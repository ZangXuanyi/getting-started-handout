\chapter{计算机的启动和输入输出}\label{chap:ics-3}

那么现在计算机内部是怎么工作的就很清晰了。但是，这仅仅是计算机“内部”的问题。计算机作为一个整体，除了内部的CPU、内存、硬盘等部件以外，还有很多外部设备，例如显示器、键盘、鼠标、网络接口等等。但我们想让这些东西一齐启动，只需要轻描淡写的按下电源键就行了，这里面到底发生了什么呢？计算机又是怎么从外界接收和发送信号的呢？本章就来带领大家了解这些问题的答案。

\section{计算机如何启动？}

我们从商店买来一台计算机，插上电源，按下电源键，计算机就启动了。这个过程发生了什么呢？硬件在这段时间内如何协同工作，使得计算机能够启动？为什么新买的计算机启动很快，而旧计算机启动很慢？为什么在更换一个性能更好的显卡之后，计算机反而启动变慢了？为了回答这些问题，我们需要了解计算机的启动过程。

计算机的启动过程可以分为以下几个步骤。

\subsection{加电自检}

实际上一个很反直觉的事情是，计算机在关机的时候也是一直需要通电的。计算机的主板上有一个小电池，叫做CMOS电池，它负责为计算机提供基本的电源；主板上还有一个芯片，叫做BIOS/UEFI芯片，它记录了当前时间、日期、硬件配置等信息。

当我们按下电源键时，主板收到“按下电源键”这个信号后，给电源发信号。于是电源率先启动，但它并不是立即给所有硬件供电，而是按严格的时间顺序先输出3.3V、5V、12V等不同的电压，自己也会不断检测这些电压是否在允许的误差值内。如果一切良好，电源会向主板发送一个“Power Good”信号，表示电源已经稳定工作。否则，主板会立即切断电源，防止其他硬件因错误的工作电压而损坏。

收到“Power Good”信号后，主板上的芯片组就会开始工作。芯片组会首先复位CPU，然后CPU从固定的地址开始执行整个计算机启动中的第一个指令，运行第一个程序——BIOS/UEFI程序，开始加电自检（POST，Power-On Self Test）。加电自检的任务是检测计算机的硬件是否正常工作，一般先按顺序检查CPU、内存、显卡，再检查其余设备。如果发现任何问题，加电自检会发出错误信号，例如蜂鸣声、错误代码等，提示用户进行修复。如果一切正常，加电自检会将控制权交给下一个程序。

\subsection{硬件初始化和配置}

POST通过后，BIOS/UEFI就会开始初始化硬件。它会为每一个PCIe\footnote{PCIe，全称Peripheral Component Interconnect Express，外设组件互连快速通道，是一种高速串行计算机扩展总线标准，用于连接主板和各种硬件设备，例如显卡、网卡、存储设备等。}设备分配总线编号、内存映射I/O空间\footnote{内存映射I/O（Memory-Mapped I/O，MMIO）是一种将外设设备的寄存器映射到计算机内存地址空间中的技术。这样，CPU可以通过读写内存地址来访问外设设备，而不需要使用专门的I/O指令。}和中断号，确保这些设备都能被操作系统正确识别。在这个时候，主板上的RGB灯、风扇、CPU超频等用户自定义配置也会被加载。

这一阶段的速度主要取决于主板固件的优化程度以及硬件的数量和类型。高端主板通常会有更好的固件优化，因此启动速度更快；而安装了大量硬件设备的计算机则需要更多时间来初始化这些设备，导致启动速度变慢。

\subsection{引导}

硬件准备就绪后，BIOS/UEFI就会开始引导操作系统。它会按照预设的引导顺序，依次检查硬盘、SSD、U盘、光驱等设备，寻找操作系统。传统的引导方式Legacy会读取硬盘首个扇区（MBR，512字节），该山区存放着一段大小为446字节的引导代码；而现代的UEFI引导方式则会读取EFI系统分区中的引导文件（通常是 \texttt{bootx64.efi} ），该文件可以存放在FAT32格式的分区中。

如果找遍整个引导顺序都没有找到操作系统，BIOS/UEFI就会发出错误信号“No bootable device”，随即终止启动过程。如果找到了操作系统，BIOS/UEFI就会将控制权交给引导加载程序（Boot Loader），开始加载操作系统。

引导加载程序又会做两件事：第一，把操作系统内核（如 \texttt{winload.efi} 、 \texttt{vmlinuz} 等）加载到内存中；第二，把启动参数（如启动分区、内核参数等）传递给操作系统内核。引导加载程序的速度主要取决于存储设备的读写速度以及引导加载程序的优化程度。

\subsection{内核加载与驱动初始化}

操作系统内核获得控制权后，会首先初始化CPU调度子系统、内存管理子系统，然后加载硬件抽象层（HAL）和必要的驱动程序。现在屏幕大概率会出现操作系统的Logo或者启动动画。随后，内核会并行地初始化其他设备，速度主要决定于磁盘性能、驱动数量、安全策略等因素。

\subsection{用户空间启动与登录界面}

现在内核初始化完毕了，可以启动第一个用户态\footnote{用户态（User Space）是指操作系统中运行应用程序的环境，与内核态（Kernel Space）相对应。用户态中的程序无法直接访问硬件资源和内核数据结构，而是通过系统调用与内核进行交互。这样可以提高系统的安全性和稳定性，防止用户程序对系统造成破坏。}进程了。在Windows中，第一个用户态进程是 \texttt{smss.exe} ，它负责启动其他系统服务和后台进程；在Linux中，第一个用户态进程通常是 \texttt{systemd} 或者 \texttt{init} 。这些进程会负责挂载系统分区、启动日志服务、启动设备管理器等，这些都被叫做“自动启动项”。

当所有的自启动项都加载完毕，登录界面出现在屏幕上，整个启动流程结束。用户输入密码后，Explorer 或桌面环境继续加载用户级程序，至此计算机完全可用。

\subsection{问题解答}

现在我们就可以解答前面提出的问题了。

\textbf{为什么新旧电脑启动速度差异巨大？}

\begin{enumerate}
  \item 新主板往往用的是UEFI Fast Boot（快速启动）技术，可以跳过一些不必要的硬件检测和初始化步骤，从而大幅提升启动速度；而旧的主板往往是全部检测，耗时长；
  \item 新电脑往往使用SSD作为存储设备，SSD的读写速度和和随机读取延迟都要显著优于传统的机械硬盘，因此引导加载程序和内核加载的速度更快；
  \item 新的操作系统往往是干净的，没有太多的自启动项，因此用户空间启动的速度更快；而旧的操作系统往往安装了大量的软件和服务，导致自启动项过多，拖慢了启动速度。
\end{enumerate}

大家完全不必要担心自己的计算机使用的不是UEFI技术，因为今年已经是2025年了，想找到BIOS主板已经非常困难了——除非你用的电脑是在2018之前买的。那么，如果你的计算机确实是旧的主板或依然缓慢，可以进入BIOS设置（在开机前猛按F2、F8、Del等，具体按键见主板说明书），看看有没有“Fast Boot”选项，启用它就能显著提升启动速度。

至于优化启动项，这个只需要别安装一堆不必要的软件就行了，而且在安装软件的时候注意把“开机启动”选项关掉（例如QQ、微信等）。

\textbf{为什么换了个高端显卡，启动反而变慢？}

实际上只有一点，也就是高端显卡的初始化时间更长。高端显卡往往有更多的功能和复杂的硬件设计，因此需要更多的时间来初始化和配置。此外，高端显卡往往需要加载更多的驱动程序和固件，这也会增加启动时间。如果主板的固件没有针对高端显卡进行优化，启动时间则会显著增加。但随着主板固件的更新和优化，这个问题会逐渐得到解决。

\begin{table}[htbp]
  \centering
  \caption{启动故障排查速查表}
  \begin{tabular}{ccc}
    \toprule
    现象 & 可能原因 \\
    \midrule
    按下电源键风扇不转 & 电源线没插、电源损坏、主板供电线松动 \\
    风扇转但没有画面 & 内存没插好、显卡供电不足、或显示器问题 \\
    主板蜂鸣器响 & 内存条松动、显卡没插好、CPU过热，具体含义见主板说明书 \\
    卡在主板Logo & 硬盘没连接好、引导顺序错误、操作系统损坏 \\
    Windows蓝屏 & 驱动程序冲突、硬件故障、系统文件损坏 \\
    Linux内核恐慌 & 硬件不兼容、驱动程序错误、文件系统损坏 \\
    \bottomrule
  \end{tabular}
\end{table}

了解启动流程后，我们就能有针对性地优化：关闭不必要的启动项、启用 Fast Boot、升级固件、更换更快的 SSD，甚至调整显卡固件设置，都能让“按下电源键到进入桌面”的时间显著缩短。

\section{计算机怎么和外界交互？}

我们日常把U盘插进接口，耳机塞进耳机孔，点击保存按钮把文件“放”进硬盘，仿佛计算机内部与外部世界之间隔着一堵透明的墙，数据像幽灵一样穿墙而过。实际上，这堵墙上有无数扇“暗门”，门后站着一群翻译官、调度员和安检员，它们共同把数据变成电压，把电压再变回数据，还要防止外设把奇怪的东西带进屋里。本节就拆开这堵墙，看看计算机究竟怎么和外界打交道。

\subsection{I/O地址和端口}

CPU 并不直接认识“鼠标”或“打印机”，它只认“地址”。x86 体系把外设抽象成一组寄存器，每个寄存器被分配一个固定或动态的 I/O 地址：早年的键盘控制器占 0x60–0x64，串口 COM1 占 0x3F8–0x3FF。CPU 用 I/O 指令像写信一样把数据塞进这些“信箱”，外设收到信后再回信，完成一次最小交互。

现代计算机中，大部分外设搬进了“内存映射 I/O”（MMIO）：显卡的几百 MB 显存、NVMe 控制器的寄存器，都被映射到一段物理地址。CPU 把它们当成普通内存读写，但背后由芯片组把地址翻译成 PCIe 事务，送到目标设备。于是，同一条 mov 指令，既可能真往内存写数据，也可能改掉了显卡的光栅化参数——地址就是门牌，门牌背后是什么，由主板上的“片选信号”决定。

\subsection{中断与DMA}

如果CPU只能靠轮询I/O地址来和外设交互，那效率会非常低下：CPU每几毫秒就得问一次“鼠标你动没动？”，这样浪费电，速度还慢。为了解决这个问题，计算机引入了中断机制。

在外设完成动作（如鼠标拖动、键盘按键）后，它会在IRQ（中断请求线）上发出一个信号，中断控制器（现代计算机一般叫APIC，高级可编程中断控制器）收到信号后，会通知CPU暂停当前工作，转而执行一个预设的中断处理程序ISR（中断服务例程），把鼠标位移、网卡数据包什么的都统统发送，处理完毕后再返回继续执行之前的任务。这样，CPU就不需要不停地轮询外设，而是等外设主动来“敲门”，大大提高了效率。

但是中断只能通知“有事”，数据还得CPU亲自搬运，而现代SSD、千兆网卡等外设的数据量巨大，CPU搬运数据的效率远远不够。为了解决这个问题，计算机引入了DMA（直接内存访问）技术。DMA会把数据直接从外设搬到内存，CPU只需要在中断处理程序中告诉DMA控制器“把数据搬到哪里”，然后继续干自己的事。这样，CPU就能腾出更多时间处理其他任务，像稳坐钓鱼台的市长；而其他外设，如网卡、显卡、声卡等也能更高效地工作，总线就像城市立交桥一样繁忙而有序。

\subsection{设备驱动}

有了I/O地址、中断和DMA，CPU就能和外设打交道了。但每个外设的工作方式都不一样，CPU怎么知道该怎么和它们交流呢？这就需要设备驱动程序，它们会把数据真正翻译成外设能理解的格式，外设再把数据按人能理解的方式反馈回来。

一般情况下，设备驱动的上层会提供一个统一的抽象，下层则用无数运算把抽象翻译成具体的数据序列。驱动还要负责电源管理，例如笔记本合上盖子的时候，显卡驱动会把显存压进内存，网卡驱动会把PHY（物理层芯片）关掉，节省电量，掀开盖子再原样恢复。一个驱动bug就可能导致系统真正的“睡死过去”，因此社区经常说驱动“占了70\%的内核代码和90\%的稳定性问题”。

\subsection{热插拔、总线枚举}

早年的打印机必须关机才敢插拔，这叫做冷插拔。因为接口没有电气隔离，插拔时会产生电弧，烧坏接口和设备，甚至把主板烧掉。为了解决这个问题，计算机引入了热插拔技术：接口上加了电气隔离电路，插拔时不会产生电弧；操作系统也会动态识别设备的插拔事件，加载或卸载驱动程序。而其背后，是总线枚举协议在默默工作：
\begin{enumerate}
  \item 新设备插入，接口芯片检测到电压变化，向主机发“Present”信号；
  \item 主机收到信号后，在总线上广播“你是什么设备？”，设备则回复自己的ID、类型等信息；
  \item 主机根据设备信息，加载相应的驱动程序，进而分配地址、中断向量、DMA通道等资源。
\end{enumerate}

\subsection{从电信号到文件：以保存U盘为例}

把“保存文件到U盘”拆成时序，就能看到整条交互链：
\begin{enumerate}
\item 用户点“保存”，应用调用  \texttt{write()}  系统调用，内核把用户缓冲区映射到页缓存；
\item 文件系统（FAT32/exFAT）在缓存里分配新簇，修改 FAT 表，生成 SCSI 命令块；
\item 内核 USB 大容量存储驱动把 SCSI 命令封装成 CBW（Command Block Wrapper），交给 xHCI 主机控制器；
\item xHCI 把 CBW 切成微帧，通过差分信号线以 480 Mbps/5 Gbps/10 Gbps 速率差分发送；
\item U 盘主控收到 CBW，把逻辑块地址翻译成 NAND 物理页，拉高就绪线；
\item 主机发起 DMA，把数据突发写入 U 盘内部缓存，U 盘回传 CSW（Command Status Wrapper）表示“写完”；
\item 内核收到 CSW，把页缓存标记为干净，应用弹出“保存成功”。
\end{enumerate}
整条链路跨越用户态、内核态、USB 总线、闪存转换层，七级抽象、十几种协议，却要在几百毫秒内完成，否则用户就会抱怨“卡了”。这不禁让人感叹计算机的精密和复杂，也难怪在物流行业中计算机属于“精密仪器”或“高价值易损货物”。

\subsection{性能与瓶颈——为什么USB3.0跑不满5Gbps？}
\begin{itemize}
\item \textbf{协议开销：} 每 1024 字节有效数据要附带 20~30 字节包头、CRC、链路控制字，实际速率 ≈ 4 Gbps；
\item \textbf{块大小：} FAT32 默认 32 KB 簇，写小文件时主控要做“读-改-写”，带宽骤降；
\item \textbf{CPU 复制：} 若主板 USB 控制器较老，数据必须经 CPU 内存复制，吃掉 10~20\% 核心；
\item \textbf{闪存限速：} 低端 U 盘使用 TLC/QLC，持续写 1 GB 后触发缓存用尽，速度从 100 MB/s 跌到 20 MB/s。
\end{itemize}
所以，接口规格只是“天花板”，真正的地板由最慢的环节——闪存颗粒、文件系统、驱动质量——共同决定。

\subsection{安全关卡——I/O 权限与恶意外设}
并非所有外设都“人畜无害”。BadUSB 攻击把 U 盘固件刷成虚拟键盘，插入后自动输入恶意命令；Thunderbolt 设备通过 DMA 可直接读写整机内存，绕过 CPU 页表保护。
现代操作系统引入多层防护：
\begin{itemize}
\item \textbf{IOMMU（VT-d、AMD-Vi）：} 把外设 DMA 也纳入地址转换，只允许访问内核提前登记的物理区域；
\item \textbf{代码签名：} Windows 要求内核模式驱动提交 EV 证书，无签名驱动默认拒绝加载；
\item \textbf{USB 授权弹窗：} macOS、GNOME 检测到键盘/网卡类设备首次插入时，要求用户物理点击“允许”，阻断自动注入。
\end{itemize}
即便如此，安全与便利仍像跷跷板：完全锁死外设，研究员的示波器、开发板就无法工作；全部放行，又给攻击者留下后门。操作系统每天都在这架跷跷板上找平衡。

\section{计算机如何联网？}

我们打开计算机，插上网线或连接到无线网络（Wi-Fi），计算机就能上网了。这个过程发生了什么呢？计算机是如何通过网络与其他计算机进行通信的？为了回答这些问题，我们需要了解计算机网络的基本原理。本节中，我们会先介绍一些网络的基本概念，然后从本机开始，逐步将网络扩展到局域网、广域网，最终到达互联网。

\subsection{带宽、传输速率、延迟和丢包率}

这四个名词用来衡量网络的性能，是日常生活中最常见的几个名词。

\textbf{带宽}指的是网络的理论最大传输能力，通常以比特每秒（bps）或字节每秒（B/s）来衡量。带宽越大，网络的传输能力就越强。例如，一个带宽为100Mbps的网络\textbf{理论上}可以每秒传输100兆比特的数据（实际可能远低于这个数值）。我们家里通网的时候说的“千兆宽带”指的就是该网络的带宽是1000Mbps=1Gbps，或125MB/s。

而传输速率、延迟、丢包率则用于衡量网络的实际表现。\textbf{传输速率}指的是网络的实际传输速率，单位也是比特每秒（bps）或字节每秒（B/s），往往显著低于带宽。例如，一个带宽为100Mbps的网络可能实际传输速率只有50Mbps或更低。\textbf{延迟}指的是数据从发送方到接收方所需的时间，通常以毫秒（ms）为单位来衡量。延迟越低，网络的响应速度就越快。例如，一个延迟为50ms的网络意味着数据从发送方到接收方需要50毫秒的时间。\textbf{丢包率}指的是在数据传输过程中丢失的数据包的比例，通常以百分比（\%）来衡量。丢包率越低，网络的可靠性就越高。例如，一个丢包率为1\%的网络意味着在每100个数据包中有1个数据包会丢失。延迟、丢包率、传输速率等指标往往会受到网络拥塞、信号干扰、硬件性能等因素的影响。

\begin{example}
  有一辆满载硬盘的卡车从北京开到上海，估计其平均传输速率、延迟和丢包率，并和现在家用网络进行对比。
\end{example}

\begin{answer}
  先估算带宽。国内高速允许最大总重量为49吨（半挂或板车），一辆半挂车空车质量在16吨以上，这里为了方便按19吨计算，因此装载了30吨的硬盘。一块企业级数据盘容量按30TB（$3\times 10^{13}$ B）计算，自重约700克；算上保护盒等，按1kg计算，因此一辆卡车装了$3\times 10^4$块硬盘，总容量为$9\times 10^{17}$ B，或者0.9EB。

  卡车在高速公路上最大时速在100到90千米每小时不等。按90千米每小时计算，北京到上海约1200千米，则行驶时间大概13.3小时，即$4.8\times 10^4$秒，因此传输速率用总数据量除以时间，得到约$1.9\times 10^{13}$B/s，即19TB/s，约合\textbf{152Tbps}。该数字非常惊人，是目前家用网络的近两万倍。

  下面估计延迟。和常规网络按数据包发送的方式不同，卡车运输是整体运输，或者说卡车本身就是一个大“数据包”，因此延迟等于运输时间，也就是从北京到上海的时间，约13.3小时，即\textbf{$4.8\times 10^4$秒}。

  下面估计丢包率。只要这个车没出事故、没被劫持、没整个掉沟里，那么就可以用公路运输HDD货物损失率0.02\%到0.05\%来充当丢包率。另外，如果出事故，则丢包率为100\%，而按照中国相关统计数据，公路运输百万公里事故数约为1起，因此完全可以忽略不计。综上，\textbf{丢包率约为0.05\%}。

  相对的，现在家用网络的传输速率大概在100MB/s到1GB/s之间，延迟大概在10ms到100ms之间，丢包率大概在0.1\%到1\%之间。可以看到，卡车运输的传输速率远远高于家用网络、丢包率显著低于家用网络，能和最优质的光纤媲美，但是延迟则高得离谱，完全无法进行实时操作。另外，卡车运输还受天气、交通等因素影响，稳定性无法和网络传输相提并论。
\end{answer}

在以往的计算机教材中总是出现一句话：“永远不要小看一辆满载磁带的卡车，其带宽远远超过了家庭网络。”看起来现在也差不多，只不过是把磁带换成了硬盘罢了；实际上，即使是2025年，把1EB数据从北京运到上海这个任务，最经济、最快速的方案依然是物流，其速度甚至能把5GB/s的高端光纤专线按在地上摩擦，成本更是低得多；只要不是那么要求时效性，物流依然是传输超大量数据的首选方案。

上述例子也提示我们怎么选择数据传输方式：GB级别的数据，可以使用任意网络途径传输；TB级别的数据，考虑使用专业的数据传输服务；PB级别的数据，考虑走光纤专线；EB级别的数据，则应考虑物流途径。要是数据量更大，那比起你把数据运过去，不如让对面把计算任务运过来。当然，上述数据是对于企业级别的网络而言的，个人用户的网络情况往往更极端，TB级别数据就可以考虑走快递等物流途径了；例如想把某些大文件从大连运送到沈阳，走网络可能需要几天时间才能传输完，而自行开车一天就能送到

\subsection{内网和外网}

我们在日常生活中，常常会听到“内网”和“外网”这两个词。内网是指一个局域网内部的网络，通常用于家庭、学校或者公司等小范围的网络。内网中的计算机可以通过路由器或者交换机等设备连接到外网。外网是指互联网上的网络，通常用于连接不同的局域网和广域网。

内网和外网的IP地址往往是不同的。内网IP地址通常是私有的IP地址，仅在内网中有效（例如每一个地级市都可能有一个“二中”，但是在不同的市称呼“二中”指的不是同一个学校）；而外网IP地址全球唯一，互联网可以访问（例如“东港二中”）。例如大名鼎鼎的 \texttt{8.8.8.8} 是Google的公共DNS服务器的IP地址，它是一个外网IP地址。如果在内网中访问该地址，则可能访问到的不是Google的DNS服务器，而是内网中的某个设备。

\subsection{网络协议}

网络协议是计算机之间进行通信的规则和约定。它定义了计算机如何发送和接收数据，以及如何处理错误和异常等情况。常见的网络协议有TCP/IP、HTTP、FTP等。不同的网络协议适用于不同的应用场景，例如TCP/IP协议适用于可靠的数据传输，而HTTP/HTTPS协议适用于Web应用程序的通信、UDP适用于精度要求不太高的实时通信等。

\subsection{网络设备}

网络设备是用于连接计算机和其他设备的硬件设备。常见的网络设备有路由器、交换机、集线器等。\textbf{路由器}用于连接不同的网络，并且可以根据网络协议进行数据转发；\textbf{交换机}用于在同一局域网内连接多个设备，并且可以根据MAC地址进行数据转发；\textbf{集线器}用于将多个设备连接到同一个网络，但不具备智能转发功能。

\textbf{光网络单元}（光猫，ONU）是用于将数字信号转换为光信号的设备，通常用于连接到光纤。光猫可以将计算机发送的数据转换为模拟信号，并且将接收到的模拟信号转换为数字信号。家用的光纤宽带通常是通过光猫连接到互联网的。

目前家用的路由器往往集成了光猫和交换机的部分功能，因此我们往往不需要像以前一样购买一大堆设备了。

下面，我们将会逐步讲述计算机从开机到联网，乃至访问互联网、数据传输的全过程。

\subsection{网卡上线}

我们开机，电脑POST、初始化硬件、引导操作系统。操作系统走完启动流程，内核把驱动一个个唤醒。轮到网卡的时候，它还在睡觉。网卡驱动这时候会给MAC控制器喂一口“复位”寄存器，然后写EEPROM里面的MAC地址\footnote{MAC地址是网卡的唯一标识符，由制造商在生产时烧录到EEPROM中，全球唯一。}。这时候，网卡才睡醒：它开始“打拍子”，往双绞线\footnote{也就是“网线”，无线网卡则是收发无线信号。}里面打1000BASE-TX\footnote{1000BASE-TX，全称Gigabit Ethernet over Twisted Pair，千兆以太网双绞线传输标准，是一种以太网物理层协议，支持在双绞线上以1Gbps的速率传输数据。它使用4对双绞线进行全双工通信，采用了先进的编码和调制技术，以提高传输效率和抗干扰能力。}的NLP\footnote{NLP，全称Normal Link Pulse，正常链路脉冲，是以太网物理层协议中的一种信号，用于表示网络连接的存在和状态。在100BASE-TX和1000BASE-TX等以太网标准中，NLP信号通过在双绞线上周期性地发送脉冲来维持链路的活跃状态。}信号，并监听对面有没有回音。对面是交换机，如果一切正常会回复FLP\footnote{FLP，全称Fast Link Pulse，快速链路脉冲，是以太网物理层协议中的一种信号，用于表示网络连接的存在和状态。在100BASE-TX和1000BASE-TX等以太网标准中，FLP信号通过在双绞线上周期性地发送脉冲来维持链路的活跃状态。}信号。网卡收到FLP信号后，就知道对面有人了，接下来就可以开始协商速率、双工模式等参数，最终进入“上线”状态，链路灯两栖，网卡向操作系统抛NETDEV\_UP事件，表示“我上线了”。

\subsection{DHCP：办临时身份证（IP）}

现在协议栈还是光秃秃的，只有一个MAC地址，别的什么都没有。于是，网卡构造一个以太网广播包，目的是FF:FF:FF:FF:FF:FF，来源为自己，Ethertype\footnote{Ethertype是以太网帧头中的一个字段，用于标识上层协议类型。它是一个16位的无符号整数，通常以十六进制表示。例如，IPv4的Ethertype为0x0800，IPv6的Ethertype为0x86DD，ARP的Ethertype为0x0806。}为0x0800（IPv4），里面是UDP源端口68、目的端口67的DHCP Discover报文，走UDP\footnote{UDP，全称User Datagram Protocol，用户数据报协议，是一种无连接的传输层协议，用于在计算机网络中传输数据。与TCP（传输控制协议）不同，UDP不提供可靠的数据传输和流量控制，因此适用于对实时性要求较高但对数据完整性要求较低的应用场景，如视频流、在线游戏等。}协议发走，表示“我来了，给我分个IP地址吧”。

交换机收到内容后，这个包就洪泛到所有端口；路由器则把广播改单播，扔给DHCP服务器\footnote{DHCP服务器通常是路由器自带的，也可以是专门的DHCP服务器。}。DHCP服务器收到请求后，查池子，挑一个空闲的IP，回复：192.168.1.123/24，租期86400秒，网关192.168.1.1，DNS 8.8.8.8\footnote{这里的IP地址、网关、DNS服务器地址仅为示例。}。随即终端回Request、服务器回ACK\footnote{ACK，全称Acknowledgment，确认，是计算机网络中的一种控制信息，用于确认数据包的接收和传输。在TCP协议中，ACK是一个重要的标志位，用于表示接收方已经成功接收到发送方发送的数据包，并通知发送方可以继续发送下一个数据包。}，一来一回四个包，俗称DORA（Discover-Offer-Request-Ack）。至此，计算机就有了临时身份证：IP地址、子网掩码、网关、DNS服务器等信息。如果我们抓包的话，会发现这些包的Transaction ID都是一样的，用于标识同一个DHCP会话，像一起开黑的暗号，匹配不上就丢弃掉，防止隔壁老王冒领。

收到这个“临时身份证”后，操作系统就把IP地址、子网掩码、网关等信息写进内核数据结构。

\subsection{ARP：户籍管理人员}

现在计算机有了IP地址，可以和同一子网内的其他计算机通信了。但有了IP是不够的，数据包最终还需要知道发送到哪里，这依赖于MAC地址。协议栈查路由，发现网关192.168.1.1在直连网段，于是构造一个ARP Request广播：“谁有192.168.1.1？告诉192.168.1.123！”

网关会收到该信息，回复这个Unicast\footnote{Unicast，单播，是计算机网络中的一种通信方式，指数据包从一个发送方传输到一个特定的接收方。与广播（Broadcast）和组播（Multicast）不同，单播通信只涉及两个节点，即发送方和接收方。} ARP Reply：“192.168.1.1对应74:ac:5f:xx:xx:xx。”ARP会缓存60秒，防止频繁广播。

ARP还能防止主机的IP冲突：如果两台主机IP相同，会同时回复包：duplicate address detected，提示用户修改IP。

\subsection{路由：熟知路径的快递员}

假如我们ping了8.8.8.8。于是，协议栈就会查最长前缀匹配：
\begin{enumerate}
  \item 8.8.8.8不在192.168.1.0/24网段内，不能直连，走默认路由192.168.1.1，构造以太网帧，目的MAC为网关，源MAC为自己，Ethertype为0x0800（IPv4）；
  \item 交换机查CAM表，发现不认识目的MAC，把帧扔到上联口；
  \item 路由器收到帧，剥掉二层头，查三层转发表，找到下一跳10.0.0.2\footnote{这个IP地址仅为示例。}，TTL减1\footnote{TTL，全称Time To Live，生存时间，是计算机网络中的一个字段，用于限制数据包在网络中的寿命。它是一个8位的无符号整数，表示数据包在网络中可以经过的最大跳数（hop count）。每当数据包经过一个路由器时，TTL值就会减1，当TTL值减到0时，数据包就会被丢弃，以防止数据包在网络中无限循环。}，重新构造以太网帧，目的MAC为下一跳；
  \item 运营商核心继续查BGP路由，AS\_PATH\footnote{AS\_PATH，全称Autonomous System Path，是边界网关协议（BGP）中的一个重要属性，用于描述数据包在自治系统（AS）之间的路径。自治系统是指由一个或多个网络运营商管理的网络集合，具有统一的路由策略和管理权限。}像快递单一样，经4837、15169\footnote{4837是中国电信的AS号，15169是Google的AS号。}等多个AS，最终到达目的地Google DNS服务器。
\end{enumerate}
整个过程涉及多层协议、多级路由器，最终实现了从本地计算机到全球互联网的通信。以上跳跃中，每一跳的TTL都会减去1，如果TTL减到0，数据包就会被丢弃，并发送ICMP\footnote{ICMP，全称Internet Control Message Protocol，互联网控制消息协议，是一种用于在计算机网络中传输控制信息的协议。它是TCP/IP协议族中的一个重要组成部分，主要用于报告网络错误、诊断网络问题以及传输网络状态信息。}的超时消息给源主机，防止数据包在网络中无限循环。这也是Linux中traceroute\footnote{在Windows中叫tracert。}命令的原理：把TTL从1开始逐渐增大，记录每一跳的路由器地址和响应时间，绘制出数据包从源主机到目的主机的路径。

\subsection{NAT：内网到外网的门房}

现在大部分家庭网络都使用私有IP地址（如192.168.x.x、10.x.x.x等），这些地址在互联网中是不可路由的。为了让家庭网络中的计算机能够访问互联网，路由器会使用NAT（网络地址转换）技术，把私有IP地址转换成公共IP地址。当计算机发送数据包到互联网时，路由器会把源IP地址改成自己的公共IP地址，并记录下这个映射关系；当互联网的服务器回复数据包时，路由器会根据映射关系，把目的IP地址改回私有IP地址，然后转发给计算机。

NAT表项默认120秒无流量则过期，防止表项爆满，于是微信等软件就需要发送“心跳包”来维持连接——这就是为什么有时候没有使用某些软件但这些软件却一直在联网。

\subsection{DNS：域名解析翻译官}

光有IP地址可不行，这太难记了：8.8.8.8是Google，那百度的呢？Bing的呢？逐个记忆IP地址太麻烦了，即使是查表也不方便。为了解决这个问题，计算机引入了DNS（域名系统）技术，把域名（www.google.com）映射到IP地址（8.8.8.8）。容易看到，域名实际上就是我们常说的“网址”\footnote{严格来说，网址（URL）包含了域名、路径、查询参数等信息，而域名只是网址的一部分。例如， \texttt{https://www.example.com/path?query=1} 是一个完整的网址，其中 \texttt{www.example.com} 是域名。}。

浏览器里输入www.google.com后，计算机会先查 \texttt{/etc/hosts} 文件，再查本地DNS缓存，如果没有命中，就会向配置的DNS服务器发送DNS查询请求。DNS服务器收到请求后，会查找自己的数据库，如果找到了对应的IP地址，就会把结果返回给计算机；如果没有找到，就会向根DNS服务器、顶级域DNS服务器等递归查询，最终找到结果并返回给计算机。计算机收到结果后，就可以使用这个IP地址与Google服务器进行通信了。

DNS也是非常容易受攻击的暗礁区：DNS劫持、DNS污染等攻击手段可以篡改DNS查询结果，甚至有些情况下还可以劫持NXDOMAIN\footnote{NXDOMAIN，全称Non-Existent Domain，是DNS查询中的一个响应代码，表示所查询的域名不存在。当计算机向DNS服务器发送查询请求时，如果DNS服务器无法找到对应的域名记录，就会返回NXDOMAIN响应，告诉计算机该域名不存在。}，把不存在的域名解析到攻击者指定的IP地址，从而实现钓鱼网站、插广告，于是就有了DoH（DNS over HTTPS）等加密DNS协议，防止中间人篡改DNS查询结果。

\subsection{TCP三次握手：可靠连接的建立}

现在我们有了IP地址，可以和服务器通信了。但走UDP直接发送数据包是不可靠的：数据包可能丢失、乱序、重复等。为了解决这个问题，计算机引入了TCP（传输控制协议）技术，通过三次握手建立可靠的连接。

假如浏览器拿到47.246.24.134（淘宝），发起SYN\footnote{SYN，全称Synchronize，是TCP协议中的一个标志位，用于表示连接请求。当客户端想要与服务器建立TCP连接时，会发送一个带有SYN标志的数据包，表示“我想和你建立连接”。服务器收到这个数据包后，会回复一个带有SYN和ACK标志的数据包，表示“我同意建立连接，并确认你的请求”。最后，客户端再发送一个带有ACK标志的数据包，表示“连接建立成功”。}包，序列号随机x；服务器则回复SYN-ACK包，序列号随机y，确认号x+1；浏览器再回复ACK包，确认号y+1。至此，连接建立完成，双方各自维护源IP、源端口、目的IP、目的端口四元组，以及序列号、滑动窗口、拥塞窗口等状态信息，确保数据传输的可靠性和有序性。

TCP虽然比UDP慢，但它把不可靠的IP变成了可靠的字节流，适合传输文件、网页等需要完整性的应用。

\subsection{HTTP：网页浏览的协议}

现在我们可以和服务器通信了，但数据包还是二进制的，浏览器看不懂。为了解决这个问题，计算机引入了HTTP（超文本传输协议）技术，把数据包格式化成文本，方便浏览器解析和渲染。

假如浏览器访问 \texttt{http://www.example.com} ，首先会发起一个HTTP GET请求，包含请求行、请求头等信息；服务器收到请求后，会返回一个HTTP响应，包含状态行、响应头和响应体等信息。浏览器收到响应后，就可以解析HTML、CSS、JavaScript等内容，渲染出网页。HTTP是无状态的协议，每个请求都是独立的，服务器不会记住之前的请求状态。

\subsection{TLS：加密数据的押运者}

HTTP传输的数据是明文的，容易被窃听和篡改。为了解决这个问题，计算机引入了HTTPS（HTTP安全）技术。该技术通过TLS技术的握手协商加密算法和密钥，确保数据传输的机密性和完整性。

假如浏览器访问 \texttt{https://www.example.com} ，首先会发起TLS握手：客户端发送ClientHello消息，包含支持的TLS版本、加密套件等信息；服务器回复ServerHello消息，选择TLS版本和加密套件，并发送数字证书；客户端验证证书的合法性，然后生成预主密钥，使用服务器的公钥加密后发送给服务器；服务器使用私钥解密，双方根据预主密钥生成对称加密密钥。握手完成后，双方就可以使用对称加密算法（如AES）进行数据传输了。

TLS在性能上比较差，因此也是优化的重点：AES-NI指令集\footnote{AES-NI，全称Advanced Encryption Standard New Instructions，是英特尔公司推出的一组用于加速AES（高级加密标准）算法的指令集扩展。AES-NI指令集包含了一系列新的CPU指令，可以显著提高AES加密和解密的性能，减少加密操作对CPU资源的占用。}、ChaCha20算法\footnote{ChaCha20是一种流密码算法，由Daniel J. Bernstein设计。它基于Salsa20算法，具有更高的安全性和性能。ChaCha20使用256位密钥和64位随机数，能够在软件实现中提供高效的加密和解密操作。由于其优越的性能和安全性，ChaCha20被广泛应用于各种加密协议和应用程序中，如TLS 1.3、SSH等。}、0-RTT握手\footnote{0-RTT，全称Zero Round Trip Time，是TLS 1.3协议中的一种优化技术，旨在减少连接建立的延迟。在传统的TLS握手过程中，客户端和服务器需要进行多次往返通信（RTT）来协商加密参数和密钥，这会导致较高的延迟。0-RTT技术允许客户端在第一次握手时发送加密数据，而不需要等待服务器的响应，从而实现“零往返时间”的连接建立。这种技术特别适用于需要快速连接建立的应用场景，如移动设备和实时通信等。}等技术都在不断提升TLS的性能。

\subsection{HTTP/2和QUIC：更快的数据传输}

HTTP/1.1只有一条TCP连接，只能串行传输数据，效率低下。为了解决这个问题，计算机引入了HTTP/2技术，通过多路复用、头部压缩等技术，提高数据传输的效率。HTTP/2使用二进制帧格式，把多个请求和响应复用在一条TCP连接上，减少了连接建立和关闭的开销。但是该技术仍然依赖TCP，受到TCP头阻塞问题\footnote{TCP头阻塞问题是指在TCP协议中，由于数据包的顺序传输和确认机制，当一个数据包丢失或延迟时，后续的数据包即使已经到达接收端，也无法被处理，导致整个连接的传输效率下降。这种现象被称为“头阻塞”，因为它阻塞了后续数据包的处理。}的影响，丢一个包则全车等人。

于是，Google把TCP+TLS搬进UDP，改名为QUIC（快速UDP互联网连接），并在HTTP/3中使用QUIC作为传输协议。QUIC通过内置的拥塞控制和多路复用，进一步提升了数据传输的效率和可靠性。QUIC还支持0-RTT连接建立，减少了握手延迟，提高了用户体验。

\subsection{Wi-Fi：空气中的以太网}

上述内容其实基本上全都是有线网络的原理。而无线网络则是“空气中的以太网”。STA（Station）扫描AP\footnote{AP，全称Access Point，接入点，是无线局域网（WLAN）中的一种网络设备，用于连接无线设备（如笔记本电脑、智能手机等）到有线网络（如以太网）。AP通常通过有线连接到路由器或交换机，然后通过无线信号与无线设备进行通信。AP可以提供无线覆盖范围，允许多个无线设备同时连接到网络，实现无线数据传输和互联网访问。}的SSID（分主动和被动两种方式），找到SSID后发起关联请求，AP回复关联响应，双方建立连接。然后，STA发起DHCP请求，获取IP地址等信息，最终实现联网。

现代Wi-Fi有不同的频段，主要频段有2.4GHz和5GHz，最新的Wi-Fi 6E还引入了6GHz频段。2.4GHz仅有3不重叠的信道，邻居家路由器也能像广场舞大妈一样抢占地盘，只能让“城管”RTS/CTS来协调，但吞吐率低；5GHz有更多信道，干扰少，速度更快，但穿墙能力差。目前所见的6GHz路由器还不多，速度更快但穿墙能力更差。

\begin{tip}
  出现上述现象的原因是，Wi-Fi本质上还是电磁波，频率越高，波长越短，穿透能力越差。而频率更短的情况下，单位时间内能传输的数据量就越大，因此速度更快。

  我们发现，Wi-Fi所用电磁波的频率随着技术发展不断提高。但是6GHz波段距离可见光（频率约380THz到750THz）还有一定距离。因此我们设想：将来有一天可不可能\textbf{用可见光}来做无线通信呢？答案是肯定的，已经有相关的研究和应用，但眼见的未来暂时还没办法见到可见光在传输方面的大规模应用，目前仅有光纤通信使用可见光波段来传输数据（但仍局限于红光和近红外光波段）。

  但是让人哭笑不得的是，很久以前的笔记本电脑上确实存在一个红外端口，用来传输数据的，速度还挺慢的，现在都没有了。至于为什么当时红外光传输速度那么慢……这里卖个关子，请同学们自行查阅相关资料吧。
\end{tip}

\subsection{CDN：网络上的缓存}

现代互联网中，CDN（内容分发网络）技术被广泛应用于加速网页加载和视频播放。CDN通过在全球范围内部署大量的边缘服务器，把热门内容缓存到离用户更近的位置，减少了数据传输的距离和延迟，提高了用户体验。

假如我们使用淘宝，图片在上海被北京用户请求，如果每一次都走杭州那延迟就很高了。CDN则会把图片缓存到北京的边缘服务器（例如天津），用户DNS解析会解析到天津去，这样用户请求图片时，就能直接从天津的边缘服务器获取，显著提升加载速度，这显然是模仿了CPU“缓存”的思路——但非常大规模的缓存，也很好用。

\subsection{代理和VPN：外网到内网的桥梁}

内网像一座有围墙的城堡。很多数据库、OA、邮件服务器等重要资源都部署在内网中，也只认内网IP地址。但是需求是多样的：有时候我们在校外打比赛或休假，但还要访问北京大学的内网资源，这怎么办？——请一位门房代为传话即可，这就是代理和VPN的作用。

代理是一种中间人服务，用户把请求发送给代理服务器，由代理服务器代为访问目标资源，然后把结果返回给用户。或者说，我们可以把代理看成雇了一个人帮我们办事：我们把想要的东西告诉他，他去城堡里取回来，然后交给我们。这样，用户就可以通过代理服务器访问内网资源，而不需要直接连接到内网中。常见的代理协议有HTTP代理、SOCKS代理等。北京大学早年确实提供过这个服务，但现在已经被VPN取代了。

而VPN（虚拟专用网络）则是通过加密隧道，把用户的计算机直接连接到内网中，仿佛用户的计算机就在内网中一样。这样，用户就可以直接访问内网资源，而不需要通过代理服务器。VPN通常使用IPSec、OpenVPN等协议来实现加密和认证，确保数据传输的安全性和完整性。这就像是用一条超超超长的虚拟网线，把用户的计算机直接连接到内网中，帮你虚拟“回校”。

举例：北京大学VPN。