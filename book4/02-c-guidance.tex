\chapter{C语言入门}\label{chap:c-guidance}

本章默认大家此前没有任何编程基础。

所谓“编程”，就是让计算机按照我们想要的方式工作。计算机本身并不会思考，它只能听从我们的指令去做事。因此，我们需要用一种计算机能够理解的语言来告诉它我们想要它做什么，这种语言就叫做“编程语言”。

C语言是最早的编程语言之一，在上世纪70年代被发明出来。它是一种结构化的、过程式的编程语言，具有高效、灵活和可移植等特点。C语言广泛应用于系统软件开发、嵌入式系统、游戏开发等领域，著名软件如Linux内核、Git、GCC、Vim等简单但强大的软件都是用C语言编写的；Python的官方实现也是C语言（Cpython），很多高性能的Python库（如NumPy、Pandas、sklearn的大部分等）也是用C语言写的。

安装C编译器的方法见第\ref{sec:c-install-on-windows}节，这里不再赘述。我们要写C，首先应该创建一个以 \texttt{.c} 结尾的文本文件，例如 \texttt{hello.c} 。然后，在这个文件中写入C代码，最后使用C编译器将其编译成可执行文件。而对于初学者而言，编译这种脏活累活全部丢给VS Code的C/C++扩展来做就好了。

\section{C语言的基本语法}

\subsection{你的第一个C程序}
\begin{lstlisting}
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
\end{lstlisting}

把这些内容敲到你的C文件中，保存，编译并运行（如果你按照我所推荐的方式安装并配置好了，那么按下 \texttt{F5} 就可以编译并运行了），你就会看到终端上输出了 \texttt{Hello, World!} 。

上述程序就算是一个最简单的C程序了。

第一次写C的时候，记住以下事项：

\begin{enumerate}
  \item 程序有入口；
  \item 先声明，再计算；
  \item 算完告诉外面。
\end{enumerate}

剩下的内容和说话一样，只不过是用C的语法来表达。我们说话的句号在C中是分号。

逐行拆解上述示例代码：
\begin{itemize}
  \item  \texttt{\#include <stdio.h>} ：告诉编译器，我要用输入输出工具。
  \item  \texttt{int main()} ：程序的入口函数，告诉电脑：程序从这里开始执行。 \texttt{int} 表示这个函数返回一个整数值。
  \item  \texttt{printf("Hello, World!\textbackslash n");} ：把东西一股脑全送到屏幕上。 \texttt{\textbackslash n} 表示换行。
  \item  \texttt{return 0;} ：返回0，告诉操作系统：一切OK。除非你知道你在做什么，否则这里不要改成其他数字。本行就是“算完告诉外面”。
\end{itemize}

在C中，有两种代码：一种是以 \texttt{\#} 开头的预处理指令，另一种是常规语句。预处理指令指的是在编译之前进行的一些操作，例如包含头文件、定义宏等，详见\ref{sec:macro}。常规语句则指的是程序的主要逻辑。常规语句应以分号结尾，且在结尾之后应换行（除非写注释）。压行是不好的行为，会影响代码的可读性，尽量自然地换行。

\subsection{变量及其运算}

编程的本质是对数据进行操作，而经过操作的数据可能会变化。对于会变化的数据，我们称之为“变量”。而这些量也有不同的类型，例如“人数”肯定是整数，而“身高”则可能是小数。

在C中，变量要\textbf{先声明，再使用。}声明的方法是：先写类型，再写名字。这个“名字”是我们之后用来使用这个变量的标识符，类似别人提到“张三”就能对应到这个人的头上。这个使用在编程上被叫做\textbf{调用}。

取名有一定的规则：不能用已经用过的名字，这个名字包括C保留的关键字和你自己已经定义过的名字；名字只能包含字母、数字和下划线，不能包括其他符号，且不能以数字开头；名字区分大小写，例如 \texttt{age} 和 \texttt{Age} 是两个不同的名字。

\begin{lstlisting}[language=C]
    int age = 18; // 声明一个整数变量age，并初始化为18
    double pi = 3.14; // 声明一个双精度浮点数变量pi，并初始化为3.14
    char grade = 'A'; // 声明一个字符变量grade，并初始化为'A'

    age = 19; // 把age的值改为19
\end{lstlisting}

这些语言本质上都可以用自然语言解释为：我有个xx叫xx，它的值是xx。例如第一行代码：我有个整数叫age，它的值是18。如果之后我想用age这个变量，就可以直接写 \texttt{age} ，不需要再次声明“我有个整数叫age”了。

上述 \texttt{int} 等四个排在第一个的关键字是变量的类型，分别表示整数、双精度浮点数、字符和布尔类型。在C中，变量类型不能在运行时改变，一旦声明则类型固定，因此C也被归类为“静态类型”语言。

上述声明中的等号和数学中的等号\textbf{不相同}。在这里，等号的意思是“赋值”，指的是让等号左边的值变成等号右边的值。也就是说，等号右边的值会被计算出来，然后存储到等号左边的变量中。

而变量的运算则和数学差不多，比方说
\begin{lstlisting}
    int a = 10;
    int b = 20;
    int c = a + b;
    c = a * 2;
    c += 5;
\end{lstlisting}

第三行中， \texttt{int c = a + b} 的意思是“我要创建一个变量c，把a+b的结果放进去”。可以看到，从这一行以后再提到c，就不需要再写 \texttt{int} 了，因为电脑已经知道c是个什么东西了；就像我们告诉李四“有个人叫张三”，之后再提到张三的时候就不需要再说“有个人叫张三”了。

下一行 \texttt{c = a * 2} 的意思是“我要把a乘以2的结果放到c里面，c以前不管是什么我都不要了”，而再下一行 \texttt{c += 5} 的意思是“我要把c加上5”。在上述代码中，我们发现变量c的值会随着每一行代码的执行而变化，例如第三行代码执行后，c的值变成了30；第四行代码执行后，c的值变成了20；第五行代码执行后，c的值变成了25。所以说c是一个变量。

变量的值也可以在声明时不确定（初始化），例如 \texttt{int a;} 这样也是可以的。如果在声明的时候不初始化局部变量的值，那么这个变量的初始值将会是一个\textbf{未定义行为}，这个值取决于内存中该位置之前存储的内容。我们不能依赖于这个，因此最好在声明变量的时候就给它赋初始值，例如 \texttt{int a = 0;} 。对于全局变量，如果不初始化，编译器会自动将其0初始化。

让我们看看常见的运算符：
\begin{itemize}
  \item 四则运算： \texttt{+} （加）、 \texttt{-} （减）、 \texttt{*} （乘）、 \texttt{/} （除）。注意，除法运算中，如果两个整数相除，结果仍然是整数，余数会被舍弃。
  \item 取模： \texttt{\%} ，表示取余数。例如 \texttt{5 \% 2} 的结果是1，因为5除以2的余数是1。
  \item 自增和自减： \texttt{++} （自增）和 \texttt{--} （自减）。例如， \texttt{a++} 表示将a的值加1， \texttt{b--} 表示将b的值减1。
\end{itemize}
不要过分纠结 \texttt{i++} 和 \texttt{++i} 的区别，初学者完全可以认为这两个和 \texttt{i += 1} 没有区别。

\begin{caution}
  尽量单独使用 \texttt{++} 和 \texttt{--} ，不要把它们和其他运算混在一起使用，更不要在同一个表达式中对同一个变量使用多次 \texttt{++} 或 \texttt{--} 。例如， \texttt{a = b++} 虽然不推荐但还勉强可以，但是 \texttt{a = b++ + b++} 和 \texttt{i = i++} 都是未定义行为。一个饱受诟病的题目“ \texttt{i = 3, i++ + i++ = ?} ”答：这个题目是错误的，至少是不良定义的。不同的编译器对上述代码的处理方式不同。

  笔者个人从工程的眼光上看来，非常不建议弄出 \texttt{a = b++} 这类的代码，尽管这类代码在竞赛中会让很多OIer感到Tricky，但是在工程中会让人无比恼火。如果想先用b的值再加1，可以写成 \texttt{a = b; b++;} ；如果想先加1再用b的值，可以写成 \texttt{b++; a = b;} 。上述写法一般只有非常约定俗成的场合才会使用，例如 \texttt{while(T--)} 或者 \texttt{stk[++top]=x} ——不过即使是我，也更习惯于写成\lstinline[language=C++]|for(;T>0;T--)| 和 \lstinline[language=C++]|stack<int> stk; stk.push(x);|。
\end{caution}

\subsection{注释}

注释是代码中的说明文字。它们会被编译器忽略，因此注释完全是给编写者和阅读者看的。

在C中，注释有两种方法来写：
\begin{itemize}
  \item 单行注释：使用 \texttt{//} ，例如 \texttt{// 这是一个单行注释} 。注释符号后面的内容会被编译器忽略，直到行尾为止。
  \item 多行注释：使用 \texttt{/* ... */} ，例如 \texttt{/* 这是一个多行注释 */} 。两个注释符号之间的内容会被编译器忽略，可以跨越多行。
\end{itemize}

在阻止部分代码执行的时候，我们一般不习惯于直接删除这些代码，而是使用注释。这样做的好处是可以留痕，便于以后的恢复（解注释）；这就是程序员们常说的“注释掉”代码。在VS Code等编辑器中，常用的一键注释是 \texttt{Ctrl + /} ，它会自动将光标所在的一行或多行代码注释掉。

\subsection{输入、输出及其格式化}

输入和输出是程序与外界进行交互的方式。在C中，常用的输入输出函数有 \texttt{printf} 和 \texttt{scanf} 。这两个函数都定义在 \texttt{stdio.h} 头文件中，因此在使用它们之前需要包含该头文件。

\texttt{printf} 用于输出数据到屏幕上，其基本语法如下：
\begin{lstlisting}[language=C]
    printf("格式字符串", 参数1, 参数2, ...);
\end{lstlisting}

而 \texttt{scanf} 用于从键盘读取输入，其基本语法如下：
\begin{lstlisting}[language=C]
    scanf("格式字符串", &变量1, &变量2, ...);
\end{lstlisting}
上述输入中的\&符号不能省略，也就是需要写成 \texttt{\&a} 的形式。

那这个“格式字符串”是什么东西呢？它是一个字符串，其中包含了文本和格式说明符。格式说明符用于指定要输出或输入的数据类型和格式。常见的格式说明符有：
\begin{itemize}
  \item \texttt{\%d} ：表示整数类型。
  \item \texttt{\%f} ：表示浮点数类型。
  \item \texttt{\%c} ：表示字符类型。
  \item \texttt{\%s} ：表示字符串类型。
\end{itemize}

例如，下面的代码演示了如何使用 \texttt{printf} 和 \texttt{scanf} 进行输入输出：
\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int age;
    printf("请输入你的年龄：");
    scanf("%d", &age); // 这里的输入是1个整数
    printf("你输入的年龄是：%d\n", age); // 这里你看到的的输出是：“你输入的年龄是：xx”，xx是age的值
    return 0;
}
\end{lstlisting}

在字符串中，除了上述格式说明符，还可以有控制字符，也就是类似于上文\texttt{\textbackslash n} 这样的东西。上述代码中的 \texttt{\textbackslash} 是“转义符号”，表示后面的字符有特殊含义，而不是其本身的含义。
常见的控制字符有：
\begin{itemize}
  \item \texttt{\textbackslash n} ：换行符。
  \item \texttt{\textbackslash t} ：制表符（Tab）。
  \item \texttt{\textbackslash r} ：回车符。
  \item \texttt{\textbackslash "} ：双引号字符。
  \item \texttt{\textbackslash '} ：单引号字符。
  \item \texttt{\textbackslash \textbackslash} ：反斜杠字符。
  \item \texttt{\%} ：百分号字符。
  \item \texttt{\textbackslash 0} ：字符串结束符。
\end{itemize}

\begin{exercise}[加减运算]
    写一个程序，接受两个整数输入，然后输出它们的和、差。

    \textbf{程序输入}：两个整数a和b，用空格分割。
    
    \textbf{程序输出}：两行，第一行输出$a+b$，第二行输出$a-b$。
\end{exercise}

\begin{answer}
    由于这是第一个题，我们就给出一个参考答案吧。这个题目的答案是显然的，但需要让同学们知道这种题目应该以一种什么形式去写。

    在OJ等平台上，我们一般需要提交一个完整的程序。

    首先，我们要处理问题的核心逻辑：加法和减法。
    \begin{lstlisting}[language=C]
        int a = 0;
        int b = 0;
        
        int sum = a + b; // 计算和
        int diff = a - b; // 计算差
    \end{lstlisting}
    下一步，处理输入输出：
    \begin{lstlisting}[language=C]
        scanf("%d %d", &a, &b); // 读取输入
        printf("%d\n", sum); // 输出和
        printf("%d\n", diff); // 输出差
    \end{lstlisting}
    我们应该把这些代码按照一个正确的顺序组织起来，并且放在一个完整的C程序框架内：
    \begin{lstlisting}[language=C]
    #include <stdio.h>

    int main() {
        int a = 0;
        int b = 0;
        
        scanf("%d %d", &a, &b); // 读取输入
        
        int sum = a + b; // 计算和
        int diff = a - b; // 计算差
        
        printf("%d\n", sum); // 输出和
        printf("%d\n", diff); // 输出差
        
        return 0;
    }
    \end{lstlisting}
    这样，我们就完成了这个练习题的解答。

    OJ等自动评测平台会根据题目的输出格式来验证程序的正确性，因此我们必须严格按照题目要求来编写程序，不要输出其他内容，例如“请输入两个整数：”之类的提示语句，这样会导致判错。而在实际生活中，我们可以添加这些提示语句来提高程序的用户体验。
\end{answer}

\subsection{常变量}

常变量（也叫不可变变量、只读变量）是指在程序运行过程中其值不能被修改的变量。在C中，可以使用 \texttt{const} 关键字来声明常变量。例如：
\begin{lstlisting}[language=C]
    const int MAX_VALUE = 100;
    // MAX_VALUE = 200; // 这行代码编译不通过，因此要注释掉
\end{lstlisting}

也就是在常规的声明前面加上 \texttt{const} 关键字。上述代码的意思是：我要创建一个常变量MAX\_VALUE，它的值是100。

我们发现，任何对常变量的修改操作都会使得编译不通过。因此，常变量的值一旦确定就不会在程序运行时改变。常变量的名字通常使用全部大写字母来表示，以便于和变量区分。

\subsection{条件判断}

有时候我们想要设计一个网站，给不同的人显示不同的内容。这个时候，我们就需要用到条件判断。条件判断可以让程序根据不同的条件执行不同的代码块。在C中，常用的条件判断语句有 \texttt{if} 语句和 \texttt{switch} 语句，以及三元运算符。

\subsubsection{条件表达式}

一个条件表达式，最简单的情况肯定是“真”或“假”。C语言规定：true等价于1，false等价于0；但非0的数值还是什么别的非空的东西全部视作true。因此， \texttt{if (1)} 和 \texttt{if (-42)} 甚至 \texttt{if (3.14)} 和 \texttt{if ("hello")}都肯定会执行，而 \texttt{if (0)} 和 \texttt{if ("")} 则肯定不会执行。

但是实际上情况肯定没这么简单，所以需要用比较运算符和逻辑运算符来构造更复杂的条件表达式。常见的比较运算符有：
\begin{itemize}
  \item \texttt{==} ：等于。
  \item \texttt{!=} ：不等于。
  \item \texttt{>} ：大于。
  \item \texttt{<} ：小于。
  \item \texttt{>=} ：大于等于。
  \item \texttt{<=} ：小于等于。
  \item \texttt{\&\&} ：逻辑与（AND）：前后两个条件都为真时，结果才为真。
  \item \texttt{||} ：逻辑或（OR）：前后两个条件有一个为真时，结果就为真。
  \item \texttt{!} ：逻辑非（NOT）：反转后面条件的真假。
  \item \texttt{()} ：括号，用于改变运算优先级。
\end{itemize}

也就是说：\texttt{3+2==5} 是true， \texttt{3+2!=5} 是false， \texttt{3 > 2} 和 \texttt{3 >= 2} 也都是true。而 \texttt{(3 > 2) \&\& (2 > 1)} 是true， \texttt{(3 > 2) || (2 < 1)} 也是true，而 \texttt{!(3 > 2)} 则是false。于是，借助这些比较运算符和逻辑运算符，我们就可以构造出复杂的条件表达式了。

\begin{tip}
  在C++中，不能使用类似 \texttt{1 <= x <= 2} 这样的连续记号来表示区间。正确的写法是 \texttt{(1 <= x) \&\& (x <= 2)} ，即把每个比较都单独写出来，然后用逻辑与运算符连接起来。
\end{tip}

在C++中，与或非运算符是有一定的运算顺序的。一般情况下，逻辑非运算符的优先级最高，其次是逻辑与运算符，最后是逻辑或运算符。不过笔者非常不建议同学们背诵这个顺序；实际在工程上不仅不建议大量嵌套使用这些运算符，而且遇事不决可以加括号——括号可比记运算顺序靠谱得多了！

\subsubsection{if语句}

\texttt{if} 语句的基本语法如下：
\begin{lstlisting}
if (cond1){
    // codes...
}
else if (cond2){
    // codes...
}
else {
    // codes...
}
\end{lstlisting}
上述\texttt{cond1} 和 \texttt{cond2} 是条件表达式，它们的结果是布尔值（真或假）。如果 \texttt{cond1} 为真，则执行第一个代码块；否则，如果 \texttt{cond2} 为真，则执行第二个代码块；否则，执行最后一个代码块。在实际操作中，可以没有任何\texttt{else if} 或 \texttt{else} 分支。

例子：
\begin{lstlisting}[language=C]
if (age < 18) {
    cout << "未成年";
}
else if (age < 60) {
    cout << "成年人";
}
else {
    cout << "老年人";
}
\end{lstlisting}
一目了然，不言而喻。这个age变量可以是前面提到的许多类型。

\subsubsection{switch语句}

\texttt{switch} 语句的基本语法如下：

\begin{lstlisting}
switch (expression) {
    case value1:
        // codes...
        break;
    case value2:
        // codes...
        break;
    ...
    default:
        // codes...
}
\end{lstlisting}
上述 \texttt{expression} 是一个表达式，其结果将与各个 \texttt{case} 后面的值进行比较。如果结果与某个 \texttt{case} 后面的值相等，则执行对应的代码块，直到遇到 \texttt{break} 语句为止。如果没有任何 \texttt{case} 匹配，则执行 \texttt{default} 代码块（如果有的话）。注意， \texttt{break} 语句用于跳出 \texttt{switch} 语句，否则程序会继续执行后续的代码块。在实际操作中，也可以没有 \texttt{default} 分支。

例子：
\begin{lstlisting}[language=C]
switch (day) {
    case 1:
        cout << "星期一";
        break;
    case 2:
        cout << "星期二";
        break;
    case 3:
        cout << "星期三";
        break;
    // ......其他的，基本一个写法
}
\end{lstlisting}
这也一目了然不言而喻了。

\subsubsection{三元表达式}

三元表达式也是一种条件表达式，只不过它可以在一行代码中完成条件判断和结果返回，因此显得更简洁。它通常用于简单的条件判断和赋值操作。它的基本格式如下：
\begin{lstlisting}[language=C]
条件 ? 真值 : 假值
\end{lstlisting}
以上代码的意思是：如果条件为真，整个表达式的值和真值一样；否则，整个表达式的值和假值一样。它非常适合简单的条件判断和赋值操作，但是我们不建议在复杂的条件判断中使用它或者者嵌套使用它，这样会大大降低代码的可读性。

比方说，我们可以用它来判断一个数是奇数还是偶数：
\begin{lstlisting}[language=C++]
int n = 5;
string result = (n % 2 == 0) ? "偶数" : "奇数";
\end{lstlisting}
以上代码的意思是：如果n是偶数，就把字符串“偶数”赋值给result；否则把字符串“奇数”赋值给result。

如果使用if语句来实现同样的功能，可以写成：
\begin{lstlisting}[language=C]
int n = 5;
string result;
if (n % 2 == 0) {
    result = "偶数";
} else {
    result = "奇数";
}
\end{lstlisting}

\begin{exercise}[闰年判断]
    写一个程序，接受一个年份输入，然后判断这一年有多少天（365或366）。提示：闰年的判断规则是：四年一闰，百年不闰，四百年再闰。

    \textbf{程序输入}：一个整数year，表示年份。

    \textbf{程序输出}：一个整数，表示该年份的天数（365或366）。
\end{exercise}

\begin{exercise}[天数判断]
    写一个程序，接受一个月份输入，然后输出该月份有多少天。假设输入的月份是1到12之间的整数，且不考虑闰年。

    \textbf{程序输入}：一个整数month，表示月份。

    \textbf{程序输出}：一个整数，表示该月份的天数。
\end{exercise}

\subsection{循环}

循环是一种重复执行某段代码的结构，直到满足某个条件为止。有的同学可能会问：为什么不直接把代码写多几遍就好了？这是因为有时候我们并不知道需要重复多少次，或者需要根据某个条件来决定是否继续循环，因此这时候就需要用到循环结构。

在C中，常用的循环语句有 \texttt{for} 循环、 \texttt{while} 循环和 \texttt{do-while} 循环。

\subsubsection{for循环}

\texttt{for} 循环的基本语法如下：
\begin{lstlisting}
for (初始化; 条件; 更新) {
    // 循环体代码
}
\end{lstlisting}
上述 \texttt{初始化} 用于设置循环变量的初始值， \texttt{条件} 是一个布尔表达式，用于判断是否继续循环， \texttt{更新} 用于更新循环变量的值。循环体代码会在每次循环中执行。例如，下面的代码演示了如何使用 \texttt{for} 循环打印1到10的数字：
\begin{lstlisting}[language=C]
for (int i = 1; i <= 10; i++) {
    printf("%d\n", i);
}
\end{lstlisting}

\subsubsection{while循环}
\texttt{while} 循环的基本语法如下：
\begin{lstlisting}
while (条件) {
    // 循环体代码
}
\end{lstlisting}
上述 \texttt{条件} 是一个布尔表达式，用于判断是否继续循环。循环体代码会在每次循环中执行，直到条件为假为止。例如，下面的代码演示了如何使用 \texttt{while} 循环打印1到10的数字：
\begin{lstlisting}[language=C]
int i = 1;
while (i <= 10) {
    printf("%d\n", i);
    i++;
}
\end{lstlisting}

实际上，while循环可以和for循环互相转换。上面的for循环可以改写成while循环，反之亦然。

\subsubsection{do-while循环}
\texttt{do-while} 循环的基本语法如下：
\begin{lstlisting}
do {
    // 循环体代码
} while (条件);
\end{lstlisting}
上述 \texttt{条件} 是一个布尔表达式，用于判断是否继续循环。循环体代码会先执行一次，然后再判断条件是否为真，如果为真则继续循环，直到条件为假为止。例如，下面的代码演示了如何使用 \texttt{do-while} 循环打印1到10的数字：
\begin{lstlisting}[language=C]
int i = 1;
do {
    printf("%d\n", i);
    i++;
} while (i <= 10);
\end{lstlisting}
可以看出， \texttt{do-while} 循环至少会执行一次循环体代码，而 \texttt{while} 循环则可能一次都不执行。

\subsubsection{循环控制语句}

有些时候，我们希望在循环中跳过某些迭代，或者提前结束循环。为此，C提供了两种循环控制语句： \texttt{break} 和 \texttt{continue} 。

\texttt{break} 可以立刻跳出整个循环，不再执行后续的迭代。例如：
\begin{lstlisting}[language=C]
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        break; // 当i等于5时，跳出循环
    }
    printf("%d\n", i);
}
\end{lstlisting}
这个代码的输出是1到4，后面的数字都不会被打印出来，因为循环已经被提前结束了。

而 \texttt{continue} 则是跳过当前迭代的剩余所有代码，直接进入下一次迭代。例如：
\begin{lstlisting}[language=C]
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        continue; // 当i是偶数时，跳过当前迭代
    }
    printf("%d\n", i);
}
\end{lstlisting}
这个代码的输出是1到10，除了5这个数字，因为当i等于5时，当前迭代被跳过了。

\begin{exercise}[日期差]
    写一个程序，接受两个日期输入，计算两者之间差了多少天。不考虑闰年问题。

    \textbf{程序输入}：四个整数month1、day1、month2、day2，分别表示第一个日期的月份和天数，以及第二个日期的月份和天数。

    \textbf{程序输出}：一个整数，表示两个日期之间的天数差。

    \textbf{提示}：把上一节的“天数判断”题目作为子任务来完成，也就是说可以试着复用这些代码。
\end{exercise}

\subsection{数组}

数组，顾名思义，也就是“一组数据”。这组数据的类型是相同的，可以是整数、浮点数、字符等。数组中的每个数据都有一个索引（下标），用于标识它在数组中的位置。数组的索引从0开始。

例如，下面的代码声明了一个包含5个整数的数组：

\begin{lstlisting}[language=C]
    int numbers[5] = {10, 20, 30, 40, 50};
    // 访问数组元素
    int firstNumber = numbers[0]; // 访问第一个元素，值为10
    int thirdNumber = numbers[2]; // 访问第三个元素，值为30
    int bad = numbers[5]; // 错误，数组越界访问，可能导致段错误或返回不可知的值
    int bad2 = numbers[-1]; // 错误，数组越界访问

    numbers[1] = 25; // 修改第二个元素的值为25
\end{lstlisting}

有的同学可能会问：我为什么不能用
\begin{lstlisting}
    firstNumber = 25;
\end{lstlisting}
来修改 \texttt{numbers[0]} 的值呢？这是因为 \texttt{firstNumber} 和 \texttt{numbers[0]} 是两个不同的变量，前者是一个独立的变量，而后者是数组中的一个元素。上述初始化语句只是将 \texttt{numbers[0]} 的值复制给了 \texttt{firstNumber} ，它们之间没有任何关联。因此，修改 \texttt{firstNumber} 的值不会影响 \texttt{numbers[0]} 的值，反之亦然。

在C中，我们无法直接打印整个数组，而是需要通过循环来逐个打印数组中的元素。例如：
\begin{lstlisting}[language=C]
for (int i = 0; i < 5; i++) {
    printf("%d\n", numbers[i]);
}
\end{lstlisting}

上述代码使用了一个 \texttt{for} 循环来遍历数组 \texttt{numbers} 中的每个元素，并将其打印出来。\texttt{while} 循环也可以实现同样的功能，读者可以自行尝试。

在C语言中，数组的大小必须是一个能够在编译时确定的常量（如字面值）。

\begin{caution}
  变长数组（VLA）是C99标准引入的特性，允许数组的大小在运行时确定，但它在C11中被变为可选特性。容易引起误会的是，GCC 和 Clang++ 编译器提供了包含 VLA 的GNU 扩展语法，并且默认引入这些扩展，因此，VLA （例如 \texttt{int n; int a[n];} ）在这些编译器下可行。反之，如果关闭这些扩展（通过添加  \texttt{--pedantic-errors}  选项）或者非 GNU 兼容的编译器（如 MSVC），则 VLA 不可用。在实际操作中，我们不要去写VLA，它们可能会导致代码在不同编译器下的表现不一致。C中，我们需要使用数组但是长度不确定的时候，可以将数组开得大一些，例如题目有1000个元素，那么就开1000个元素或者稍多元素的数组。
\end{caution}

\begin{exercise}[计算求和]
写一个程序，该程序接受一些非零整数的输入，直到输入0为止，然后输出这些正整数的和。

\textbf{程序输入}：一系列整数，每个整数占一行，最后一个整数为0，表示输入结束。

\textbf{程序输出}：一个整数，表示输入的非零整数的和。

\textbf{思考}：本题用数组和不用数组分别怎么写？哪种方法更好？如果本题改为“计算平均值”，用数组和不用数组分别怎么写？哪种方法更好？
    
\end{exercise}

\subsection{字符串}

C风格的字符串是以字符数组的形式存储的，并以空字符（ \texttt{\textbackslash 0} ）结尾。字符串可以通过字符数组来表示，例如：
\begin{lstlisting}[language=C]
char str[] = "Hello, World!";
\end{lstlisting}
上述代码声明了一个字符数组 \texttt{str} ，并初始化为字符串 "Hello, World!" 。注意，字符串的长度包括了结尾的空字符。

也就是说：
\begin{lstlisting}
    char str[3] = "Hi"; // 字符串"Hi"占用3个字符：'H'、'i'和'\0'
    char str2[2] = "Hi"; // 错误，数组大小不足以存储字符串及其结尾的空字符
\end{lstlisting}

在做题和实际工程中，很容易遗忘C风格字符串的结尾空字符，因此在操作字符串时要特别小心，确保有足够的空间来存储字符串及其结尾的空字符。

\begin{exercise}[字符串长度]
写一个程序，接受一个字符串输入，然后输出该字符串的长度（不包括结尾的空字符）。

\textbf{程序输入}：一个字符串，长度不超过100个字符。

\textbf{程序输出}：一个整数，表示字符串的长度。

\textbf{提示}：可以使用循环来计算字符串的长度，或者使用标准库函数 \texttt{strlen} 。体会标准库函数在实际编程中的便利性。
\end{exercise}

\subsection{结构体}

结构体（ \texttt{struct} ）是一种用户自定义的数据类型，用于将多个相关的数据组合在一起。结构体可以包含不同类型的成员变量，从而形成一个复杂的数据结构。在C中，结构体的定义和使用方法如下：
\begin{lstlisting}[language=C]
// 定义结构体
struct Person {
    char name[50]; // 姓名
    int age;       // 年龄
    double height;  // 身高
};
// 使用结构体
struct Person person1; // 声明一个结构体变量person1
// 访问和修改结构体成员
strcpy(person1.name, "Alice");
person1.age = 25;
person1.height = 165.5;
\end{lstlisting}

容易看出，结构体可以使得代码更加清晰和有组织，尤其是在处理复杂数据时非常有用。

一个更好的写法是使用 \texttt{typedef} 关键字为结构体定义一个别名，这样在声明结构体变量时就不需要再写 \texttt{struct} 了。例如：
\begin{lstlisting}[language=C]
// 定义结构体并使用typedef为其定义别名
typedef struct {
    char name[50]; // 姓名
    int age;       // 年龄
    double height;  // 身高
} Person;
// 使用结构体
Person person1; // 直接使用别名Person来声明结构体变量person1
\end{lstlisting}

\begin{exercise}[学生信息管理]
写一个程序用于管理学生的高考信息（仅包括学号、姓名、分数）。学号从0开始连续编号，姓名不超过20个字符，分数为整数，在0到750之间。

\textbf{程序输入}：首先输入一个整数n，表示学生人数。接下来输入n行，每行包含一个学生的姓名和分数，姓名和分数之间用空格分隔。然后输入一个整数m，表示查询次数。接下来输入m行，每行包含一个学生的学号。

\textbf{程序输出}：m行。每一行用空格分隔输出三个整数，分别对应查询学号的学生的学号、姓名和分数。如果未能查询到，输出“Not Found”。

\textbf{提示}：本题使用结构体、不使用结构体分别怎么写？哪种方法更好？体会结构体在组织复杂数据时的优势。
\end{exercise}

\subsection{联合体}

联合体（ \texttt{union} ）是一种特殊的数据类型，它允许在同一内存位置存储不同类型的数据。联合体的所有成员共享同一块内存，因此在任何时候只能使用其中的一个成员。联合体的定义和使用方法如下：
\begin{lstlisting}[language=C]
union Data
{
    int intValue;      // 整数值
    float floatValue;  // 浮点值
};
// 使用联合体
union Data data; // 声明一个联合体变量data
// 访问和修改联合体成员
data.floatValue = 10.0; // 设置值

printf("浮点值: %f\n", data.floatValue); // 访问浮点值
printf("整数值: %d\n", data.intValue); // 访问整数值（未定义行为）
\end{lstlisting}

在上述代码中，联合体 \texttt{Data} 包含两个成员： \texttt{intValue} 和 \texttt{floatValue} 。当我们设置 \texttt{floatValue} 的值时， \texttt{intValue} 的值会被覆盖，反之亦然。因此，在使用联合体时需要特别小心，确保只访问当前有效的成员。

\subsection{函数、变量的作用域}

函数是程序中的一个独立模块，用于执行特定的任务。函数可以接受输入参数，执行一些操作，并返回一个结果。使用函数可以提高代码的可读性和可维护性。

函数的定义和使用方法如下：
\begin{lstlisting}[language=C]
// 函数定义
返回类型 函数名(参数类型1 参数名1, 参数类型2 参数名2, ...) {
    // 函数体代码
    return 返回值; // 如果返回类型不是void，则需要返回一个值
}
// 函数调用
返回类型 变量名 = 函数名(参数值1, 参数值2, ...);
\end{lstlisting}

写得太乱了，感觉不如一个实例来得清晰明了：
\begin{lstlisting}[language=C]
int add (int a, int b) { // 函数定义
    return a + b; // 返回两个整数的和
}
int sum = add(3, 5); // 函数调用
printf("和是: %d\n", sum); // 输出结果
\end{lstlisting}

上述代码定义了一个名为 \texttt{add} 的函数，它接受两个整数参数，并返回它们的和。然后，我们调用该函数并将结果存储在变量 \texttt{sum} 中，最后打印出结果。

我们一般把上述a和b叫做“形参”（parameter），而把3和5叫做“实参”（argument）。形参是在函数定义时使用的变量名，用于表示函数接受的输入参数；实参是在函数调用时传递给函数的具体值。

我们不可以在一个函数内部定义另一个函数（即不支持嵌套函数）。main函数也是一个函数，只不过它是程序的入口点，因此也不能在main里面定义另一个函数。

我们发现，在定义上述 \texttt{add} 函数时，使用了两个参数 \texttt{a} 和 \texttt{b} 。这两个参数在函数内部是可以使用的，但是在函数外部是无法访问的。这就是变量的作用域（scope）概念：变量的作用域决定了变量可以被访问的范围。C中，变量要么是局部变量，要么是全局变量。局部变量是在函数内部定义的变量，它们只能在函数内部访问；全局变量是在函数外部定义的变量，它们可以在整个程序中访问。

\begin{lstlisting}[language=C]
int globalVar = 10; // 全局变量
void foo(){
    int localVar = 20; // 局部变量
    printf("局部变量: %d\n", localVar); // 可以访问局部变量
    printf("全局变量: %d\n", globalVar); // 可以访问全局变量
}
int main() {
    foo();
    // printf("局部变量: %d\n", localVar); // 错误，无法访问局部变量
    printf("全局变量: %d\n", globalVar); // 可以访问全局变量
    return 0;
}
\end{lstlisting}
在上述代码中， \texttt{globalVar} 是一个全局变量，可以在函数 \texttt{foo} 和 \texttt{main} 中访问。而 \texttt{localVar} 是一个局部变量，只能在函数 \texttt{foo} 中访问，尝试在 \texttt{main} 中访问它会导致编译错误。

\begin{exercise}[日期差加强版]
写一个程序，接受两个日期输入，计算两者之间差了多少天。

\textbf{程序输入}：空格分隔的6个整数year1、month1、day1、year2、month2、day2，分别表示第一个日期的年份、月份和天数，以及第二个日期的年份、月份和天数。

\textbf{程序输出}：一个整数，表示两个日期之间的天数差。

\textbf{提示}：把前面“天数判断”“闰年判断”题目作为子任务来完成，也就是说可以试着复用这些代码。考虑使用函数来组织代码，提高代码的可读性和可维护性。
    
\end{exercise}

\subsection{函数的递归调用}

函数可以调用自己，这种调用方式叫做递归。递归函数通常用于解决一些具有重复结构的问题，例如计算阶乘、斐波那契数列等。
递归函数的基本格式如下：
\begin{lstlisting}[language=C++]
int foo(){
    if (base_case) {
        return base_value;  // 基础情况，直接返回结果
    } else {
        return foo();  // 递归调用
    }
}
\end{lstlisting}

以上代码：在执行第一个foo的时候，会判断是不是基本情况，如果是则直接结束；如果不是，则会调用foo函数本身。这个过程会一直重复，直到满足基本情况为止。某种程度上，递归也是一种循环的形式。

需要注意的是，递归需要一个基础情况来跳出递归，否则则会产生无限递归错误。例如，我们都知道计算阶乘可以使用$n!=n\times(n-1)!$，但是只有这一个公式是不够的，不停地递归下去没有尽头。这时候，我们需要一个基础情况来结束递归：$0!=1$。因此，我们可以写出递归公式：$factorial(n) = n \times factorial(n-1)$，其中$factorial(0) = 1$。然后，我们就可以用程序语言来描述这个数学语言：
\begin{lstlisting}[language=C++]
int factorial(int n) {
    if (n == 0) {
        return 1;  // 基础情况
    } else {
        return n * factorial(n - 1);  // 递归调用
    }
}
\end{lstlisting}

建立递归思维是非常困难的，但也是非常重要的。在实际生活中，很多问题都可以通过“分治-递归”的思路来解决：把大问题分成相似的小问题，解决这些小问题，然后把小问题的解合并成大问题的解。递归函数正是实现这种思路的有力工具。

\begin{exercise}[小明爬楼梯]
    小明在爬楼梯。他一次可以爬1个或2个台阶。假设楼梯有n个台阶，问小明有多少种不同的爬法？

    \textbf{程序输入}：一个整数n，表示楼梯的台阶数。

    \textbf{程序输出}：一个整数，表示小明爬楼梯的不同方法数。

    \textbf{提示}：考虑：假设小明爬到x级台阶时的爬法有$f(x)$种，那么$f(x)$能不能被它前面的某些项表示出来？基础情况又是什么？这个递推关系就是大名鼎鼎的\textbf{状态转移方程}，是很多复杂问题的核心。
\end{exercise}

递归函数虽然很有效，但是开销非常庞大。每次函数调用都会占用一定的内存空间来存储函数的参数、局部变量和返回地址等信息。如果递归层数过深，可能会导致栈溢出错误。在实际操作中，可以有一些手段来避免递归，例如利用数组来存储中间结果等：
\begin{lstlisting}[language=C++]
int facts[100]; // 假设最大计算到99的阶乘
facts[0] = 1; // 基础情况
for (int i = 1; i < 100; i++) {
    facts[i] = i * facts[i - 1]; // 迭代计算
}
\end{lstlisting}
这样就能避免递归调用带来的巨大开销，但其思路本质和递归相似：递归是从问题本身出发，不停地分解成小问题；而迭代则是从基础情况出发，不停地构建成大问题。而迭代递推则是动态规划这类问题的核心思路。

\subsection{类型强转}

类型强转（type casting）是将一种数据类型转换为另一种数据类型的过程，毕竟大家都不想让5除以2得2。

用括号就可以实现类型强转。例如：
\begin{lstlisting}[language=C]
int a = 5;
int b = 2;
double result = (double)a / (double)b; // 强制将a和b转换为double类型
printf("结果是: %f\n", result); // 输出结果
\end{lstlisting}
在上述代码中，我们将整数变量 \texttt{a} 和 \texttt{b} 强制转换为 \texttt{double} 类型，然后进行除法运算。如果不进行类型强转，整数除法会导致结果被截断为整数部分，得到2；而通过类型强转，我们可以得到正确的浮点数结果2.5。

类型强转在处理不同数据类型之间的运算时非常有用，可以确保运算结果符合预期。

\begin{exercise}[求平均数]
写一个程序，接受一系列整数输入，直到输入0为止，然后输出这些整数的平均值（不包括结尾的0）。

\textbf{程序输入}：一系列整数，每个整数占一行，最后一个整数为0，表示输入结束。

\textbf{程序输出}：一个浮点数，表示输入整数的平均值，保留两位小数。

\textbf{提示}：虽然把输入的整数定义为浮点数是可以避免类型强转的，但在金融上这会产生误差，是不可接受的。因此不得将输入的整数定义为浮点数，而是要定义为整数类型、加和，再通过类型强转来计算平均值。
    
\end{exercise}

\subsection{宏和预处理指令}\label{sec:macro}

宏是一种预处理指令，它可以在编译之前对代码进行替换和扩展。宏的基本格式如下：
\begin{lstlisting}[language=C++]
#define 宏名 替换内容
\end{lstlisting}
宏在编译器对代码进行预处理的时候进行纯文本替换。宏名通常使用大写字母来表示，以便于和变量区分。替换内容可以是任意的代码片段，包括变量、表达式、语句等。宏常用于定义常量，但是用宏定义的常量没有类型，而是字面值。

我们可能会看到，诸如 \texttt{\#define} 、 \texttt{\#include} 等均以符号 \texttt{\#} 开头，这些都是预处理指令，有时候也叫做编译指令。预处理指令和常规代码的行为有区别：它们实际上并非代码的一部分，而是在编译器对代码进行预处理的时候进行处理的。预处理指令通常用于定义宏、包含头文件、条件编译等。常用的预处理指令还有 \texttt{\#pragma} 、 \texttt{\#ifdef} 等。活用编译指令可以让代码更灵活、更高效。

\begin{warning}
  严格禁止使用所谓的“火车头”预处理指令！

  所谓的火车头预处理指令，指的是在代码的开头使用大量的 \texttt{\#pragma} 来指定编译器的行为。这种做法显著地导致了代码的可移植性和可维护性变差。因为不同的编译器对 \texttt{\#pragma} 的支持程度不同，甚至同一编译器的不同版本对某些 \texttt{\#pragma} 的支持也可能不同。而且你辛辛苦苦打一大堆 \texttt{\#pragma} ，实际上优化效果还不如一个简单的 \texttt{-O3} 。这种完全属于歪门邪道的做法，严重违反了代码简洁和可维护的原则。
\end{warning}

\section{指针和内存操作}

指针是C语言的最重要特性，没有之一。该特性彻底奠定了C语言在系统编程领域的统治地位。但对于新手而言，要理解指针难度还是比较大的，因此我们会尽量用通俗易懂的语言来解释指针的概念和使用方法；读者一定要确保理解该内容，而不是背“八股”式的语法，否则后续内容将会变得非常困难。

\subsection{什么是指针}

所有教材（甚至包括C标准）中，对指针的定义实际上都是“一个变量，它存储了另一个变量的内存地址”。但是，这个定义对于初学者来说过于抽象，难以理解。因此，我们可以用一个更形象的比喻来解释指针的概念。

想象内存是一条很长很长的一维走廊，每一个房间1字节，门牌号从0开始依次编号。

现在我们 \texttt{int a = 42;} 。于是，编译器给a分配了4个连续的房间（假设int类型占4字节），并把42这个值存储在这4个房间里。假设起始门牌是0x1000，那么a的4个字节分别存储在0x1000、0x1001、0x1002和0x1003这4个房间里，而变量a就住在0x1000这个房间里，也就是说\textbf{a的地址是0x1000}。

上述内容可以记作：
\begin{lstlisting}[language=C]
    int* p = &a;
    int *p = &a; // 或者这样，但实际没有任何区别
\end{lstlisting}
\begin{note}
    星号写在哪里都无所谓，甚至
    \begin{lstlisting}
        int*p = &a;
    \end{lstlisting}
    也是合法的。

    编译器认为上述写法完全等价。笔者个人习惯第一种写法，因为它清晰地表达了 \texttt{p} 是一个 \texttt{int*} 类型的变量。但大多数人习惯第二种写法，认为这样更符合自然语言的习惯。实际的代码应符合团队的代码风格规范。
\end{note}
可以看到，上述 \texttt{\&a} 就是“取门牌号”，结果类型就是“地址”（ \texttt{int*} ），也就是“指针类型”；而\textbf{指针存的东西就是“地址”，或“门牌号”}。因此，上述代码的意思是“声明一个指针变量p，并把变量a的地址赋值给它”，也就是“让p存储a的门牌号0x1000”。对于其他类型的变量也是类似的，例如 \texttt{char} 类型变量的指针是 \texttt{char*} 类型， \texttt{double} 类型变量的指针是 \texttt{double*} 类型，依此类推。

那么怎么用这个指针呢？我们可以通过指针来访问和修改变量的值。例如：
\begin{lstlisting}[language=C]
    *p = 100; //
    printf("%d\n", p); // 输出指针p的值（地址）
    printf("%d\n", a); // 输出变量a的值
\end{lstlisting}
我们惊奇的发现，虽然我们看似修改的是p，但p并没有改变，但a变了！这是为什么呢？这是因为 \texttt{*p} 表示“通过指针p访问它所指向的变量”，也就是“通过门牌号0x1000访问房间里的东西”。因此 \texttt{*p = 100;} 的意思就是“把p指向的房间里的东西改成100”，也就是把变量a的值改成100。

那么如果这样呢？
\begin{lstlisting}
    p = 100;
    printf("%d\n", p); // 输出指针p的值（地址）
    printf("%d\n", a); // 输出变量a的值
    printf("%d\n", *p); // 试图通过指针p访问它所指向的变量
\end{lstlisting}
这样，p确实是100了，但a并没有变。这是因为这里我们修改的是指针p本身，而不是通过指针p访问的变量。因此，变量a的值保持不变。

但是当我们试图通过指针p访问它所指向的变量时，程序可能会崩溃！这是因为p现在指向的是地址100，而这个地址并没有被分配给任何变量，因此访问这个地址会导致未定义行为！这被叫做“悬空指针”（dangling pointer），俗称“野指针”。因此，在使用指针时，一定要确保指针指向的是一个有效的变量。

因此，在指针中，两个运算符不要弄反：
\begin{itemize}
  \item \texttt{\&} ：取地址运算符，用于获取变量的地址，或“门牌号”。
  \item \texttt{*} ：解引用运算符，用于通过指针访问变量的值，或“门牌号对应房间里的东西”。
\end{itemize}

有一种特殊的指针被称为“空指针”（null pointer），可以理解为“该指针没有指向任何门牌号”，常用作为指针的初始值或者表示指针不指向任何有效变量。在C中，可以使用宏 \texttt{NULL} 来表示空指针。例如：
\begin{lstlisting}[language=C]
    int* p = NULL; // 声明一个空指针

    free(p);    // 释放内存
    p = NULL; // 释放内存后，立刻将指针设置为NULL，避免悬空指针
\end{lstlisting}

\subsection{指针的三条铁律}
在使用指针时，有三条铁律需要牢记于心：
\begin{itemize}
  \item 指针存储的是地址（门牌号），类型必须匹配；\texttt{int*} 类型的指针只能存储 \texttt{int} 类型变量的地址，\texttt{char*} 类型的指针只能存储 \texttt{char} 类型变量的地址，依此类推。至于原因，看到下文就明白了。
  \item 指针必须初始化！直接 \texttt{int* p;} 会得到一个野指针，里面是一个垃圾数值，千万不要使用它，用了大概率段错误。要是真想这么干，声明空指针即可。
  \item 用完的内存要还。这个后面讲到动态内存分配时会讲到为什么。
\end{itemize}

\subsection{指针和数组、函数的配合}

\subsubsection{指针和数组}

在C中，数组名实际上是一个指向数组第一个元素的指针。因此，我们可以使用指针来访问和操作数组元素。而指针的运算也往往无法脱离数组来理解。

例如：
\begin{lstlisting}[language=C]
int numbers[] = {10, 20, 30, 40, 50};
int* p = numbers; // 数组名作为指针，指向第一个元素
for (int i = 0; i < 5; i++) {
    printf("%d\n", *(p + i)); // 通过指针访问数组元素
}
\end{lstlisting}
在上述代码中， \texttt{numbers} 是一个数组名，它在表达式（和函数传参）中，会退化成首元素的地址，因此 \texttt{int* p = numbers;} 实际上等价于 \texttt{int* p = \&numbers[0];} 。

而上述代码中的 \texttt{*(p + i)} 则是通过指针运算来访问数组元素。这里， \texttt{p + i} 表示指针p向后移动i个元素的位置，而 \texttt{*} 则用于解引用该位置，从而获取对应的数组元素的值。实际上上述计算的意思是，“从地址 \texttt{p} 开始，向后移动 \texttt{i} 个 \texttt{int} 类型的字节数，然后访问该地址对应的值”。 \texttt{*(p + i)} 事实上等价于 \texttt{numbers[i]} 。

与之类似的，\texttt{++p} 表示指针p向后移动一个元素的位置，而 \texttt{p+1} 则表示指针p向后移动一个元素的位置，但并不改变指针p本身。

这就解释了为什么指针类型必须匹配的问题：如果指针类型不匹配，那么指针运算时移动的字节数就会出错，从而导致访问错误的内存地址，进而引发未定义行为。

\subsubsection{指针和函数}

指针和函数的配合主要体现在函数参数传递上。

我们可以写一段代码来说明这个问题：
\begin{lstlisting}[language=C]
void swap(int x, int y){
    int temp = x;
    x = y;
    y = temp;
}

swap(a, b);
printf("a = %d, b = %d\n", a, b); // 输出结果
\end{lstlisting}
我们惊奇的发现，虽然写了一个交换函数，但是实际上根本没有交换a和b的值！这是因为在C中，函数参数是通过值传递的，也就是说，当我们调用 \texttt{swap(a, b);} 时，实际上是将a和b的值复制了一份传递给函数 \texttt{swap} 的参数x和y。因此，在函数内部对x和y的修改并不会影响到外部的a和b。

那么怎么才能真正去影响a和b呢？这时就需要用到指针了。我们可以将a和b的地址传递给函数，然后在函数内部通过指针来修改它们的值。例如：
\begin{lstlisting}[language=C]
void swap(int* x, int* y){
    int temp = *x;
    *x = *y;
    *y = temp;
}

swap(&a, &b);
printf("a = %d, b = %d\n", a, b); // 输出结果
\end{lstlisting}
这次运行，就能真正交换a和b的值了。这是因为我们将a和b的地址传递给了函数 \texttt{swap} 的参数x和y，然后在函数内部通过解引用指针来修改它们所指向的变量的值，而非仅仅复制一份值。

\subsubsection{函数指针}

函数指针则是指向函数的指针变量。通过函数指针，我们可以动态地调用不同的函数，从而实现更灵活的代码结构。例如：
\begin{lstlisting}[language=C]
int add(int a, int b) {
    return a + b;
}
int multiply(int a, int b) {
    return a * b;
}

int (*funcPtr)(int, int);
// 将函数指针指向add函数
funcPtr = add;
printf("5 + 3 = %d\n", funcPtr(5, 3)); // 调用add函数
// 将函数指针指向multiply函数
funcPtr = multiply;
printf("5 * 3 = %d\n", funcPtr(5, 3)); // 调用multiply函数
\end{lstlisting}

这样能够让我们在运行时选择要调用的函数，从而实现更灵活的代码结构。

\subsection{动态内存分配}

动态内存分配是指在程序编译时不知道用多少内存，于是在运行时根据需要动态地分配和释放内存空间。

在C中，动态内存分配主要通过以下三个函数来实现：
\begin{itemize}
  \item \texttt{malloc(size\_t size)} ：用于分配指定大小的内存块，返回一个指向该内存块的指针。如果分配失败，返回 \texttt{NULL} 。
  \item \texttt{calloc(size\_t num, size\_t size)} ：用于分配指定数量的内存块，并将其初始化为零。返回一个指向该内存块的指针。如果分配失败，返回 \texttt{NULL} 。
  \item \texttt{free(void* ptr)} ：用于释放之前分配的内存块。参数 \texttt{ptr} 是指向要释放的内存块的指针。
\end{itemize}
例如：
\begin{lstlisting}[language=C]
int n;
scanf("%d", &n); // 读取数组大小
// 动态分配一个包含n个整数的数组
int* arr = (int*)malloc(n * sizeof(int));
if (arr == NULL) {
    perror("内存分配失败");
    exit(EXIT_FAILURE);
}
// 使用数组
for (int i = 0; i < n; i++) {
    arr[i] = i * 2; // 初始化数组元素
}
// 释放内存
free(arr);
arr = NULL; // 好的实践，立即置空，防止悬空指针
\end{lstlisting}
在上述代码中，我们首先读取了数组的大小n，然后使用 \texttt{malloc} 函数动态分配了一个包含n个整数的数组。接着，我们使用该数组进行了一些操作，最后使用 \texttt{free} 函数释放了之前分配的内存。如果不释放这个内存，那么程序常驻时会把内存吃光，导致系统崩溃，这被称为“内存泄漏”；如果不小心释放了两次同一块内存，程序也会崩溃，这被称为“双重释放”。这两个都是非常严重的错误，必须避免。

需要说明的是，malloc返回的是无类型指针（ \texttt{void*} ），C允许直接赋值给任何其他指针类型（例如 \texttt{int*} ），这是C特有的，而C++就不允许这么写。而在C中，我也推荐在赋值前进行强制类型转换。

\subsection{生命周期、静态变量和const指针}

变量的生命周期（lifetime）是指变量在内存中存在的时间段。根据变量的生命周期，变量可以分为以下几种类型：
\begin{itemize}
  \item 自动变量（automatic variables）：也称为局部变量，生命周期从定义开始，到所在的代码块结束为止。自动变量通常存储在栈（stack）中。
  \item 静态变量（static variables）：生命周期从程序开始，到程序结束为止。静态变量通常存储在数据段（data segment）中。静态变量可以在函数内部定义，但使用 \texttt{static} 关键字修饰。
  \item 全局变量（global variables）：生命周期从程序开始，到程序结束为止。全局变量通常存储在数据段（data segment）中。全局变量在函数外部定义。
  \item 动态分配的变量（dynamically allocated variables）：生命周期从调用内存分配函数（如 \texttt{malloc} ）开始，到调用内存释放函数（如 \texttt{free} ）为止。动态分配的变量通常存储在堆（heap）中。
\end{itemize}

\begin{tip}
    栈、堆等概念涉及到操作系统和计算机体系结构的知识。可以通俗的理解为：
    \begin{itemize}
      \item 栈（stack）：用于存储函数的局部变量和函数调用信息，具有先进后出（LIFO）的特点。栈的内存分配和释放由编译器自动管理，速度较快，但空间有限。
      \item 堆（heap）：用于动态分配内存，具有灵活的内存管理特点。堆的内存分配和释放需要程序员手动管理，速度较慢，但空间较大。
      \item 数据段（data segment）：用于存储全局变量和静态变量，生命周期从程序开始到程序结束。数据段的内存分配由编译器在程序加载时完成。
    \end{itemize}
\end{tip}

需要注意的是，静态变量和全局变量在程序运行期间始终存在，因此它们的值在函数调用之间是保持不变的。而自动变量和动态分配的变量则在函数调用结束后被销毁，无法再访问。

因此，如果试图想在函数中保存一些状态信息，可以考虑使用静态变量。例如：
\begin{lstlisting}[language=C]
int* foo(){
    int x = 42; // 自动变量
    return &x; // 错误，返回局部变量地址，x作为局部变量在函数结束后被销毁
}

int* foo_fixed(){
    static int x = 42; // 静态变量
    return &x; // 正确，返回静态变量地址，x在程序运行期间始终存在
}
\end{lstlisting}

至于const指针，则很特殊：
\begin{lstlisting}
int a = 10;
const int* p1 = &a; // 指向常量的指针，不能通过p1修改a的值
int* const p2 = &a; // 常量指针，不能修改p2的值，但可以通过p2修改a的值
const int* const p3 = &a; // 谁都别想动我
\end{lstlisting}
这个估计只能死记硬背了。

\subsection{指针常见错误}

指针是C语言中非常强大但也非常容易出错的特性。以下是一些常见的指针错误（其实我大多都提到过了）：
\begin{itemize}
  \item 没初始化：出现这种情况应该自罚三杯。
  \item 数组越界：一不小心访问了数组之外的内存地址，可能会导致程序崩溃或数据损坏。解决方法是确保访问的索引在数组的有效范围内。
  \item 返回局部变量地址：函数中的局部变量会随着函数的结束而销毁，因此试着返回它们的地址（或在函数外使用它们的地址）会导致悬空指针。解决方法是将变量声明为静态变量。
  \item free以后忘了，接着用：释放内存后继续使用该内存地址会导致未定义行为。解决方法是，free之后，立刻把指针置为NULL，防止悬空指针。
  \item 把int强转成指针乱玩：除非你知道你在做什么，否则不要这么做。
\end{itemize}

\begin{exercise}[指针练习题]
编写一个函数，接受一个整数数组和它的大小作为参数，返回数组中的最大值和最小值。

\textbf{程序输入}：一个整数n，表示数组的大小，接着是n个整数，表示数组的元素。

\textbf{程序输出}：两个整数，分别表示数组中的最大值和最小值。

\textbf{提示}：试着使用指针来遍历数组，并在函数中返回最大值和最小值。另，试着使用动态的内存分配来创建实际上的动态数组，而不是写VLA或预先写一个巨大的静态数组。

\end{exercise}


\section{标准库常用头文件}

C标准库头文件按照C17标准一共29个，其中有一些方法是我们经常会用到的。下面列出一些常用的头文件及其主要功能，基本上覆盖了C代码八成以上的需求。剩余的头文件，读者可以根据需要自行查阅相关资料。

\subsection{stdio.h}

该库主要负责输入输出操作。除了\lstinline[language=C]|scanf|和\lstinline[language=C]|printf|，还包括文件操作等功能。
\begin{itemize}
  \item \texttt{fopen(filename, mode)} ：打开文件，返回一个文件指针。
  \item \texttt{fclose(file\_ptr)} ：关闭文件。
  \item \texttt{fread(buffer, size, count, file\_ptr)} ：从文件中读取数据到缓冲区。
  \item \texttt{fwrite(buffer, size, count, file\_ptr)} ：将缓冲区的数据写入文件。
  \item \texttt{fprintf(file\_ptr, format, ...)} ：格式化输出到文件。
  \item \texttt{fscanf(file\_ptr, format, ...)} ：格式化从文件读取数据。
\end{itemize}

\subsection{stdbool.h}

该库主要负责布尔类型的定义和操作。它定义了一个名为 \texttt{bool} 的数据类型，以及两个宏 \texttt{true} 和 \texttt{false} ，分别表示布尔值的真和假。

\subsection{string.h}

该库主要负责字符串操作，顺带一些内存操作。常用函数包括：
\begin{itemize}
  \item \texttt{strlen(str)} ：返回字符串的长度（不包括结尾的空字符）。
  \item \texttt{strcpy(dest, src)} ：将源字符串 \texttt{src} 复制到目标字符串 \texttt{dest} 中。
  \item \texttt{strcat(dest, src)} ：将源字符串 \texttt{src} 连接到目标字符串 \texttt{dest} 的末尾。
  \item \texttt{strcmp(str1, str2)} ：比较两个字符串 \texttt{str1} 和 \texttt{str2} 的大小关系。
  \item \texttt{strchr(str, ch)} ：在字符串 \texttt{str} 中查找字符 \texttt{ch} 的第一次出现位置。
  \item \texttt{strstr(str1, str2)} ：在字符串 \texttt{str1} 中查找子字符串 \texttt{str2} 的第一次出现位置。
  \item \texttt{memcpy(dest, src, n)} ：将源内存块 \texttt{src} 的前 \texttt{n} 个字节复制到目标内存块 \texttt{dest} 中。
  \item \texttt{memset(dest, val, n)} ：将目标内存块 \texttt{dest} 的前 \texttt{n} 个字节设置为值 \texttt{val} 。该方法用来清理数组非常方便。
\end{itemize}

\subsection{stdlib.h}

该库主要负责内存分配、程序控制和数值转换等功能。常用函数包括：
\begin{itemize}
  \item \texttt{malloc(size\_t size)} ：分配指定大小的内存块。
  \item \texttt{calloc(size\_t num, size\_t size)} ：分配指定数量的内存块，并将其初始化为零。
  \item \texttt{free(void* ptr)} ：释放之前分配的内存块。
  \item \texttt{atoi(str)}、 \texttt{atof(str)} 、\texttt{strtol(str, endptr, base)} 等：将字符串转换为整数或浮点数。
  \item \texttt{qsort(base, nmemb, size, compar)} ：对数组进行快速排序。
  \item \texttt{bsearch(key, base, nmemb, size, compar)} ：在已排序的数组中进行二分查找。
  \item \texttt{realloc(ptr, size)} ：重新分配内存块的大小。
  \item \texttt{exit(status)} ：终止程序的执行，并返回状态码。
\end{itemize}

\subsection{math.h}

该库主要负责一些数学运算函数。常用函数包括：
\begin{itemize}
  \item \texttt{sqrt(x)} 、\texttt{pow(x, y)} 、\texttt{sin(x)} 、\texttt{cos(x)} 、\texttt{tan(x)} 、\texttt{log(x)} 、\texttt{exp(x)} 等：各种数学函数，一目了然。
  \item \texttt{abs(x)} 、\texttt{fabs(x)} ：计算整数或浮点数的绝对值。
  \item \texttt{ceil(x)} 、\texttt{floor(x)} ：向上取整和向下取整函数。
  \item \texttt{round(x)} ：四舍五入函数。
  \item \texttt{fmod(x, y)} ：计算浮点数的余数。
\end{itemize}

\begin{exercise}[改错练习]
    以下代码均有错误或未定义行为或不良实践，请指出并改正。

\begin{lstlisting}[language=C]
#include <stdio.h>
int main(){
    int n;
    int arr[n];
    scanf("%d", &n);
    for (int i = 0; i <= n; i++) {
        scanf("%d", &arr[i]);
    }
    return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C]
#include <stdio.h>
int main(){
  int arr[5];
  for(int i = 0; i <= 5; i++){
    scanf("%d", &arr[i]);
  }
  return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C]
#include <stdio.h>
int main(){
  int *p;
  *p = 10;
  printf("%d\n", *p);
  return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C]
#include <stdio.h>
int main(){
  char str[5];
  scanf("%s", str); // input: Hello
  printf("%s\n", str);
  return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C]
#include <stdio.h>
int main(){
  int x = 5;
  if (x = 0){ 
    printf("x is zero\n");
  }
  return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C]
#include <stdio.h>
int* getNumber(){
  int a = 42;
  return &a; 
}
int main(){
  int *p = getNumber();
  printf("%d\n", *p); 
  return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C]
#include <stdio.h>
void printSize(int arr[]){
  printf("%zu\n", sizeof(arr));
}
int main(){
  int arr[10];
  printSize(arr);
  return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C]
#include <stdio.h>
int main(){
  int a = 1;
  int b = a++ + a++; 
  printf("%d %d\n", a, b);
  return 0;
}
\end{lstlisting}

\end{exercise}

\begin{answer}
以上八个题目（以左栏第一个为第一题）分别错在：
\begin{enumerate}
    \item n未初始化就使用。应先读入n，再定义数组。另，VLA不是C标准的一部分，建议使用动态内存分配\lstinline[language=C]|malloc|。
    \item 数组越界。应改为\lstinline[language=C]|i < 5|。
    \item 指针未初始化就使用。
    \item 数组长度不足以存储输入的字符串，是忘记\verb|\0|导致的。应改为\lstinline[language=C]|char str[6];|。
    \item 误用赋值运算符。应改为\lstinline[language=C]|if (x == 0)|。
    \item 返回局部变量地址，导致悬空指针。应改为静态变量或动态分配内存。
    \item 数组作为函数参数时退化为指针，sizeof结果是指针大小。应传入数组大小作为额外参数。
    \item 未定义行为，因为\lstinline[language=C]|a++|的副作用未定义顺序。应改为两行分别处理。
\end{enumerate}
改正代码略，读者可自行完成。
\end{answer}