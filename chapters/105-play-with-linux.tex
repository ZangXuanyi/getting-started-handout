\chapter{开玩Linux}\label{chap:play-with-linux}

很多人是因为迫不得已而使用 Linux \faLinux（最常见的是上ICS）。更深入的想一想，还有没有其他使用Linux的原因呢？

对于 Windows 等带图形化界面操作系统，我们所访问的其实是设计者抽象出的交互逻辑。但对于高效的系统，自底向上的彻底理解和掌握是高效使用系统的必备途径。我们得以更深入洞悉文件和文件之间的联系，获得系统更高的主动权。同时，以最小化的人机接口访问能把足够多的资源投入至计算，获得最高的资源利用率。Linux 正是带着这样的思想而诞生的。

因此，学习 Linux，我们需要掌握：

\begin{enumerate}
  \item 对这一套思想有充分理解、能顺利玩一些玩具
  \item 使用现有的工具操作命令行、把他人准备好的软件运行起来
  \item 创造新的工具
\end{enumerate}

让我们开始吧！

\section{获取Linux}

在20世纪80年代，主要的几个计算机系统有UNIX、DOS和Mac OS。当时，UNIX系统昂贵且无法用于个人计算机，DOS太简陋了且闭源，Mac OS则只用于苹果电脑，计算机科学教育严重受限。为了解决这个问题，Andrew S. Tanenbaum教授设计了MINIX系统，并将其用于教学。然而该系统功能有限且不实用。

当时在芬兰赫尔辛基大学读大二的Linus Torvalds在用过MINIX之后，受到了启发。在1991年，他利用UNIX的核心，吸收了MINIX的精华，剔除了不必要的部分，编写了一个新的操作系统内核，并将其命名为Linux 0.01，该内核能够运行在x86架构的个人计算机上。这就是后来各种Linux的雏形。1994年，Linux 1.0版本发布，标志着Linux的正式诞生。

Linux内核采用了GPL协议，这使得任何人都可以自由地使用、修改和分发它。这种开放的理念吸引了大量的开发者和用户，形成了一个庞大的社区。如今，Linux已经与Windows、macOS成三足鼎立之势，成为全球最流行的操作系统之一，更成为了开源技术的象征。

然而，不管怎么讲故事，Linux最终还是一个操作系统，我们还是先要获取一个基于Linux的系统当玩具：不摸一摸，知道用起来舒不舒服，又了解它干啥呢？

\subsection{Linux发行版}

虽然我们经常说“Linux系统”，但是实际上Linux并不是一个操作系统，它仅仅是一个内核（Kernel）。一个完整的操作系统还需要很多其他的组件，例如文件系统、图形界面、应用程序等。为了方便用户使用，很多组织和公司将Linux内核和其他组件打包在一起，形成了一个完整的操作系统，这就是我们常说的Linux发行版（Distribution）。Linux发行版种类繁多，每个发行版都有其独特的特点和适用场景。常见的Linux发行版有：
\begin{small}
  \begin{longtable}[c]{l|lll}
    \caption{常见Linux发行版}\label{tab:linux-distros}\\
    \toprule
    发行版 & 特点 & 更新频率 & 适用情况 \\
    \midrule
    \endfirsthead          % 首页表头

    \multicolumn{4}{c}{\footnotesize 续表~\ref{tab:linux-distros}}\\[.5ex]
    \toprule
    发行版 & 特点 & 更新频率 & 适用情况 \\
    \midrule
    \endhead               % 后续页表头

    \midrule
    \multicolumn{3}{r}{\footnotesize 接下页}
    \endfoot               % 每页底部（除末页）

    \bottomrule
    \endlastfoot

    Ubuntu\faUbuntu & 用户友好，社区活跃 & 两年 & Linux新手，桌面用户 \\
    Debian & 稳定，软件包丰富 & 两年 & 服务器等生产环境 \\
    Fedora\faFedora & 最新技术，社区驱动 & 半年 & 开发者，技术爱好者 \\
    RHEL \faRedhat& 商业支持，稳定 & 三年 & 企业用户，服务器 \\
    CentOS\faCentos & RHEL的免费版本 & 死了 & 企业用户，服务器 \\
    Arch & 滚动更新，极简 & 以天计 & 高级用户，DIY爱好者 \\
    NixOS & 声明式配置，原子升级 & 以天计 & 高级用户，系统管理员 \\
    Rocky & Cent的复活版本 & 三年 & 企业用户，服务器 \\
    Alma & Cent的复活版本 & 三年 & 企业用户，服务器 \\
    Mint & 基于Ubuntu，用户友好 & 两年 & Linux新手，桌面用户 \\
    Manjaro & 基于Arch，用户友好 & 以月计 & Linux新手，桌面用户 \\
    openSUSE & 稳定，企业支持 & 八个月 & 企业用户，服务器 \\
    Gentoo & 源码编译，极致定制 & 以月计 & 高级用户，DIY爱好者 \\
    Kali & 安全测试，渗透测试 & 半年 & 网络安全专业人员 \\
    Alpine & 轻量级，安全 & 以月计 & 容器，嵌入式系统 \\
    统信UOS & 中国本土，兼容Windows & 两年 & 政府，企业用户 \\
  \end{longtable}
\end{small}

上述发行版是相对常见的Linux发行版。其中，最出圈的发行版莫过于Ubuntu了，有不少人甚至直接将Ubuntu和Linux划等号（这实际上是不对的）。Ubuntu拥有着庞大的用户群体和丰富的软件资源，非常适合初学者入门。

对于什么都不会的小白而言，我们推荐使用Ubuntu、Mint、Manjaro等用户友好的发行版；如果你愿意折腾，可以尝试Arch、Gentoo等极简主义的发行版；如果你要玩服务器，可以选择Debian、RHEL、CentOS（或其复活版本Rocky、Alma）等稳定的发行版；如果你对网络安全感兴趣，可以尝试Kali等专用发行版。

\subsection{CLab}

这是最简单的使用Linux的方式，甚至不需要在计算机上安装任何东西。我们只需要去 \href{https://clab.pku.edu.cn/}{CLab} 注册一个账号，根据上面的指南连接到虚拟机。这样，你就可以在不破坏自己的系统的情况下，体验 Linux 的魅力了。当然，这个虚拟机的性能和功能有限，因此一般用户无法在上面运行诸如MineCraft服务端等大型软件。

\subsection{实机安装}

如果我们有一台不怎么重要的机器和一个U盘，可以利用U盘在这台机器上面安装Linux。你可以选择任意的发行版进行安装。

\subsubsection{Ubuntu}

Ubuntu安装过程非常简单，其自动化程度非常高。以下是一个简要步骤：

\begin{enumerate}
  \item 获取Linux发行版的ISO镜像文件。可以从（\href{https://ubuntu.com/download}{Ubuntu官网}）下载最新版本的Ubuntu ISO镜像。
  \item 准备一个U盘，至少8GB容量。将这个镜像文件写入U盘。可以使用工具如Ultra ISO、Rufus、Ventoy 或Etcher（跨平台）来完成这个操作。
  \item 将U盘插入目标机器，重启电脑并进入BIOS设置，将U盘设置为首选启动设备。
  \item 保存设置并重启，系统将从U盘启动，进入Ubuntu安装界面，并按照提示进行安装。我们建议选择“安装Ubuntu”选项，并在安装过程中选择“擦除磁盘并安装Ubuntu”选项（注意，这将删除磁盘上的所有数据，请确保备份重要数据）。
  \item 安装完成后，重启电脑，拔出U盘，系统将进入Ubuntu桌面环境。
\end{enumerate}

对于硬盘容量较大且熟悉分区的同学，可以使用磁盘分区工具自己划出一个分区，并将Ubuntu安装在这个分区上。这样可以保留原有的操作系统，并在需要时切换到Ubuntu。在这种情况下我们一般使用grub引导程序来管理多系统启动。

\subsubsection{其他发行版}

如果你对Linux有一定了解，或者想尝试其他发行版，可以选择其他发行版进行安装。对于此类学生，我们非常推荐使用Arch Linux，因为它提供了一个非常灵活和可定制的环境，适合有一定Linux基础的用户。

同时，安装Arch Linux也是一个很好的学习Linux的机会，因为它的安装过程需要用户从头手动配置系统，这样可以更深入地了解Linux的工作原理。

\subsection{使用虚拟机}

使用虚拟机也是一个很好的选择。通过虚拟机，我们可以在现有的操作系统上运行Linux或者其它系统，而不需要重新安装或配置硬件。

一般我们使用的虚拟机软件有VirtualBox、VMware等。不同的虚拟机有着不同的特点和使用方法，但是总体而言在虚拟机中安装一个Linux发行版的步骤与在实机上安装类似（只是不需要设置BIOS和U盘启动等了）。

\subsection{WSL}

WSL是在Windows上使用Linux的最佳方式之一。它允许用户在Windows上运行Linux发行版，并提供了与Linux相似的命令行环境。WSL的安装和配置非常简单，只需要在命令行中运行以下命令即可：
\begin{lstlisting}[language=bash]
    wsl --install
\end{lstlisting}
WSL提供了与Linux相似的命令行环境，并且可以直接访问Windows文件系统。例如：

\begin{lstlisting}[language=bash]
    cd /mnt/c/Users/YourUsername/Documents
\end{lstlisting}
上述命令会在Linux环境中查看Windows的文档目录。这种跨系统的文件访问方式非常方便，可以让用户在Windows和Linux之间无缝切换。这样，我们就可以在Windows上使用Linux的命令行工具和开发环境了。

对WSL这里仅是一个简单的介绍，更多内容请参考微软的\href{https://learn.microsoft.com/en-us/windows/wsl/about}{WSL官方文档}。当然，你也可以直接把本章拉到最后！

\section{Linux的基本操作}

得了，来了啥也别说，先跑个小火车：

\begin{lstlisting}[language=bash]
sudo apt update
sudo apt install -y sl
sl
\end{lstlisting}

执行以上命令，我们就可以看到一个小火车在终端上跑了过去。

\texttt{sl}是一个玩具软件，它的全称是Steam Locomotive，是一个在终端上显示火车动画的程序。这不仅能够展示ASCII艺术的魅力，还能矫正打错的\texttt{ls}命令（列出目录内容）。

\texttt{apt}是Debian及其衍生发行版（如Ubuntu）中用于管理软件包的工具。它可以用来安装、更新和删除软件包。

于是我们就能看到，一个程序就这么跑起来了。

让我们看看上面内容是怎么发生的。我们刚刚输入的命令大概是这样的形式：
\begin{lstlisting}[language=bash]
程序 子命令 [选项] [对象]
\end{lstlisting}

其中，除了子命令，选项和对象都是可选的。我们就用第二个命令来举例说说：apt是程序，install是子命令，-y是选项，sl是对象。

看起来很明确。

那么，我们怎么知道有什么程序，我们又怎么使用它们呢？对于第一个问题，我们可以通过搜索来解决；对于第二个问题，我们可以通过手册来解决。

\begin{itemize}
  \item \texttt{<program> -h}：这是最简单的方式，直接查看程序的帮助信息。通常会列出所有可用的子命令和选项。
  \item \texttt{man <program>}：这是查看程序手册的方式。手册通常会提供更详细的信息，包括子命令的用法、选项的含义等。但是这个手册可能会比较长，需要耐心阅读。
  \item \texttt{tldr <program>}：这个命令会给出一些常用的命令示例和简要说明。当然，\texttt{tldr}需要自己安装，当然，安装方法和\texttt{sl}类似。
\end{itemize}

\section{Linux的文件系统}

好的，我们刚刚已经知道怎么使用Linux了。接下来，我们来看看Linux的文件系统。我们不会涉及到任何复杂的概念，只会介绍一些最基本的内容。

思考以下问题：我们刚刚确实输入了\texttt{sl}命令，但是我们并没有输入\texttt{sl}的路径。那这个\texttt{sl}到底在哪里呢？我们怎么知道它在哪里？（其实我们知不知道真无所谓）终端又怎么知道它在哪里？小火车又是怎么跑起来的？

为了解决这一问题，计算机前辈们发挥了聪明才智：只要把所有的东西都归纳为一个概念，那么不就可以方便的管理了吗？于是，文件系统就诞生了。

UNIX和Linux认为，所有的东西都是\textbf{文件}。文件系统就是用来管理这些文件的。这时候，我们就可以使用同样的方式来对所有的东西进行操作了。但是我们又出现了其他问题：

\begin{enumerate}
  \item 文件怎么组织？
  \item 文件是谁的？怎么反映不同类型的特性？
  \item 文件怎么相互联系？
\end{enumerate}

接下来我们将会逐个回答以上问题。

\subsection{文件的组织}

我们在上一章中提到，Windows系统下，物理先于文件存在，所以有盘符一说。但是Linux不这么认为：Linux认为什么都是文件。于是，Linux的根目录\text{/}就成了所有文件的起点。所有的文件都在这个根目录下。

于是，我们就能够通过目录来解决这一问题。目录是一个特殊的文件，它可以包含其他文件和子目录。我们可以使用\texttt{ls}命令来查看当前目录下的文件和子目录，也可以使用\texttt{cd}命令来切换目录。

Linux的目录结构和Windows极其相似，只是没有盘符，并且使用\texttt{/}作为分隔符，而不是\texttt{\textbackslash}。我们可以使用\texttt{/}来表示根目录，使用\texttt{..}来表示上一级目录，使用\texttt{./}来表示当前目录。需要注意的是，Linux的文件系统是区分大小写的，所以\texttt{/home}和\texttt{/Home}是两个不同的目录。

Linux还有一个重要的目录：用户的家目录，通常位于\texttt{/home/username}。在这个目录下，用户可以存放一些配置文件。我们可以使用\texttt{\textasciitilde}来表示当前用户的家目录。我们不推荐把自己的杂七杂八文件放在根目录或者家目录下，而是放在家目录的子目录下。这样可以更好地组织文件，并且避免与系统文件冲突。

我们在上一章提到，处于安全性考虑，对于可执行文件，如果没有提供路径，系统会在一些特定的目录下查找。因此假如有一个可执行文件\texttt{hello}，我们应当使用\texttt{./hello}来运行它，而不是直接使用\texttt{hello}。

如果我们想要在任何地方都能运行这个程序，我们可以把它加入PATH环境变量中去。PATH是一个环境变量，它包含了一些目录的路径，系统会在未提供路径时去这些目录下查找可执行文件。我们可以使用\texttt{echo \$PATH}命令来查看当前的PATH变量。

\subsection{文件是谁的，有什么属性}

作为多机系统，Linux 中文件如果对每个访问者都相同，那就没有安全性可言了。Linux 的做法是，抽象出了“用户”这个实体（其实就是在 \texttt{/etc/passwd} 里面定义的一行 UID 和用户名的对应而已）。为了方便用户的文件共享，同时抽象出了组（Group）的概念，代表一组互相信任的用户。

对文件的基本操作有读、写、执行三种，一般用字母表示为r、w、x。我们使用权限位来表示这三种操作。每个文件都有三个权限位，分别对应所有者、组和其他用户。我们可以使用\texttt{ls -l}命令来查看文件的权限。

举例：一个用户创建了一个文件，这个文件对他的权限是rwx，对同组用户的权限是r-x，对其他用户的权限是r--。那么这个文件的权限就是\texttt{rwxr-xr--}。而这个代表方式还是太笨重了，于是Linux又引入了数字表示法。

数字表示法是一个“独热编码”（One-hot Encoding），也就是rwx被看作三个相互独立的二进制位，对应位上1表示有该权限，0表示没有该权限。然后把这三个位的值拼成一个三位的二进制数，就代表了其最终权限。例如：某用户对文件有读、写权限，没有执行权限，即rw-，对应的二进制数是110，转换成十进制就是6。而二进制中的100是4，010是2，001是1，于是就可以把一个用户对文件的权限表示为一个0到7的数字，例如7=4+2+1表示rwx，5=4+0+1表示r-x，等等。

因此我们的文件权限可以用一个三位八进制来表示，从左到右的每一位分别对应所有者、组和其他用户的权限。例如，权限为\texttt{rwxr-xr--}的文件可以表示为\texttt{754}。另一个常见的权限编码是\texttt{644}，你能说明其含义吗？\footnote{其含义是：所有者有着读写权限，组和其他用户只有读权限。}

但有一个用户比较特殊，那就是root用户。root用户是系统管理员，拥有对所有文件的最高权限。无论文件的权限如何设置，root用户都可以对其进行读、写、执行操作；换句话说，root用户对所有文件的权限都是\texttt{rwx}或者7。

我们可以使用\texttt{chmod}命令来修改文件的权限。例如，\texttt{chmod 777 file.txt}将会把指定文件的权限设置为777。

\begin{tip}
  修改文件权限需要有相应的权限，否则会报错。例如你无法给一个对你来说权限是0的文件加上可执行权限。
\end{tip}

\begin{warning}
  不要执行这类抽象的命令：\texttt{chmod 777 /}，这会导致系统所有成员全部被视同root用户，进而导致系统无法正常工作。
  
  这样就会导致所有用户都可以写根目录，随便替换\texttt{/bin/sh}、\texttt{/etc/passwd}、\texttt{usr/bin/sudo}等关键文件，乃至随意植入cron、systemd等定时任务，\textbf{等同于整个安全阵地完全失守，自毁长城}。
\end{warning}

所以可执行文件并不是因为这个文件本身有什么特别，而是这个文件被你赋予了可执行的性质。一个简单的文本文件也可以被加上可执行的权限，也可以发挥操作其他文件的作用。

例如，如果你会写 Python 的话，写一个从输入读取 2 个数字，输出他们和的程序，输出结果到控制台。在本地跑起来这个程序之后，把 \texttt{\#!/usr/bin/env python3} 放在脚本的第一行（这个特殊的一行叫 Shebang）。给这个脚本加上可执行的属性，然后直接运行这个文本！

\subsection{文件的联系}

文件间的联系，主要是通过文件系统的链接来实现的。Linux 中有两种链接：硬链接和软链接。硬链接是指在文件系统中，一个文件可以有多个文件名，存在于多个位置，但是文件系统中只有一份文件副本，所有链接均指向这一副本。删除其中一个文件名并不会影响文件内容，只有所有位置下的文件链接均被删除时，此文件副本才会被最终移除。软链接是指一个文件名指向另一个文件名，删除原文件名会影响软链接的有效性。

硬链接和软链接的区别在于，硬链接是文件系统的一个特性，而软链接是文件系统的一个单独的文件。硬链接只能在同一个文件系统下，而软链接可以在不同文件系统下。硬链接不能链接目录，而软链接可以链接目录。

\begin{tip}
  试一试：
  \begin{lstlisting}[language=bash]
    echo "hello" > a # 随便创建一个文件
    ln a b           # 创建硬链接 b 指向 a
    ln -s a c       # 创建软链接 c 指向 a
  \end{lstlisting}
  现在这里有了b和c两个新的文件。试着利用\texttt{ls -l}命令查看它们的属性，看看有什么区别。然后尝试删除a文件，看看b和c会发生什么变化。
\end{tip}

\section{Linux的进一步使用}

\subsection{root权限的配置}

root 用户是超级用户，拥有着 Linux 系统内最高的权限，在终端内使用su命令即可以超级用户开启终端，root 用户的权限最高，而其他账户则可能会有以能以超级用户身份执行命令的授权（可以类比 Windows 中的管理员权限），但即使是拥有授权的账户在终端输入的命令也不会以超级用户身份执行，如果需要以超级用户的身份运行则需要在此命令前加 sudo。

第一种情况，如果你所选择的发行版在安装过程中没有设置 root 密码的环节（如 Ubuntu），则新创建的用户会拥有管理员权限，一般不需要使用 root 账户，直接使用 sudo 命令即可。

第二种情况，如果你所选择的发行版在安装过程中已经设置了 root 密码，但是自己的账户并没有管理员权限（如 Debian），为了用起来方便一般会用 root 账户给自己的账户添加管理员权限，具体操作如下（\$号后的为输入的命令）：

\begin{lstlisting}[language=bash]
    yourusername@yourcomputer$ su
    root@yourcomputer$ /usr/sbin/usermod -aG sudo yourusername
\end{lstlisting}

前者表示切换至 root 账户，后者表示为你指定的账户添加管理员权限。有些发行版中 wheel 组表示有 sudo 权限的用户组（例如Arch），也可以用 visudo 编辑 sudo 配置。

\subsection{软件的安装及其源的配置}

如果你的系统在安装的时候已经选择过了国内源则忽略，否则默认源来自于国外。从国外的服务器更新软件包会很慢，可以根据自己系统的版本自行搜索匹配的源并更换。具体参考\href{https://mirrors.pku.edu.cn/Help}{北大开源镜像站的帮助文档}。

以采用 apt 包管理器为例，更新源后需要重新更新软件索引，请执行以下操作：

\begin{lstlisting}[language=bash]
sudo apt-get update
sudo apt-get upgrade # 如果需要升级软件包
\end{lstlisting}

如果你需要安装软件包，可以使用以下命令：
\begin{lstlisting}[language=bash]
sudo apt-get install <package-name>
\end{lstlisting}

如果想要卸载软件包，可以使用以下命令：
\begin{lstlisting}[language=bash]
sudo apt-get remove <package-name>
\end{lstlisting}

有时候，我们不得不使用一些其他安装方式，例如从\texttt{*.deb}包安装。对于这些情况，我们可以使用以下命令：

\begin{lstlisting}[language=bash]
sudo dpkg -i <package-name>.deb # 安装 .deb 包
sudo apt-get install -f # 修复依赖问题
\end{lstlisting}

有时，软件自带安装脚本，我们直接运行这些脚本即可。

特别注意：我们请尽可能地使用包管理器来安装软件，而不是直接下载二进制文件或源码编译安装。包管理器可以自动处理依赖关系，并且可以方便地进行软件的更新和卸载。如果一定要手动安装软件，请确保你了解该软件的安装过程和依赖关系，并尽可能在虚拟环境或容器中进行测试，以避免对系统造成不必要的影响。

\subsection{关于VIM和Nano}

虽然我们有很多文本编辑器可以在图形化的Linux上使用，但是在终端中，这两个编辑器依然是最常用的，而且也是不得不用的（尤其是VIM！）。因此，我将会在这里简要介绍一下这两个编辑器。

\subsubsection{VIM}

VIM是一个强大的文本编辑器，它有着丰富的功能和插件，可以满足各种需求。
VIM有两种状态：命令状态和编辑状态。默认情况下，VIM处于命令状态。在命令状态下，我们可以使用各种命令来操作文件；在编辑状态下，我们可以直接输入文本。在这两种方式之间的切换非常简单，只需要按下\texttt{i}键即可进入编辑状态，按下\texttt{Esc}键即可返回命令状态。

编辑状态下的VIM乏善可陈，完全可以把这玩意当成一个没有鼠标的Windows记事本来使用，这里根本没有什么好说的。我们的重点在于命令状态下的VIM。
在命令状态下，我们可以使用各种命令来操作文件。以下是一些常用的命令：

\begin{multicols}{2}
  \begin{itemize}
    \item \texttt{h}：向左移动光标。
    \item \texttt{j}：向下移动光标。
    \item \texttt{k}：向上移动光标。
    \item \texttt{l}：向右移动光标。
    \item \texttt{w}：移动到下一个单词的开头。
    \item \texttt{b}：移动到上一个单词的开头。
    \item \texttt{0}：移动到行首。
    \item \texttt{\$}：移动到行尾。
    \item \texttt{gg}：移动到文件开头。
    \item \texttt{G}：移动到文件结尾。
    \item \texttt{dd}：删除当前行。
    \item \texttt{yy}：复制当前行。
    \item \texttt{p}：粘贴。
    \item \texttt{u}：撤销。
    \item \texttt{Ctrl+r}：重做。
    \item \texttt{:w}：保存文件。
    \item \texttt{:q}：退出VIM。
    \item \texttt{:wq}：保存并退出VIM。
    \item \texttt{:q!}：强制退出VIM，不保存文件。
  \end{itemize}
\end{multicols}

想给Vim装插件其实也是一种挺折腾的工作。目前最通行的方式是利用插件管理器，比如Vundle、Pathogen、vim-plug等。安装插件管理器后，我们可以通过编辑\texttt{~/.vimrc}文件来添加插件，具体也可以参考各插件管理器的文档。而使用NeoVim等衍生版本则会更方便一些。

\subsubsection{Nano}

Nano是一个简单易用的文本编辑器，它有着直观的界面和快捷键，可以快速上手。其使用也比VIM简单得多，因为它没有两种状态的区别，直接打开文件后就可以编辑文本了，而且所有命令快捷键全都在界面下方列出了，直接照着按就行了！

\begin{multicols}{2}
  \begin{itemize}
    \item \texttt{Ctrl+O}：保存文件。
    \item \texttt{Ctrl+X}：退出Nano。
    \item \texttt{Ctrl+K}：剪切当前行。
    \item \texttt{Ctrl+U}：粘贴。
    \item \texttt{Ctrl+W}：查找文本。
    \item \texttt{Ctrl+\textbackslash}：替换文本。
    \item \texttt{Ctrl+C}：显示光标位置。
    \item \texttt{Ctrl+G}：显示帮助信息。
  \end{itemize}
\end{multicols}

\subsection{再临终端命令行}

在表\ref{tab:terminal-commands}中，我们初步认识了一些常用的命令。接下来我们会对它们进行一定的扩展。

\begin{itemize}
  \item \textbf{系统命令}
    \begin{itemize}
      \item \texttt{sudo}命令用于提权。
      \item \texttt{poweroff}和\texttt{shutdown}两个命令用于关机。
      \item \texttt{reboot}命令用于重启电脑。
      \item \texttt{whoami}命令用于查看自己是哪个用户。
      \item \texttt{which}命令用于查找可执行文件的路径。
      \item \texttt{ps}命令用于显示当前运行的进程。
        \begin{itemize}
          \item \texttt{-e}：显示所有进程。
          \item \texttt{-f}：以全格式显示进程信息，包括父进程ID、用户等。
          \item \texttt{-l}：以长格式显示进程信息。
          \item \texttt{-u}：显示指定用户的进程。
          \item \texttt{-p}：显示指定进程ID的进程。
          \item \texttt{-o}：自定义输出格式。
          \item \texttt{-H}：以树形结构显示进程之间的关系。
          \item \texttt{-j}：以作业控制格式显示进程信息。
          \item \texttt{-x}：显示所有进程，包括没有控制终端的进程。
        \end{itemize}
      \item \texttt{kill}命令用于终止进程。
      \item \texttt{fg}命令可以将后台运行的任务调回前台，这个命令可以恢复被\texttt{Ctrl+Z}挂起的任务。
      \item \texttt{bg}命令可以将任务放到后台运行。
    \end{itemize}
  \item \textbf{列出和查找类}
    \begin{itemize}
      \item \texttt{pwd}命令用于显示当前工作目录的绝对路径。
      \item \texttt{ls}命令用于列出目录中的文件和子目录。
        \begin{itemize}
          \item \texttt{-l}：以长格式列出文件和目录的详细信息。
          \item \texttt{-a}：列出所有文件和目录，包括隐藏文件。
          \item \texttt{-h}：以人类可读的格式显示文件大小。
          \item \texttt{-R}：递归地列出子目录中的文件和目录。
          \item \texttt{-t}：按修改时间排序。
        \end{itemize}
      \item \texttt{tree}命令用于以树形结构显示目录中的文件和子目录。
      \item \texttt{find}命令用于在目录中查找文件和目录。
    \end{itemize}
  \item \textbf{文件系统操作类}
    \begin{itemize}
      \item \texttt{cd}命令用于切换当前工作目录。
      \item \texttt{mkdir}命令用于创建新目录。
        \begin{itemize}
          \item \texttt{-p}：递归地创建多级目录，如果上级目录不存在则一并创建。
          \item \texttt{-v}：显示创建目录的详细信息。
          \item \texttt{-m}：设置新目录的权限。
        \end{itemize}
      \item \texttt{touch}命令用于创建新文件或更新现有文件的修改时间。
        \begin{itemize}
          \item \texttt{-a}：只更新访问时间。
          \item \texttt{-m}：只更新修改时间。
          \item \texttt{-c}：如果文件不存在则不创建。
          \item \texttt{-t}：设置文件的时间戳。
          \item \texttt{-r}：使用指定文件的时间戳。
        \end{itemize}
      \item \texttt{rm}命令用于删除文件或目录。
        \begin{itemize}
          \item \texttt{-r}：递归地删除目录及其内容。
          \item \texttt{-f}：强制删除文件或目录，不提示确认。
          \item \texttt{-i}：在删除前提示确认。
          \item \texttt{-v}：显示删除的详细信息。
        \end{itemize}
      \item \texttt{rmdir}命令用于删除空目录。
      \item \texttt{cp}命令用于复制文件或目录。
        \begin{itemize}
          \item \texttt{-r}：递归地复制目录及其内容。
          \item \texttt{-f}：强制覆盖目标文件。
          \item \texttt{-i}：在覆盖前提示确认。
          \item \texttt{-v}：显示复制的详细信息。
          \item \texttt{-u}：只在源文件比目标文件新时才进行复制。
        \end{itemize}
      \item \texttt{mv}命令用于移动或重命名文件或目录。
        \begin{itemize}
          \item \texttt{-f}：强制覆盖目标文件。
          \item \texttt{-i}：在覆盖前提示确认。
          \item \texttt{-v}：显示移动的详细信息。
          \item \texttt{-u}：只在源文件比目标文件新时才进行移动。
        \end{itemize}
      \item \texttt{ln}命令用于创建链接。
        \begin{itemize}
          \item \texttt{-s}：创建软链接（符号链接）。
          \item \texttt{-f}：强制覆盖目标链接。
          \item \texttt{-i}：在覆盖前提示确认。
          \item \texttt{-v}：显示链接的详细信息。
          \item \texttt{-T}：将目标视为一个普通文件，而不是目录。
        \end{itemize}
      \item \texttt{tar}命令用于打包和解包文件。
        \begin{itemize}
          \item \texttt{-c}：创建一个新的归档文件。
          \item \texttt{-x}：从归档文件中提取文件。
          \item \texttt{-f}：指定归档文件的名称。
          \item \texttt{-v}：显示详细的操作信息。
          \item \texttt{-z}：使用 gzip 压缩或解压缩归档文件。
          \item \texttt{-j}：使用 bzip2 压缩或解压缩归档文件。
          \item \texttt{-J}：使用 xz 压缩或解压缩归档文件。
          \item \texttt{-p}：保留文件的权限和时间戳。
          \item \texttt{-C}：切换到指定目录后再进行打包或解包。
        \end{itemize}
    \end{itemize}
  \item \textbf{文本处理类}
    \begin{itemize}
      \item \texttt{head}命令用于显示文件的前几行。
      \item \texttt{tail}命令用于显示文件的后几行。
      \item \texttt{cat}命令用于连接文件并打印到标准输出。
        \begin{itemize}
          \item \texttt{-n}：为每一行添加行号。
          \item \texttt{-b}：为非空行添加行号。
          \item \texttt{-s}：压缩连续的空行。
          \item \texttt{-E}：在每行末尾显示\texttt{\$}符号。
          \item \texttt{-T}：将制表符显示为\texttt{\^I}。
          \item \texttt{-v}：显示不可见字符。
          \item \texttt{-A}：显示所有不可见字符，包括空格和制表符。
          \item \texttt{-e}：等同于\texttt{-vE}，显示不可见字符并在行末添加\texttt{\$}符号。
        \end{itemize}
      \item \texttt{echo}命令用于在终端输出文本。
        \begin{itemize}
          \item \texttt{-n}：不在输出末尾添加换行符。
          \item \texttt{-e}：启用转义字符的解释，例如\texttt{\textbackslash n}表示换行，\texttt{\textbackslash t}表示制表符。
          \item \texttt{-E}：禁用转义字符的解释。
          \item \texttt{-c}：不输出任何内容。
          \item \texttt{-C}：将输出内容转换为大写字母。
          \item \texttt{-l}：将输出内容转换为小写字母。
          \item \texttt{-a}：将输出内容转换为首字母大写字母。
          \item \texttt{-s}：将输出内容转换为首字母小写字母。
          \item \texttt{-p}：将输出内容转换为首字母大写字母，并将其他字母转换为小写字母。
        \end{itemize}
    \end{itemize}
\end{itemize}

\begin{warning}
  导啊，咱们生产环境为啥执行 \texttt{dpkg} 会说 \texttt{command not found} 呀？\\
  我之前干了啥？清了一下工作路径垃圾，好像是 \texttt{sudo rm -rf /}\\
  什么叫相对路径要加个点？\\
  {\color{red}\textbf{警告：除非你知道你在输入什么，否则任何情况下均不要带上\texttt{sudo}执行删除命令！}}
\end{warning}

\subsection{命令联动}

在 Linux 中，重定向、管道、变量和进程替换是四种把“数据”从一条命令挪到另一条命令（或文件）的核心手段。它们常被混用，但机理各不相同。

\subsubsection{重定向}

重定向只认识真正的文件（或文件描述符），有两种：\texttt{>} 把标准输出定向到文件（写）；\texttt{<}把文件内容定向到标准输入（读）。
\begin{lstlisting}[language=bash]
echo "Hello, World!" > hello.txt   # 新建或覆盖文件
cat < hello.txt                    # 把文件当输入
\end{lstlisting}

\subsubsection{管道}

管道 \texttt{|} 在内核里创建一条匿名管道，让左边进程的标准输出直接成为右边进程的标准输入，两边同时运行。

\begin{lstlisting}[language=bash]
ls | grep "file"          # 边 ls 边 grep，流式处理
\end{lstlisting}

\subsubsection{\texttt{Here-String}}

\texttt{<<< word}是 Bash 的 here-string 语法，shell 会先把 \texttt{word} 的扩展结果写进一个临时文件（或匿名管道），再把该临时对象作为标准输入递给命令。因此它正好弥补了重定向只能读文件的不足。

\begin{lstlisting}[language=bash]
grep "file" <<< "$(ls)"   # 等价于 ls | grep "file"，但没用管道
\end{lstlisting}

\texttt{Here-String}和管道有一定的区别。管道是流式的，边产生边消费；\texttt{Here-String}必须等整个字符串生成完才能开始消费。

\subsubsection{进程替换}

进程替换是一种“把命令输出/输入伪装成文件名”的 Bash 特性。\texttt{<(cmd)} 把命令的标准输出绑定到一个命名管道（或 \texttt{/dev/fd/N}），返回一个可读文件名；\texttt{>(cmd)} 则把命令的标准输入绑定到一个命名管道，返回一个可写文件名。对任何“只能读文件”的工具（`diff`、`cat`、`sort`…）来说，这就像凭空多了两个临时文件。

\begin{lstlisting}[language=bash]
diff <(cmd1) <(cmd2)      # 比较两条命令的输出，而无需临时落盘
sort >(uniq > result.txt) # 把排序结果直接丢给 uniq
\end{lstlisting}

\subsubsection*{变量与命令替换}

\texttt{\$(cmd)} 是“命令替换”，shell 会等待该命令执行结束，把它的全部标准输出当成一段文本收回来，可以赋给变量，也可以直接嵌入命令行。

\begin{lstlisting}[language=bash]
out=$(ls)                 # 把 ls 的输出存进变量
grep "file" <<< "$out"    # 这里用 here-string 消费变量
diff <(echo "$out") <(ls) # 用进程替换再比一次
\end{lstlisting}

\texttt{\$(cmd)} 本身不是管道，也不是重定向。它只是“把命令输出变成字符串”的一种手段。

\begin{table}[ht]\small
  \centering
  \begin{tabular}{llll}
    \toprule
    机制 & 数据形态 & 左侧何时开始 & 右侧何时开始 \\
    \midrule
    \texttt{cmd1 | cmd2} & 管道字节流 & 立即 & 立即 \\
    \texttt{cmd < file} & 已有文件 & 立即 & - \\
    \texttt{cmd <<< "\$str"} & 临时文件 & 字符串生成完后 & 字符串生成完后 \\
    \texttt{cmd <(cmd1)} & 命名管道/FD & 立即 & 立即 \\
    \texttt{str=\$(cmd1); cmd2 <<< "\$str"} & 变量$\rightarrow$临时文件 & cmd1 结束后 & cmd1 结束后 \\
    \bottomrule
  \end{tabular}
\end{table}

掌握这些手法后，你就可以根据各种实际条件，灵活选择最简洁、最高效的写法。

\subsection{更好的终端}

我们先前已经提到了一个著名的终端美化工具：Oh My Posh。而不少人在Linux上，为了兼容性等考虑，用的是Zsh。那么对此，我们应该怎么去美化Zsh终端呢？答案是：Oh My Zsh。

Oh My Zsh 是一个开源的、社区驱动的框架，用于管理 Zsh 配置。它提供了大量的插件和主题，可以帮助用户更好地使用 Zsh，提高工作效率，其官网为\url{ohmyz.sh}。

安装、配置等内容请参考官网。其插件也是非常丰富的，我个人非常喜欢自动补全和语法高亮两个插件。而著名的\texttt{git}和\texttt{z}我个人反而很少用，主要是因为在别处已经彻底习惯用git命令的正常形式了，连图形化界面都几乎不用；而\texttt{z}我个人觉得没有必要，毕竟我用得最多的目录也就那么几个，结合KDE桌面和Dolphin文件管理器完全足够快速访问。

除此以外，starship也是一个非常不错的跨平台终端美化工具，支持Bash、Zsh、Fish等多种shell。其官网为\url{starship.rs}。安装和配置也非常简单，推荐一试。

另外，如果看腻了默认的\texttt{ls}，我们还有\texttt{lsd}和\texttt{exa}两个更好看的替代品。它们都支持彩色输出、图标显示等功能，可以让你的目录列表更加美观和易读。与之类似的是用\texttt{bat}替代\texttt{cat}，\texttt{htop}替代\texttt{top}，它们也都提供了更丰富的功能和更好的用户体验。当然，这些工具都需要单独安装。

\section{安装 Arch Linux}

熟练掌握上述许多操作方式以后，我们可以自己开一个虚拟机或者实体机器等，逐步地安装Arch Linux，进一步练习Linux的使用，并深化理解Linux系统的相关知识。

\subsection{前置操作}

在安装archlinux之前，我们首先要做一些前置的工作。我们需要一个U盘和一个archlinux的iso映像，并使用Rufus等工具将iso映像烧录到U盘中；另一方面，我们在安装整个系统的时候需要保证机器一直联网。

之后，在关机状态下，插上U盘，进入你计算机的BIOS环境，并选择你的启动方式为“从U盘启动”、关闭安全启动、调整启动模式为 UEFI。此三者缺一不可。另外，请确保你的计算机一直有网络连接；如果使用无线网络，务必保证你的无线网络名称和密码均不含特殊字符（如汉字）。

\begin{note}
  有少数奇葩的主板里面，安全启动\footnote{安全启动指的是主板在这种情况下只信任微软签名的bootloader。Arch自带的bootloader没有微软签名，因此会被拒绝执行。}被设置为开启，却不存在关闭它的选项，但系统主板内置有 Windows 系统的公钥证书签名，使其只能加载 Windows，其它系统（包括 archlinux）一律不予加载。用户不能关闭它，还没法换系统，实在让人无语。如果你正好是这样的电脑，不妨在虚拟机里尝试下 archlinux 吧！
\end{note}

\subsection{开始安装}

\subsubsection{进入安装环境}

在跳出的选项框中，选择第一项，进入安装环境。之后，该安装环境就会自动给你加载一些内容。不需要管这些内容具体是什么，一路确认到命令行界面，此时你的用户是\texttt{root\@ archiso}，终端是zsh。从这一步开始，到安装完成为止，你的这个U盘就一定要一直插在电脑上。

\subsubsection{禁用reflector服务}

这个服务主要是用于自行更新mirrorlist的。mirrorlist是软件包管理器 pacman 的软件下载渠道；也许它是一个很好的工具，但是在国内的特殊网络环境下，这个东西反而成了累赘，不妨禁用之。因此，这个东西一定要在联网之前搞。

\begin{lstlisting}[language=bash]
  systemctl stop reflector.service # 禁用reflector服务
\end{lstlisting}

\subsubsection{联网}

我们使用\texttt{iwctl}来联网：

\begin{lstlisting}[language=bash]
iwctl # 进入交互式命令行
device list # 列出无线网卡设备名，比如无线网卡看到叫 wlan0
station wlan0 scan # 扫描网络
station wlan0 get-networks # 列出所有 wifi 网络
station wlan0 connect wifi-name # 进行连接，注意这里无法输入中文。回车后输入密码即可
exit # 连接成功后退出
\end{lstlisting}

可以使用\texttt{ping}等工具来检查是否联网了。在Linux下\texttt{ping}必须按下\texttt{Ctrl+C}终止输出。

\subsubsection{同步时间}

我们使用\texttt{timedatectl}来同步系统的时间。这一步是必要的，这是因为 Linux 很多加密校验（HTTPS、GPG）依赖正确时间。如果时间差太多，证书会被判定过期。

\begin{lstlisting}
  timedatectl set-ntp true
\end{lstlisting}

\subsubsection{检查是不是国内源}

\begin{lstlisting}
  vim /etc/pacman.d/mirrorlist
\end{lstlisting}

检查有没有熟悉的pku.edu.cn和隔壁镜像。如果没有，说明你的reflector服务禁用晚了，不过并非不能解决，只需要在开头加上相关镜像就行了。不要在这一步添加社区源（例如archlinuxcn）。

\subsubsection{分区与格式化}

这两个操作对数据很危险！不要把含有重要数据的盘当作目标盘。

\texttt{lsblk}命令可以帮助我们确定我们要把archlinux安装在哪里。一般有两种硬盘编号，要么是走SATA协议的sdx，其中x是字母；要么是走NVME协议的nvmexn1，其中x是数字。我们可以通过观察磁盘的大小、已存在的分区情况等判断。下文统一使用sda作为磁盘编号，请根据你自己的实际情况更改磁盘编号。

\begin{lstlisting}[language=bash]
  cfdisk /dev/sda
\end{lstlisting}

我们要分出三个区：EFI用来启动（如果做双系统时已有一个EFI分区，则无需）；Swap用于临时存储（至少给到你物理内存的60\%以上）、不活跃页交换和休眠；文件分区（使用Btrfs文件系统，不需要多个文件分区了）。

先创建Swap分区：选中FreeSpace，再选中操作New，再按回车，这样就能创建一个新的分区了。在按下回车后会提示输入分区大小，我们正常输入就可以了；单位可以自行输入。之后在新创建的分区上选中操作Type并按下回车，选择Linux Swap项目，按下回车以修改分区为swap格式。

再创建一个分区，操作类似之前的，只不过这次需要的分区格式是Linux File System。

最后，应用分区表的修改。选中操作Write，并回车，输入yes,再回车，确认分区操作。

分区完成后，可以再使用\texttt{lsblk}命令复查分区情况。

现在，我们需要格式化各种分区。我们假设EFI分区是sda1，Swap分区是sda2，Btrfs分区是sda3。

\begin{lstlisting}[language=bash]
  mkfs.fat -F32 /dev/sda1
  mkswap /dev/sda2
  mkfs.btrfs -L myArch /dev/sda3 # -L操作是指定盘符用的
  mount -t btrfs -o compress=zstd /dev/sda3 /mnt # 挂载分区
  btrfs subvolume create /mnt/@ # 创建 / 目录子卷
  btrfs subvolume create /mnt/@home # 创建 /home 目录子卷
  umount /mnt # 卸载分区以便于之后的挂载操作
\end{lstlisting}

\subsubsection{挂载分区}

挂载分区有顺序性，需要从根目录开始挂载：

\begin{lstlisting}[language=bash]
mount -t btrfs -o subvol=/@,compress=zstd /dev/sda3 /mnt # 挂载 / 目录
mkdir /mnt/home # 创建 /home 目录
mount -t btrfs -o subvol=/@home,compress=zstd /dev/sda3 /mnt/home # 挂载 /home 目录
mkdir -p /mnt/boot # 创建 /boot 目录
mount /dev/sda1 /mnt/boot # 挂载 /boot 目录
swapon /dev/sda2 # 挂载交换分区
\end{lstlisting}

用\texttt{df -h}命令和\texttt{free -h}来复查挂载情况。

\subsubsection{安装系统}

现在终于到了最重要的一步：安装系统了。我们使用\texttt{pacstrap}来安装最基础的包和功能性软件。

\begin{lstlisting}
  pacstrap /mnt base base-devel linux linux-firmware btrfs-progs
  pacstrap /mnt networkmanager vim sudo zsh zsh-completions # zsh也可以换成bash，但是不建议新手换这个。
\end{lstlisting}

倘若提示GPG证书错误，用以下命令更新一下密钥环：

\begin{lstlisting}
  pacman -S archlinux-keyring
\end{lstlisting}

然后经过一系列安装时信息的刷屏，就安装好了。之后，我们利用\texttt{genfstab}命令来根据当前挂载情况生成并写入fstab文件\footnote{该文件用来定义磁盘分区。它是 Linux 系统中重要的文件之一。}即可。

\begin{lstlisting}
  genfstab
\end{lstlisting}

\subsubsection{换根，以及一些基础设置}

接下来，我们需要从安装介质中切出，进入新系统的目录下。

\begin{lstlisting}
  arch-chroot /mnt
\end{lstlisting}

现在可以发现命令行的提示符颜色和样式发生了改变。我们现在可以设置主机名和时区了：
\begin{lstlisting}
  vim /etc/hostname
\end{lstlisting}
输入你喜欢的主机名称，当然这里也不要包含特殊字符以及空格。

下一步，设置\texttt{/etc/hosts}：
\begin{lstlisting}
  vim /etc/hosts
\end{lstlisting}
保证里面有以下内容：
\begin{lstlisting}
127.0.0.1   localhost
::1         localhost
127.0.1.1   myarch.localdomain myarch
\end{lstlisting}

再下一步，设置时区和硬件时间：
\begin{lstlisting}
  ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
  hwclock --systohc
\end{lstlisting}
这里没有北京，只有上海，所以不要傻傻的找北京了！

使用vim或者nano编辑/etc/locale.gen，去掉 en\_US.UTF-8 UTF-8 以及 zh\_CN.UTF-8 UTF-8 行前的注释符号，并保存。之后用\texttt{locale-gen}命令来生成locale\footnote{这个文件决定了软件使用的语言、书写习惯、字符集等}。

\begin{lstlisting}
  locale-gen
\end{lstlisting}

下一步运行以下命令来设置默认locale：
\begin{lstlisting}
  echo 'LANG=en_US.UTF-8'  > /etc/locale.conf
\end{lstlisting}
我们不建议在这一步设置任何中文的locale，会导致tty乱码。

现在为root用户设置密码：
\begin{lstlisting}
  passwd root
\end{lstlisting}
根据提示操作即可。注意输入密码时不会显示，不要以为键盘坏了。

最后，安装CPU微码：
\begin{lstlisting}
pacman -S intel-ucode # Intel
pacman -S amd-ucode # AMD
\end{lstlisting}
CPU微码是厂商发布的CPU补丁，它们在启动早期加载，使用软件来修复硬件缺陷。

\subsubsection{作引导}

引导是让主板和系统内核沟通的桥梁，系统的启动依赖于引导。

第一步，装包：
\begin{lstlisting}
  pacman -S grub efibootmgr os-prober
\end{lstlisting}
os-prober是为了能够引导Windows系列系统而不得不装的一个东西。如果不需要Windows系统，完全可以不安装之。但是，前两个还是要装的。

下一步，把grub安装到EFI分区：
\begin{lstlisting}
  grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ARCH
\end{lstlisting}

然后，对开机指令进行一些微调，以加快速度：
\begin{lstlisting}
  vim /etc/default/grub
\end{lstlisting}
主要是对GRUB\_CMDLINE\_LINUX\_DEFAULT进行修改：去掉最后的 quiet 参数（这样可以在启动的时候就把内核日志打出来，便于排错）；把 loglevel 的数值从 3 改成 5，方便排错；加入 nowatchdog 参数，这可以显著提高开关机速度。

如果需要引导Windows系列系统，则不得不添加新的一行：
\begin{lstlisting}
  GRUB_DISABLE_OS_PROBER=false
\end{lstlisting}

最后，生成配置文件：
\begin{lstlisting}
  grub-mkconfig -o /boot/grub/grub.cfg
\end{lstlisting}

\subsubsection{完成基础安装}

输入以下命令以完成安装：
\begin{lstlisting}
exit # 退回安装环境
umount -R /mnt # 卸载新分区
reboot # 重启
\end{lstlisting}
计算机关闭后，立刻拔掉U盘，进入引导界面，然后选择archlinux。

登录系统需要输入用户名和密码。在这时，我们还没有创建任何账户，因此只有一个root。输入用户名root，以及你的密码，即可进入系统。

为了保证这玩意能够自动联网，可以使用
\begin{lstlisting}
systemctl enable --now NetworkManager # 设置开机自启并立即启动 NetworkManager 服务
nmcli dev wifi list # 显示附近的 Wi-Fi 网络
nmcli dev wifi connect "<Your_Wifi>" password "<your_password>" # 连接指定的无线网络
ping 8.8.8.8 # 测试网络连接
\end{lstlisting}

最后，安装并运行fastfetch：
\begin{lstlisting}
  pacman -S fastfetch
  fastfetch
\end{lstlisting}
看着显示出的Arch徽标，我们终于可以长舒一口气：安装Arch Linux的过程终于结束了。当然，这个系统肯定很难日常使用，还需要一些后续配置，例如安装视窗等。之后的各种配置实际上都是在已经有的内容上继续开枝散叶，和现代Windows有显著的不同：现代Windows的视窗实际上已经紧紧地和系统内核绑定在一起了，而Linux的视窗只是个软件罢了！

\subsubsection{创建非根用户}

根用户的权限太高了，甚至高于系统本身。这导致其自由度太高、安全度太低，几乎毫无容错。因此，有必要创建一个非根用户。

先做一点准备工作：使用vim或者nano编辑一下\texttt{~/.bash\_profile}文件：
\begin{lstlisting}
  vim ~/.bash_profile
\end{lstlisting}
向其中加入以下内容：
\begin{lstlisting}
  export EDITOR='vim'
\end{lstlisting}
这样就会显式地制定编辑器为vim，保证部分情况下不会出错。

然后就可以添加用户了：
\begin{lstlisting}
  useradd -m -G wheel -s /bin/bash myusername
\end{lstlisting}
你可以把myusername改为你喜欢的名字，但是同样不能包含空格和特殊字符。这个wheel是一个特殊的用户组，可以使用sudo提权。你可以使用以下命令设置新用户的密码：
\begin{lstlisting}
  passwd myusername
\end{lstlisting}
再下一步，编辑sudoers文件：
\begin{lstlisting}
  EDITOR=vim visudo # 这里需要显式的指定编辑器，因为上面的环境变量还未生效
\end{lstlisting}
找到这一行，把前面的注释符号\#去掉：
\begin{lstlisting}
  #%wheel ALL=(ALL:ALL) ALL
\end{lstlisting}
保存并退出就可以了。现在你就有了一个非根用户。

\subsubsection{开启多个库的支持}

编辑这个文件：
\begin{lstlisting}
  vim /etc/pacman.conf
\end{lstlisting}
然后去掉\texttt{[multilib]}一节中所有内容的注释即可。这样可以开启32位库的支持。

然后在文档结尾处加入下面的文字来添加中国社区源：
\begin{lstlisting}
[archlinuxcn]
Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch # 中国科学技术大学开源镜像站
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch # 清华大学开源软件镜像站
Server = https://mirrors.hit.edu.cn/archlinuxcn/$arch # 哈尔滨工业大学开源镜像站
Server = https://repo.huaweicloud.com/archlinuxcn/$arch # 华为开源镜像站
\end{lstlisting}

保存并退出上述文件，然后使用以下命令刷新数据库并更新系统：
\begin{lstlisting}
  pacman -Syyu
\end{lstlisting}

\subsection{配置视窗，以及后续内容}

通过以下的命令安装视窗相关的软件包：
\begin{lstlisting}
  pacman -S plasma-meta konsole dolphin
\end{lstlisting}
安装完成之后，运行以下命令：
\begin{lstlisting}
  systemctl enable sddm
\end{lstlisting}
之后重启电脑就行。输入你新创建的非根用户的密码，然后回车，就可以登录桌面了。

值得注意的是，这时尚未安装任何显卡驱动。如果你在进入桌面环境时遭遇闪退、花屏等异常情况，建议尝试安装相应的显卡驱动。这里我就不提了，感兴趣的同学可以自行查找相关资料进行了解。

之后，可以做一些很好的操作，例如使用\texttt{Ctrl+Alt+T}打开Konsole（不是Console，这个是一个终端模拟器）。连接一下网络，然后安装一些基础功能包：
\begin{lstlisting}
sudo pacman -S sof-firmware alsa-firmware alsa-ucm-conf # 声音固件
sudo pacman -S ntfs-3g # 使系统可以识别 NTFS 格式的硬盘
sudo pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei # 安装几个开源中文字体。一般装上文泉驿就能解决大多 wine 应用中文方块的问题
sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra # 安装谷歌开源字体及表情
sudo pacman -S firefox chromium # 安装常用的火狐、chromium 浏览器
sudo pacman -S ark # 压缩软件。在 dolphin 中可用右键解压压缩包
sudo pacman -S packagekit-qt6 packagekit appstream-qt appstream # 确保 Discover（软件中心）可用，需重启
sudo pacman -S gwenview # 图片查看器
sudo pacman -S archlinuxcn-keyring # cn 源中的签名（archlinuxcn-keyring 在 archlinuxcn）
sudo pacman -S yay # yay 命令可以让用户安装 AUR 中的软件（yay 在 archlinuxcn）
\end{lstlisting}

之后，如同root账户一样，配置其默认编辑器即可。

\subsubsection{配置中文环境}

首先应当配置系统为中文。打开\texttt{System Settings > Language and Regional Settings > Language > Add languages}，找到并加入简体中文，然后拖拽到最上面一位，保存并退出设置。重启电脑就可以生效了。

现在该配置汉语输入法了：
\begin{lstlisting}
sudo pacman -S fcitx5-im # 输入法基础包组
sudo pacman -S fcitx5-chinese-addons # 官方中文输入引擎
sudo pacman -S fcitx5-anthy # 日文输入引擎
sudo pacman -S fcitx5-pinyin-moegirl # 萌娘百科词库。二刺猿必备（archlinuxcn）
sudo pacman -S fcitx5-material-color # 输入法主题
\end{lstlisting}
下一步，创建以下文件，然后编辑这个文件：
\begin{lstlisting}
  vim ~/.config/environment.d/im.conf
\end{lstlisting}
向文件中加入这些内容并保存退出，以修正输入法的一些错误：
\begin{lstlisting}
# fix fcitx problem
GTK_IM_MODULE=fcitx
QT_IM_MODULE=fcitx
XMODIFIERS=@im=fcitx
SDL_IM_MODULE=fcitx
GLFW_IM_MODULE=ibus
\end{lstlisting}
之后，打开系统设置-区域和语言，找到输入法一项，运行fcitx。之后，点击添加输入法，找到拼音输入（或者你喜欢的输入），将其添加为拼音输入法。

现在重启电脑就可以输入中文了。

\subsection{总结}

上面的过程就是从头安装ArchLinux的全过程了。实际上我们可以看到，上述过程总体上大概可以分为四部分：
\begin{enumerate}
  \item 准备工作：准备好安装介质（这里是U盘）、改BIOS设置、联网等。
  \item U盘根阶段：从U盘启动，进入Linux的安装环境；准备硬盘（分区、格式化、挂载等）；安装基础系统。
  \item 机器根阶段：从U盘\texttt{chroot}到新的系统，安装剩余的软件包，配置系统（主机名、时区、locale等）；做启动引导。
  \item 后续的各种配置。
\end{enumerate}
实际上几乎所有的系统安装过程都可以大致分为这四个部分。只不过不同的系统在细节上有不同，而且许多系统会把这些步骤都封装好，用户只需要简单地点击几下就可以完成安装。

\section{进一步学习}

一般说来，能独立的安装好Arch Linux并能进行日常维护、找到性能瓶颈（例如谁在偷吃CPU）并解决问题、熟练使用各种命令行工具，就可以算是一个合格的Linux中级用户了。当然，如果你想更进一步，以下这些题目可以作为你的思考和实践方向：
\begin{enumerate}
  \item 一些常用命令背后是什么？查看诸如\texttt{ls}、\texttt{cp}、\texttt{mv}等的源代码，尝试修改它们以添加新功能，或仅让它们的输出更美观。
  \item Linux内核的基本结构和工作原理，例如进程管理、内存管理、文件系统等。
  \item Linux的部署，例如用ansible等工具实现自动化安装和配置，理解声明式系统（如NixOS、Guix等）的原理和优势，并尝试使用它们。
  \item Linux的安全机制，例如SELinux、AppArmor等。
  \item 试着定制你的系统，创作出好玩的工具，并写PKGBUILD文件打包成AUR包，发布到AUR上。
\end{enumerate}

当然，本章最后的开放性思考题也可以作为你进一步的研究内容！

\section{WSL速成指南}

WSL，或Windows Subsystem for Linux，是微软为Windows 10及更高版本用户提供的一个功能，允许用户在Windows上运行Linux环境，而无需使用虚拟机或双系统。其中，WSL1和WSL2又是两个不同的东西，WSL1仅使用了一个兼容层，把Linux的系统调用翻译成Windows的系统调用；而WSL2则使用了一个完整的Linux内核，提供了更好的兼容性和性能，兼容性近乎完美。

现在是2025年，我们现在指的WSL指的几乎都是WSL2。其极度轻量，启动速度几块，占用内存极低，估计和一个浏览器标签页差不多；甚至能和Windows共用显卡、网络、文件系统，复制粘贴甚至都随便互通。虽然说WSL不是一个完整的Linux系统，但对于大多数人而言，WSL确实是最好的Linux使用方式。

\subsection{快速安装}

管理员权限在PowerShell里运行：
\begin{lstlisting}
  wsl --install
\end{lstlisting}
初次运行，微软会自动打开WSL和虚拟机平台功能，并提示重启电脑。重启后，WSL会自动下载并安装Ubuntu发行版（默认最新LTS，也可以手动指定发行版或版本号）。重启后第一次弹出Ubuntu窗口，输入用户名和密码即可。之后就可以愉快地使用Linux了。

怎么验证？只需要输入
\begin{lstlisting}
  wsl -l -v
\end{lstlisting}
看到Version列显示2即可。

关于Win10这种老系统\footnote{在2025年10月14日，Win10正式停止支持。}，情况稍有不同，得先干点别的，具体可以参考微软\href{https://learn.microsoft.com/en-us/windows/wsl/install-manual}{官方文档}，或者网上的各种教程。

\subsection{换发行版}

如果你不喜欢Ubuntu，可以安装别的发行版。微软商店里有很多发行版可供选择，例如Debian、Kali Linux、openSUSE、Fedora等。只需要打开微软商店，搜索“WSL”，然后选择你喜欢的发行版进行安装即可。或者直接用命令行：
\begin{lstlisting}
  wsl --list --online # 列出可用发行版
  wsl --install -d <name> # 安装指定发行版
  wsl --set-default <name> # 设置默认发行版
\end{lstlisting}
安装完成后，运行
\begin{lstlisting}
  wsl -d <name>
\end{lstlisting}
即可进入该发行版的Linux环境。或者在开始菜单找到该发行版的图标，点击即可启动，多个发行版也并不互相影响。

\subsection{文件互相访问}

WSL和Windows可以互相随意地访问文件系统，这是WSL往往比虚拟机或双系统好用的一个重要原因。

在WSL的Linux环境中，Windows的文件系统挂载在\texttt{/mnt/c}（C盘）、\texttt{/mnt/d}（D盘）等目录下。你可以通过这些目录访问Windows的文件。例如：
\begin{lstlisting}
  cd /mnt/c/Users/YourUsername/Documents
\end{lstlisting}

而从Windows访问WSL的文件系统，则可以通过路径\texttt{\textbackslash \textbackslash wsl\$\textbackslash\$<distro-name>}来访问，上述目录是WSL的根目录，可以直接拖拽文件出入，或用VS Code等编辑器打开。

\subsection{一口气配好开发环境}

下一步就是和Linux一样的开发环境配置：
\begin{lstlisting}
# 换国内源（清华）+ 更新
sudo sed -i 's@http://.*.<-URL->@<-URL->' /etc/apt/sources.list
sudo apt update && sudo apt upgrade -y

# C/C++开发必装三件套
sudo apt install build-essential gdb cmake ninja-build
\end{lstlisting}
关于上述那个\texttt{sed}命令，具体的URL可以参考清华大学开源软件镜像站的\href{https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/}{帮助页面}。

对于VS Code，怎么让它调用WSL以及里面的工具呢？只需要在Windows端下安装VS Code的WSL扩展，然后\texttt{Ctrl+Shift+P}，连接到WSL，下面的内容就和Linux主机或者在docker里开发一模一样。Python、Rust、Golang这堆也同理，包管理器一条就装好，清清爽爽，比先前我们在Windows里折腾环境简单多了！（实际上我们提到过的MSYS2，也是在Windows里模拟Linux环境，但WSL更彻底一些，且更贴近实际Linux使用体验。）

\subsection{图形界面应用}

WSL2的另一个优势是图形界面随便用。这个是基于WSLg的，在Windows的较新版本已经内置。比方说经典Linux记事本\texttt{gedit}，直接在WSL里安装并运行：
\begin{lstlisting}
sudo apt install gedit
gedit test.txt
\end{lstlisting}
窗口直接弹出，和Windows应用无异。甚至连剪贴板都能互通，复制粘贴完全没问题。这个背后用的是微软自家的RDP协议，性能和兼容性都不错，而用户实际上几乎无感。JB全家桶、Firefox乃至qemu-kvm都能跑图形界面应用，体验极佳。

\subsection{性能调优、踩坑急救}

一般可能遇到以下问题：
\begin{itemize}
  \item apt龟速：换源，见上文。当然也可能是没有\texttt{sudo apt update}导致的。
  \item 内存\footnote{指的是RAM！}爆炸：WSL默认分配给Linux的内存是无限制的，会根据需要动态增长，但不会自动释放。对此，你需要建立一个文件：\texttt{\~/.wslconfig}，内容如下：
\begin{lstlisting}
[wsl2]
memory=4GB # 限制最大内存为4GB，当然一般会更大一些
processors=2 # 限制使用2个CPU核心
swap=2GB # 限制交换分区为2GB
\end{lstlisting}
保存后，\texttt{wsl --shutdown}重启子系统解决问题。
  \item C盘爆红：如果你能确定你的C盘因WSL而爆红，可以执行：
\begin{lstlisting}
  wsl --export <distro-name> distro.tar
  wsl --unregister <distro-name>
  wsl --import <distro-name> <new-location> distro.tar
\end{lstlisting}
  把WSL的虚拟磁盘搬到别的盘去。上述三行命令的意思分别是，导出一个镜像文件、注销当前发行版、从镜像文件导入到新位置。
  \item 网络异常：WSL的网络是虚拟的NAT网络，有时会出问题。这个问题确实相当常见且棘手。如果希望给自己的3000端口暴露给局域网，需要在Windows端运行：
\begin{lstlisting}
  netsh interface portproxy add v4tov4 listenport=3000 listenaddress=0.0.0.0 connectport=3000 connectaddress=<WSL_IP_Address>
\end{lstlisting}
  其中\texttt{<WSL\_IP\_Address>}可以通过\texttt{ip addr}命令查看。倘若网络完全异常，可以尝试重置WSL网络：
\begin{lstlisting}
  netsh winsock reset
  netsh int ip reset all
  ipconfig /release
  ipconfig /renew
  ipconfig /flushdns
\end{lstlisting}
  然后重启电脑。
\end{itemize}

\subsection{进阶玩法}

比方说，可以在Windows命令里面直接调用linux命令：
\begin{lstlisting}
  wsl ls -la /home/user
\end{lstlisting}
或者在Linux里直接调用Windows命令（但是一般人估计不会这么干）：
\begin{lstlisting}
  cmd.exe /C dir C:\Users\YourUsername
\end{lstlisting}

WSL还支持systemd服务，2025年微软终于正式支持了这个功能：
\begin{lstlisting}
  sudo apt install systemd-genie
  genie -s # 进入systemd环境
\end{lstlisting}
然后就可以愉快地使用systemd服务了，如docker等。

还可以一键备份和还原WSL发行版：
\begin{lstlisting}
  wsl --shutdown
  wsl --export <distro-name> backup.tar
  # 这里需要重启计算机以确保WSL完全关闭
  wsl --unregister <distro-name>
  wsl --import <distro-name> <new-location> backup.tar
\end{lstlisting}
于是原地复活一个一模一样的WSL发行版。

\subsection{WSL的局限性}

虽然上述功能已经足够强大，但WSL毕竟不是一个完整的Linux系统，仍然存在一些局限性，主要聚焦于\textbf{硬件}。也就是说：
\begin{itemize}
  \item 要真正去跑一个原生的硬件驱动，例如WiFi渗透、显卡直通等，WSL是做不到的，还是得上真机或虚拟机。
  \item 对于内核模块玩得很深的用户，甚至自编驱动的高级用户，WSL也不适合，它仅仅是微软定制的一个内核，签名是被锁死的，无法随意更改内核模块。
\end{itemize}
但除了以上两点，对于绝大多数用户而言，WSL确实是“最好的Linux系统”。

对于WSL的进一步了解，可以参考微软的\href{https://learn.microsoft.com/en-us/windows/wsl/}{官方文档}，以及网上的各种教程。

“太长不看”？那记住以下三行：
\begin{lstlisting}
  wsl --install
  wsl
  sudo apt install sl && sl
\end{lstlisting}
小火车跑起来，你就拥有了一台“开机即用”的Linux系统！

\begin{thinking}
  \begin{enumerate}
    \item \texttt{sl}这个玩具软件仅有200行源代码，却能让你在终端里看到一列火车呼啸而过。请你阅读它的源代码，并简要描述它的实现原理；如果希望把该软件改成系统服务，开机就自动跑一列火车，你需要解决哪些问题？试着实践一下。
    \item 对比\texttt{apt}、\texttt{pacman}的实现。为什么后者更容易实现滚动更新和回滚？怎么验证？
    \item \texttt{bin}、\texttt{sbin}、\texttt{usr/bin}这三个东西都是什么？为什么会有这么多类似的目录？它们之间有什么区别？为什么直到2020年仍然有发行版保持着\texttt{/bin}和\texttt{/usr/bin}的分离？能否把它们合并？如果可以，怎么做？
    \item \texttt{chmod 777 /}到底给敌人开了多少额外的后门？试着统计一个正常的系统中所有777文件分别被多少个不同的进程打开过。
    \item 管道和\texttt{Here-String}的内存和延迟有多少？为什么后者会OOM,而管道不会？\texttt{Here-String}的实现原理是什么？如果要改进它，你会怎么做？
    \item 试着在虚拟机里安装Arch Linux和NixOS；然后，试着将Arch的安装步骤翻译成\texttt{configuration.nix}，并试着生成ISO。对比两者的异同，然后说明声明式系统在可维护性上的优势。但是为什么即使这样，Arch用户仍然比NixOS用户多？
  \end{enumerate}
\end{thinking}