\chapter{数据存储和交换}

\begin{outline}
  本章介绍了数据存储和交换的基本概念，涵盖了SQL数据库、NoSQL数据库以及常见的数据交换格式（如JSON、XML、CSV、YAML和TOML）。通过学习本章内容，读者将能够理解不同类型的数据存储和交换格式及其应用场景，并掌握各种数据交换格式的特点和使用方法。
\end{outline}

\begin{prerequisite}
  \begin{itemize}
    \item 基本的编程知识（如变量、数据类型、函数等）
    \item 终端操作基础（如文件读写等）
  \end{itemize}
\end{prerequisite}


在数字世界里，数据是信息的载体，而数据交换则是信息传递的桥梁。本章将探讨数据交换的各种方法和技术。

为了便于数据交换，不同系统之间需要遵循一定的协议和标准。这些协议和标准确保了数据在传输过程中能够被正确理解和处理。现在比较通行的数据交换格式：JSON、XML、CSV、Yaml、Toml。而现行存储数据的数据库系统往往是用SQL数据库来存储结构化数据，用NoSQL数据库来存储非结构化数据。

\section{SQL数据库}

SQL（Structured Query Language）是一种用于管理\textbf{关系型数据库}的标准语言。

关系型数据库的本质是\textbf{表格}。每个表格由行和列组成，行表示记录，列表示字段。SQL数据库使用预定义的模式（schema）来组织数据，这意味着数据必须符合特定的结构。

SQL有着不同的实现，常见的有MySQL、PostgreSQL、SQLite和Microsoft SQL Server等。这些实现大同小异，主要功能几乎相同，但在性能、扩展性和特定功能上有所区别。

\subsection{键和表}

刚刚说到，SQL数据库组织数据的方式是通过表格。每个表格都有一个或多个\textbf{键}或字段，用于唯一标识每一行数据。常见的键类型有：
\begin{itemize}
  \item 主键（Primary Key）：唯一标识表中的每一行数据，不能重复且不能为空。
  \item 外键（Foreign Key）：用于在两个表之间建立关系，引用另一个表的主键。
\end{itemize}
表格中的每一列都有一个数据类型，常见的数据类型包括整数、浮点数、字符串、日期等。通过定义合适的数据类型，可以确保数据的完整性和一致性。

在SQL中，表格之间可以通过关系进行连接（JOIN），这使得我们可以从多个表中提取相关数据。例如，我们可以有一个“用户”表和一个“订单”表，通过用户ID将它们连接起来，以获取每个用户的订单信息。SQL鼓励用户把数据存在多个表格中，通过关系来组织数据（类似MS Access行为），而不是把所有数据都存储在一个大表格中（类似Excel行为）。

\subsection{SQL查询语言}

查询语言分四种类型：数据查询语言（DQL）、数据定义语言（DDL）、数据操作语言（DML）和数据控制语言（DCL）。

\begin{itemize}
  \item 数据查询语言（DQL）：用于从数据库中检索数据，最常用的命令是SELECT。
  \item 数据定义语言（DDL）：用于定义和修改数据库结构，包括CREATE、ALTER和DROP等命令。
  \item 数据操作语言（DML）：用于插入、更新和删除数据，包括INSERT、UPDATE和DELETE等命令。
  \item 数据控制语言（DCL）：用于控制对数据库的访问权限，包括GRANT和REVOKE等命令。
\end{itemize}

SQL的查询等相当类似自然语言，这使得它相对容易学习和使用。以下是一些常见的SQL查询示例：
\begin{itemize}
\item 选择所有列的数据：
\begin{lstlisting}
SELECT * FROM table_name;
\end{lstlisting}
\item 选择特定列的数据：
\begin{lstlisting}
SELECT column1, column2 FROM table_name;
\end{lstlisting}
\item 插入新数据：
\begin{lstlisting}
INSERT INTO table_name (column1, column2) VALUES (value1, value2);
\end{lstlisting}
\item 更新现有数据：
\begin{lstlisting}
UPDATE table_name SET column1 = value1 WHERE condition;
\end{lstlisting}
\item 删除数据：
\begin{lstlisting}
DELETE FROM table_name WHERE condition;
\end{lstlisting}
\end{itemize}

\subsection{SQL数据库的自动更新}

在实际应用中，数据经常需要自动更新以保持最新状态，例如想输入学生的成绩单就能自动计算其GPA。实现自动更新的常见方法包括触发器（Triggers）和存储过程（Stored Procedures）。
\begin{itemize}
\item 触发器：是一种特殊的存储过程，当特定事件（如插入、更新或删除）发生时自动执行。触发器可以用于自动验证数据、维护审计日志或执行复杂的业务逻辑。
\item 存储过程：是一组预编译的SQL语句，可以通过调用来执行。存储过程可以接受参数，返回结果，并且可以包含复杂的逻辑和控制结构。
\end{itemize}

例如，可以创建一个触发器，当学生的成绩被插入或更新时，自动计算并更新其GPA：
\begin{lstlisting}
CREATE TRIGGER update_gpa
AFTER INSERT OR UPDATE ON grades
FOR EACH ROW
BEGIN
  DECLARE new_gpa FLOAT;
  -- 计算新的GPA逻辑
  UPDATE students SET gpa = new_gpa WHERE student_id = NEW.student_id;
END;
\end{lstlisting}
上述SQL语言中，两个横线（--）表示注释内容。如果用存储过程实现类似功能，可以这样写：
\begin{lstlisting}
CREATE PROCEDURE calculate_gpa(IN student_id INT)
BEGIN
  DECLARE new_gpa FLOAT;
  -- 计算新的GPA逻辑
  UPDATE students SET gpa = new_gpa WHERE student_id = student_id;
END;
\end{lstlisting}
然后可以在需要时调用存储过程：
\begin{lstlisting}
CALL calculate_gpa(12345);
\end{lstlisting}
可以看出，触发器是一个自动执行的函数，而存储过程是一个需要手动调用的函数。但两者都可以用于实现SQL数据库的自动更新功能。

想用好SQL数据库，实际上查询语言不是关键，其关键实际上在于怎样设计好数据库的表格和关系，以及哪些内容可以自动更新、哪些内容需要手动更新（如果数据量很大，自动更新可能会影响性能）。这需要根据具体的应用场景和需求来进行设计和优化，也需要数据库的编写者有着对业务逻辑的深刻理解和对数据的高敏感度，才能设计出高效的数据库结构。

\section{数据交换格式}

数据交换格式是指用于在不同系统之间传输和存储数据的标准化格式。常见的数据交换格式包括JSON、XML、CSV、YAML和TOML等。

当然，我们大可以自己创建自己的“数据交换格式”，但这样做会带来兼容性和可维护性的问题，因此通常建议使用已有的标准化格式。

\subsection{JSON}

JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人类阅读和编写，同时也易于机器解析和生成。JSON使用键值对的形式来表示数据，支持嵌套结构。例如，下面是一个简单的JSON示例：
\begin{lstlisting}
{
  "name": "Alice",
  "age": 30,
  "is_student": false,
  "courses": ["Math", "Science"],
  "address": {
    "street": "123 Main St",
    "city": "Wonderland"
  }
}
\end{lstlisting}

容易看出，JSON的结构是“键值对”，其中值可以是字符串、数字、布尔值、数组或另一个对象（用大括号{}表示）。JSON广泛应用于Web开发中，用于客户端和服务器之间的数据交换。

JSON和Python的字典（dict）结构非常相似，Python提供了内置的json模块来处理JSON数据。可以使用json模块将Python对象转换为JSON字符串，或将JSON字符串解析为Python对象。例如：
\begin{lstlisting}[language=Python]
import json

# 将Python对象转换为JSON字符串
data = {"name": "Alice", "age": 30}
json_string = json.dumps(data)
print(json_string)
# 将JSON字符串解析为Python对象
parsed_data = json.loads(json_string)
print(parsed_data)
\end{lstlisting}

而C++则不得不调用著名的nlohmann/json库来处理JSON数据。

由于JSON和JavaScript的语法非常相似，JavaScript也有内置的JSON对象来处理JSON数据。

\subsection{XML}

XML（eXtensible Markup Language）是一种用于表示结构化数据的标记语言。与HTML类似，XML使用标签来定义数据的结构和内容。XML的标签是用户自定义的，可以根据需要创建任意数量的标签。例如，下面是一个简单的XML示例：
\begin{lstlisting}
<person>
  <name>Alice</name>
  <age>30</age>
  <is_student>false</is_student>
  <courses>
    <course>Math</course>
    <course>Science</course>
  </courses>
  <address>
    <street>123 Main St</street>
    <city>Wonderland</city>
  </address>
</person>
\end{lstlisting}

上述内容是一段相当“原教旨主义”的XML代码，标签必须成对出现，并且区分大小写。XML支持嵌套结构，可以表示复杂的数据关系。而稍现代的XML则允许自闭合标签，例如：
\begin{lstlisting}
<person>
  <name="Alice" />
  <age="30" />
</person>
\end{lstlisting}

XML相当重型且冗长，解析XML数据通常需要使用专门的库，例如Python的xml.etree.ElementTree模块或C++的TinyXML库。但因为其更加严格的结构和自定义标签的灵活性，XML在某些领域（如配置文件和文档存储）仍然被广泛使用。例如在游戏《物竞天择》中的自定义场景中，就使用了XML格式来存储场景中的事件信息；在.NET框架的MAUI应用程序中，XAML（eXtensible Application Markup Language）是一种基于XML的标记语言，用于定义用户界面布局和行为。

\subsection{CSV}

CSV（Comma-Separated Values）是一种简单的文本文件格式，直译就是“逗号分隔的值”。CSV文件中的每一行表示一条记录，字段之间使用逗号分隔。例如，下面是一个简单的CSV示例：

\begin{lstlisting}
name,age,is_student
Alice,30,false
Bob,25,true
\end{lstlisting}

CSV可以表示简单的表格数据，易于阅读和编写。由于其简单性，CSV文件可以使用任何文本编辑器打开和编辑。CSV文件广泛应用于数据导入和导出，例如电子表格软件（如Microsoft Excel）通常支持CSV格式。

在Python中，可以使用内置的csv模块来处理CSV数据。例如：
\begin{lstlisting}[language=Python]
import csv
# 读取CSV文件
with open('data.csv', mode='r') as file:
    reader = csv.reader(file)
    for row in reader:
        print(row)
# 写入CSV文件
with open('data.csv', mode='w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['name', 'age', 'is_student'])
    writer.writerow(['Alice', 30, False])
\end{lstlisting}
但在仅分析CSV文件时，Pandas库更为强大和方便。

C++中可以使用诸如RapidCSV等第三方库来处理CSV数据。

\subsection{YAML}

YAML（YAML Ain't Markup Language）是一种人类可读的数据序列化格式，设计目标是简洁和易读。YAML使用缩进来表示数据的层次结构，类似于Python的代码风格。例如，下面是一个简单的YAML示例：
\begin{lstlisting}
name: Alice
age: 30
is_student: false
courses:
  - Math
  - Science
address:
  street: 123 Main St
  city: Wonderland
\end{lstlisting}

YAML是键值对结构，比JSON更简洁，支持复杂的数据类型和嵌套结构；但是其缩进要求相当严格，且冒号后面必须有空格，否则会报错。游戏《物竞天择》的自定义场景文件就使用了假的YAML格式来存储各种参数设置，虽然一眼望上去很像YAML，但实际上并不符合YAML的语法规范（冒号后面没有空格），这让笔者当年编写解析器时吃了不少苦头。

YAML广泛应用于配置文件和数据交换，配置文件通常使用YAML格式。

\subsection{Toml}

TOML（Tom's Obvious, Minimal Language）是一种简洁易读的配置文件格式，设计目标是易于编写和理解。TOML使用键值对和表格来表示数据的层次结构。例如，下面是一个简单的TOML示例：
\begin{lstlisting}
name = "Alice"
age = 30
is_student = false
[courses]
courses = ["Math", "Science"]
[address]
street = "123 Main St"
city = "Wonderland"
\end{lstlisting}

TOML的语法相对简单，支持多种数据类型和嵌套结构。TOML广泛应用于配置文件和数据交换，特别是在Rust编程语言的生态系统中，TOML被用作Cargo包管理器的配置文件格式。

\subsection{INI}

INI是一种简单的配置文件格式，使用键值对和节（section）来组织数据。INI文件通常由多个节组成，每个节包含若干键值对。例如，下面是一个简单的INI示例：
\begin{lstlisting}
[person]
name=Alice
age=30
is_student=false
[courses]
course1=Math
course2=Science
\end{lstlisting}

INI看起来很像YAML和TOML，但实际上语法更为简单，甚至到了简陋的地步。INI缺乏对复杂数据结构的支持，因此在现代应用中逐渐被YAML和TOML等更强大的格式所取代。但由于其简单性，INI文件仍然被一些应用程序用作配置文件格式，例如古老的游戏《红色警戒2》的配置文件就使用了INI格式，即使是现代移植版本（如OpenRA）也继续沿用这种格式，mod作者也往往被称作ini玩家。

\subsection{非显式数据交换格式}

除了上述显式的数据交换格式外，还有一些非显式的数据交换格式，例如二进制格式。此类格式与上述文本格式不同，通常用于高效存储和传输数据。常见的二进制格式包括Protocol Buffers、Avro和MessagePack等。这些格式人类不可读，但在性能和存储效率方面具有优势，适用于需要高效数据交换的场景。

与之类似的还有Base64编码，它并不是一种数据交换格式，而是一种将二进制数据转换为文本格式的方法。Base64编码使用64个字符来表示二进制数据，使任何类型的数据（甚至包括图片和音频）都可以以文本形式进行传输和存储。Base64编码常用于电子邮件和Web应用程序中，以确保数据在传输过程中不会被损坏。

\section{NoSQL}

NoSQL不是一种产品，而是一类数据库管理系统的总称，旨在处理大规模分布式数据存储和高并发访问。NoSQL数据库通常不使用传统的关系型数据库模型，而是采用更灵活的数据模型，如键值对、文档、列族和图形等。

常见的NoSQL数据库包括MongoDB、Cassandra、Redis和Neo4j等。NoSQL数据库通常具有高可扩展性和高性能，适用于大数据分析、实时应用和分布式系统等场景。

笔者对于NoSQL的了解甚少，因此希望同学们能够自行查阅相关资料以深入了解NoSQL数据库的工作原理和应用场景。但现在的SQL数据库也加入了对非结构化数据的支持，例如PostgreSQL现在也支持JSON数据类型，因此在选择数据库时需要根据具体的应用需求进行权衡和选择。