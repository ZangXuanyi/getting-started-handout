\documentclass[../main.tex]{subfiles}

\begin{document}

\chapter{C/C++高速入门}

本章会快速带领大家过一遍C系的基本语法和常用特性，除了用作预习材料以外，还可以在期末考试复习的时候来快速回顾其基本语法与常用的高级特性。

这里直接从C++开始讲起，因为C++是C的超集，C的语法在C++中完全可以使用。

由于C++的语法和特性极多、语法也较为复杂，因此本章节可能会显得有些长、节奏也非常快。

让我们开始吧：

\section{C++的基本语法}

第一次写C++的时候，我们只需要了解一些最基本的语法和特性。记住以下三件事：

\textbf{程序有入口；先存再算；算完告诉外面。}剩下的内容，都跟我们说话一样，只不过是用C++的语法来表达，而且我们说话的句号在C++中是分号。

一个简单的C++程序如下：
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;

int main() {
    int age = 18;
    cout << "I am " << age;
    return 0;
}
\end{lstlisting}
逐行拆解之：
\begin{itemize}
  \item \texttt{\#include <iostream>}：告诉编译器，我要用输入输出工具。
  \item \texttt{using namespace std;}：使用标准命名空间，这样我们就可以直接使用\texttt{cout}而不需要加上\texttt{std::}前缀。
  \item \texttt{int main()}：程序的入口函数，告诉电脑程序从这里开始执行。\texttt{int}表示这个函数返回一个整数值。
  \item \texttt{int age = 18;}：跟电脑说，我要在内存找个地方放个整数，这个地方叫age，放个18进去。
  \item \texttt{cout << "I am " << age; }：把东西一股脑全送到屏幕上。
  \item \texttt{return 0;}：返回0，告诉操作系统：一切OK。除非你知道你在做什么，否则这里不要改成其他数字。
\end{itemize}

以上就是骨架。接下来该往骨架里面填肉了：

\subsection{基本变量及其运算}

变量用来存储数据，可以变化；声明格式是\textbf{“先写类型，再写名字”}。

常见的变量类型有：
\begin{itemize}
  \item \texttt{int}：整数类型，通常是32位（二进制位数）。
  \item \texttt{double}：双精度浮点数，通常是64位。
  \item \texttt{char}：字符类型，通常是8位整数，表示一个字符。也可以用于表示整数。
  \item \texttt{bool}：布尔类型，表示真或假。
  \item \texttt{string}：字符串类型，表示一串字符。
\end{itemize}

对于变量的运算就跟数学差不多，比方说
\begin{lstlisting}[language=C++]
    int a = 10;
    int b = 20;
    int c = a + b;
    c = a * 2;
    c += 5;
\end{lstlisting}
\texttt{int c = a + b}的意思是“我要创建一个变量c，把a+b的结果放进去”。可以看到，从这一行以后再提到c，就不需要再写\texttt{int}了，因为电脑已经知道c是个什么东西了。

下一行\texttt{c = a * 2}的意思是“我要把a乘以2的结果放到c里面，c以前不管是什么我都不要了”，而再下一行\texttt{c += 5}的意思是“我要把c加上5”。在上述代码中，我们发现变量c的值会随着每一行代码的执行而变化，例如第三行代码执行后，c的值变成了30；第四行代码执行后，c的值变成了20；第五行代码执行后，c的值变成了25。所以说c是一个变量。

变量的值也可以在声明时不确定（初始化），例如\texttt{int a;}这样也是可以的。如果在声明的时候不初始化局部变量的值，那么这个变量的初始值将会是一个\textbf{未定义行为}，这个值取决于内存中该位置之前存储的内容。我们不能依赖于这个，因此最好在声明变量的时候就给它赋初始值，例如\texttt{int a = 0;}。对于全局变量，如果不初始化，编译器会自动将其0初始化。

让我们看看常见的运算符：
\begin{itemize}
  \item 四则运算：\texttt{+}（加）、\texttt{-}（减）、\texttt{*}（乘）、\texttt{/}（除）。注意，除法运算中，如果两个整数相除，结果仍然是整数，余数会被舍弃。
  \item 取模：\texttt{\%}，表示取余数。例如\texttt{5 \% 2}的结果是1，因为5除以2的余数是1。
  \item 自增和自减：\texttt{++}（自增）和\texttt{--}（自减）。例如，\texttt{a++}表示将a的值加1，\texttt{b--}表示将b的值减1。
\end{itemize}
不要纠结\texttt{i++}和\texttt{++i}的区别，初学者完全可以认为这两个和\texttt{i += 1}没有区别。一个饱受诟病的题目“\texttt{i = 3, i++ + i++ = ?}”答：这个题目是错误的，至少是不良定义的。不同的编译器对上述代码的处理方式不同。

\textbf{我们非常不建议大家弄出这种代码：\texttt{a = b++}，这种在运算或者赋值中使用自增的代码令人恼火。}如果你想要先用b的值再加1，可以写成\texttt{a = b; b++;}；如果你想要先加1再用b的值，可以写成\texttt{b++; a = b;}。

更现代的程序员往往使用\texttt{i += 1}来代替\texttt{i++}。

是不是非常简单？

\subsection{注释}

注释是代码中的说明文字。它们会被编译器忽略，因此注释完全是给编写者和阅读者看的。

在C++中，注释有两种方法来写：
\begin{itemize}
  \item 单行注释：使用\texttt{//}，例如\texttt{// 这是一个单行注释}。注释符号后面的内容会被编译器忽略，直到行尾为止。
  \item 多行注释：使用\texttt{/* ... */}，例如\texttt{/* 这是一个多行注释 */}。两个注释符号之间的内容会被编译器忽略，可以跨越多行。
\end{itemize}

在阻止部分代码执行的时候，我们一般不习惯于直接删除这些代码，而是使用注释。这样做的好处是可以留痕，便于以后的恢复（解注释）；这就是程序员们常说的“注释掉”代码。在VS Code等编辑器中，常用的一键注释是\texttt{Ctrl + /}，它会自动将光标所在的一行或多行代码注释掉。

\subsection{常量}
常量指的是一旦确定就不会改变的值，任何试图对常量进行更改的操作都会使得编译不通过。常量的值应当在声明时确定，可以通过赋值或者计算得到。

声明常量的方法和声明变量差不多，但是要在最前面加上\texttt{const}关键字，如：
\begin{lstlisting}
const int MAX\_VALUE = 100;
const int P = a + b; // 这里的a和b可以是变量
// P = 10 // 这行代码编译不通过，因此要注释掉
\end{lstlisting}

以上代码的意思是：我要创建一个常量MAX\_VALUE，它的值是100。注意，常量的名字通常使用大写字母来表示，以便于和变量区分。

如果常量的值无需在运行时确定，可以使用编译时常量，这样的常量在编译的时候值就确定了，不过因此也需要在定义中就写明它的值。编译时常量的声明方法和常量类似，只是把\texttt{const}换成\texttt{constexpr}。
编译时常量也可以通过计算得到，计算在编译时进行，可以节省程序运行时间。但是，用于计算的值必须也都是编译时常量，它才能表现为编译时常量；否则就和普通的const没有区别了。下文是编译时常量的几个例子。

\begin{lstlisting}
constexpr double E = 2.71828;
constexpr double PI = 3.14159;
constexpr double EPI = E * PI;
\end{lstlisting}

\subsection{判断和循环}
有时候，代码需要根据不同的条件或不同的输入来执行不同的操作；有时候，一段代码需要执行很多次，但是并不知道具体要执行多少次。C++提供了条件语句和循环语句来实现这些功能。

\subsubsection{条件表达式}
条件表达式是一个布尔表达式，它的值要么是true（真），要么是false（假）。在C++中，条件表达式通常用于控制程序的执行流程。一般情况下，认为false等价于0，true等价于1。

常见的一些条件表达式包括：
\begin{itemize}
  \item \texttt{==}：等于运算符。
  \item \texttt{!=}：不等于运算符。
  \item \texttt{<}：小于运算符。
  \item \texttt{>}：大于运算符。
  \item \texttt{<=}：小于等于运算符。
  \item \texttt{>=}：大于等于运算符。
  \item \texttt{\&\&}：逻辑与运算符。如果前后两个条件都为真，则结果为真；有一个是假的话，结果为假。
  \item \texttt{||}：逻辑或运算符。如果前后两个条件至少有一个为真，则结果为真；如果两个都为假，结果为假。
  \item \texttt{!}：逻辑非运算符。如果后面跟着的条件是真的，那么结果为假；反之为假。
\end{itemize}

在C++中，与或非运算符是有一定的运算顺序的。一般情况下，逻辑非运算符的优先级最高，其次是逻辑与运算符，最后是逻辑或运算符。不过笔者非常不建议同学们背诵这个顺序；实际在工程上不仅不建议大量嵌套使用这些运算符，而且遇事不决可以加括号——括号可比记运算顺序靠谱得多了！

\subsubsection{条件语句}

最常见的条件语句是\texttt{if}语句。它的基本格式如下：
\begin{lstlisting}[language=C++]
if (条件) {
    // 条件为真时执行的代码
}
else if (另一个条件) {
    // 另一个条件为真时执行的代码
}
else {
    // 以上条件全部为假时执行的代码
}
\end{lstlisting}
以上代码可以有很多个\texttt{else if}分支，也可以没有\texttt{else}分支。意思是：我执行到if这一行的时候，检查后面的条件。如果条件为真，那么执行第一个大括号内的代码，剩下的全都不执行；如果条件为假，那么检查下一个\texttt{else if}的条件，如果为真就执行它的大括号内的代码，剩下的全不执行；如果所有的条件都为假，那么执行\texttt{else}大括号内的代码。

例子：
\begin{lstlisting}[language=C++]
if (age < 18) {
    cout << "未成年";
}
else if (age < 60) {
    cout << "成年人";
}
else {
    cout << "老年人";
}
\end{lstlisting}
一目了然，不言而喻。这个age变量可以是前面提到的许多类型。

\subsubsection{三元表达式}

三元表达式也是一种条件表达式，只不过它可以在一行代码中完成条件判断和结果返回，因此显得更简洁。它通常用于简单的条件判断和赋值操作。它的基本格式如下：
\begin{lstlisting}[language=C++]
条件 ? 真值 : 假值
\end{lstlisting}
以上代码的意思是：如果条件为真，整个表达式的值和真值一样；否则，整个表达式的值和假值一样。它非常适合简单的条件判断和赋值操作，但是我们不建议在复杂的条件判断中使用它或者者嵌套使用它，这样会大大降低代码的可读性。

比方说，我们可以用它来判断一个数是奇数还是偶数：
\begin{lstlisting}[language=C++]
int n = 5;
string result = (n % 2 == 0) ? "偶数" : "奇数";
\end{lstlisting}
以上代码的意思是：如果n是偶数，就把字符串“偶数”赋值给result；否则把字符串“奇数”赋值给result。

如果使用if语句来实现同样的功能，可以写成：
\begin{lstlisting}[language=C++]
int n = 5;
string result;
if (n % 2 == 0) {
    result = "偶数";
} else {
    result = "奇数";
}
\end{lstlisting}

\subsubsection{切换语句}
有时候，我们需要根据一个变量的值来执行不同的操作。C++提供了\texttt{switch}语句来实现这个功能。它的基本格式如下：
\begin{lstlisting}[language=C++]
switch (变量) {
    case 值1:
        // 当变量等于值1时执行的代码
        break;
    case 值2:
        // 当变量等于值2时执行的代码
        break;
    default:
        // 当变量不等于任何case的值时执行的代码
}
\end{lstlisting}
以上代码的意思是：检查变量的值，如果等于值1，就执行第一个大括号内的代码；如果等于值2，就执行第二个大括号内的代码；如果都不等于，就执行\texttt{default}大括号内的代码。可以有任意多个\texttt{case}分支，也可以没有\texttt{default}分支。

注意，\texttt{break}语句用于跳出\texttt{switch}，这个是必须的。

例子：
\begin{lstlisting}[language=C++]
switch (day) {
    case 1:
        cout << "星期一";
        break;
    case 2:
        cout << "星期二";
        break;
    case 3:
        cout << "星期三";
        break;
    // ......其他的，基本一个写法
}
\end{lstlisting}
这也一目了然不言而喻了。

\subsubsection{for循环语句}

for循环是灵活度极高的循环语句。它的基本格式如下：
\begin{lstlisting}[language=C++]
for (初始化; 条件; 更新) {
    // 循环体
}
\end{lstlisting}
以上代码的意思是：先执行初始化语句，然后检查条件是否为真。如果为真，就执行循环体内的代码，然后执行更新语句。接着再检查条件，如果为真就继续执行循环体，否则跳出循环。比方说，我们需要打印1到10的数字，可以这样写：
\begin{lstlisting}[language=C++]
for (int i = 1; i <= 10; i++) {
    cout << i << " ";
}
\end{lstlisting}
这段代码的意思是：先初始化一个变量i为1，然后检查i是否小于等于10。如果是，就打印i的值，然后将i加1。接着再检查i是否小于等于10，如果是就继续打印，否则跳出循环。

这个\texttt{int i = 1}可以在其他地方声明过，那么这里就遵从“先声明后使用”的原则，不需要再写int了。

\subsubsection{while和do-while循环语句}
while循环是另一种常见的循环语句。它的基本格式如下：
\begin{lstlisting}[language=C++]
while (条件) {
    // 循环体
}
\end{lstlisting}
以上代码的意思是：先检查条件是否为真。如果为真，就执行循环体内的代码，然后再次检查条件。如果条件仍然为真，就继续执行循环体，否则跳出循环。比方说，我们需要打印1到10的数字，可以这样写：
\begin{lstlisting}[language=C++]
int i = 1;
while (i <= 10) {
    cout << i << " ";
    i++;
}
\end{lstlisting}
以上内容与for循环的例子是等价的。

do-while循环与while循环类似，但它会先执行一次循环体，然后再检查条件。它的基本格式如下：
\begin{lstlisting}[language=C++]
do {
    // 循环体
} while (条件);
\end{lstlisting}
这样可以保证循环体至少执行一次。比方说，我们需要打印1到10的数字，可以这样写：
\begin{lstlisting}[language=C++]
int i = 1;
do {
    cout << i << " ";
    i++;
} while (i <= 10);
\end{lstlisting}

\subsubsection{break和continue语句}

有时候，我们需要在循环中提前跳出循环或者跳过当前的迭代。C++提供了\texttt{break}和\texttt{continue}语句来实现这些功能，它们也叫做循环控制语句。

\texttt{break}语句用于跳出循环，通常用于满足某个条件时立即结束循环。例如：
\begin{lstlisting}[language=C++]
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        break;  // 当i等于5时跳出循环
    }
    cout << i << " ";
}
\end{lstlisting}
上述代码如果不写break一句，那么会输出1到10；如果写了break一句，那么会输出1到4。

而continue语句只用于跳过当前循环的剩余语句，继续下一次迭代。例如：
\begin{lstlisting}[language=C++]
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        continue;  // 当i等于5时跳过当前迭代
    }
    cout << i << " ";
}
\end{lstlisting}
上述代码的输出应该是1 2 3 4 6 7 8 9 10。因为当i等于5时，continue语句会跳过当前迭代的输出语句。

\subsection{输入输出}

在C++中，我们建议使用更安全的输入输出流\texttt{cin}和\texttt{cout}来进行输入输出操作。它们分别用于从标准输入（通常是键盘）读取数据和向标准输出（通常是屏幕）打印数据。

\texttt{cin}和\texttt{cout}的基本用法如下：
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;
int main() {
    int age;
    cout << "请输入你的年龄：";  // 输出提示信息
    cin >> age;  // 从标准输入读取数据
    cout << "你输入的年龄是：" << age << endl;  // 输出读取到的数据
    return 0;
}
\end{lstlisting}
以上代码的意思是：先输出提示信息“请输入你的年龄：”，然后从标准输入读取一个整数值并存储到变量age中。接着输出“你输入的年龄是：”以及读取到的年龄值。

C风格的输入输出分别是\texttt{printf}和\texttt{scanf}，它们的用法如下：
\begin{lstlisting}[language=C++]
#include <cstdio>
// 也可以写成 #include <stdio.h>，但不推荐
using namespace std;
int main() {
    int age;
    printf("请输入你的年龄：");  // 输出提示信息
    scanf("%d", &age);  // 从标准输入读取数据
    printf("你输入的年龄是：%d\n", age);  // 输出读取到的数据
    return 0;
}
\end{lstlisting}
以上代码中，\texttt{\%d}的意思是“这里要输出一个整数”，而\texttt{\&age}的意思是“把age的地址传给scanf”。前者叫做“格式化输出”，后者叫做“地址传递”。\texttt{printf}和\texttt{scanf}的速度更快，因为不需要流操作；但是它们存在一些安全隐患，例如格式化字符串攻击和缓冲区溢出等问题。现代C编程中，微软推荐使用\texttt{scanf\_s}和\texttt{printf\_s}来代替\texttt{scanf}和\texttt{printf}，它们允许一个额外的参数来指定缓冲区的大小，从而避免缓冲区溢出的问题。但是，gcc和clang均不支持这两个函数。

不过，虽然在做题的时候确实可以使用\texttt{scanf}和\texttt{printf}来压榨时间，但是我们仍然建议在C++工程上使用更安全的\texttt{cin}和\texttt{cout}。

\begin{tcolorbox}
    实际上，\texttt{cin}和\texttt{cout}和\texttt{printf}和\texttt{scanf}区别巨大。后者是一个函数，而前者是一个“流对象”（可以理解为一个“东西”而不是一个“手段”）。它们是C++标准库中的流对象，真正负责输入输出的实际上是\texttt{<istream>}头文件中的\texttt{istream::read}和\texttt{<ostream>}头文件中的\texttt{ostream::write}方法，它们被封装进\texttt{>>}和\texttt{<<}这两个运算符（流运算符），和我们的加减乘除等运算符一样。这两个运算符必然是返回流对象的一个引用，因此可以链式调用。特别的，当输入失败的时候，会返回流对象的一个“失败”状态，因此可以通过\texttt{cin.fail()}来判断输入是否成功，也可以通过布尔上下文转换（例如\texttt{while(cin>>n)}）来判断输入是否成功。

    实际上，流运算符也不是它们的原本样子。它们原本是右移和左移运算符：例如\texttt{a<<b}是对a进行左移操作，将a的二进制表示整体向左边移动b位，右边补0；右移类似（只不过对于有符号整数最高位是0补0，是1补1；无符号整数默认补0）。在\texttt{<iostream>}头文件中，这两个运算符被重载了，使得它们可以用于流对象，进而辅助执行输入输出操作；也正因此，我们需要引用上述头文件才能使用它们。不过值得庆幸的是，我们可能一辈子都不会用到它们的原本样子。

    头文件\texttt{<stdio.h>}是C的头文件，而\texttt{<cstdio>}是这个头文件在C++中的移植版本。两者内容完全一致，只不过\texttt{<cstdio>}使用了C++的命名空间（\texttt{std}）；但是由于C++是C的超集，因此大多数实现也允许不套命名空间直接用\texttt{printf}等。在现代风格的C++编程中，我们通常使用\texttt{<iostream>}或\texttt{<cstdio>}来进行输入输出操作，而不是使用\texttt{<stdio.h>}。
\end{tcolorbox}

这些看起来都非常简单。而以上内容就是C++的全部基本语法了：是的，你已经学完了！

\subsection{小练}

\begin{tcolorbox}[title={练习：验证角谷猜想}]
角谷猜想是一个有趣的数学问题：从任意整数开始，如果他是奇数就乘以3加1，如果是偶数就除以2，如此反复循环，最终一定会得到1。目前还没有人证明这个猜想，但我们可以用C++来验证一些具体值。请编写一个C++程序，输入一个整数n，然后输出这个整数经过角谷猜想的处理后，最终得到1的过程。要求输出每一步的结果。例如，输入n=6时，输出应该是：6, 3, 10, 5, 16, 8, 4, 2, 1。    
\end{tcolorbox}

\subsubsection{解答}
一句一句地看：任意整数，奇数乘以3加1，偶数除以2。这一段代码写起来很方便。我们知道，整数的奇偶性可以通过取模来判断：如果n\%2==0，那么n是偶数；否则n是奇数。

因此仅仅这句话，从人的自然语言到代码语言的转换就非常简单了。
\begin{lstlisting}[language=C++]
int n;
if(n % 2 == 0) {
    n /= 2; // 偶数除以2
} else {
    n = n * 3 + 1; // 奇数乘以3加1
}
\end{lstlisting}

或者使用三元表达式：
\begin{lstlisting}[language=C++]
n = (n % 2 == 0) ? (n / 2) : (n * 3 + 1);
\end{lstlisting}

然后是下一句话：如此反复循环。这说明我们至少需要写一个循环语句。再看下一句：最终一定会得到1。

这样我们就明确了：我们需要写一个循环语句，跳出循环的条件是n等于1。于是我们可以写成：
\begin{lstlisting}[language=C++]
while(n != 1){
    // 处理 n 的代码
}
\end{lstlisting}

再看下一句：输入一个整数n，输出每一步的结果。这说明我们需要一个输入语句和一个输出语句。输入语句可以用\texttt{cin}，输出语句可以用\texttt{cout}。

题目读完了，那么我们就可以把这些代码组合起来了：
\begin{lstlisting}[language=C++]
int n;
cin >> n; // 输入一个整数n
cout << n; // 输出初始值
while(n != 1) {
    if(n % 2 == 0) {
        n /= 2; // 偶数除以2
    } else {
        n = n * 3 + 1; // 奇数乘以3加1
    }
    cout << " " << n; // 输出每一步处理后的结果
}
\end{lstlisting}
这就是基本的代码框架。下一步，我们结合一开始说的话：程序要有入口，先存再算，算完告诉外面。于是我们可以真正地完成这段代码：
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n; // 输入一个整数n
    cout << n; // 输出初始值
    while(n != 1) {
        if(n % 2 == 0) {
            n /= 2; // 偶数除以2
        } else {
            n = n * 3 + 1; // 奇数乘以3加1
        }
        cout << " " << n; // 输出每一步处理后的结果
    }
    return 0; // 返回0，表示程序正常结束
}
\end{lstlisting}
这段代码就是一个完整的C++程序了。同学们可以在自己的电脑上编译运行，看看效果！

\begin{tcolorbox}[title={练习}]
    用三元表达式来改写这个程序。
\end{tcolorbox}

\section{C++的进阶使用}

\subsection{更进阶的变量类型}
C++提供了许多更进阶的变量类型和特性，可以帮助我们更好地组织代码和数据。以下是一些常见的进阶变量类型和特性：
\subsubsection{数组（C风格）}

数组是一个可以存储多个同类型数据的变量。它的基本格式如下：
\begin{lstlisting}[language=C++]
类型 数组名[大小];
\end{lstlisting}
以上代码的意思是：声明一个名为数组名的数组，它可以存储大小个同类型的数据。数组的索引从0开始。例如，我们可以声明一个整数数组来存储10个整数：
\begin{lstlisting}[language=C++]
int arr[10];
\end{lstlisting}
以上的数组arr中的元素可以通过索引来访问，例如arr[0]表示第一个元素，arr[1]表示第二个元素，以此类推，一直到arr[9]表示第十个元素。没有arr[10]，访问这个会出错。我们不能像Python一样访问arr[-1]，因为C++不支持负索引。

在C和C++中，数组的大小应当是一个常量，或者说C风格的数组是\textbf{无法动态扩展的}。

\begin{tcolorbox}
  变长数组（VLA）是C99标准引入的特性，允许数组的大小在运行时确定，但它在C11中被变为可选特性。C++不支持任何VLA特性。容易引起误会的是，GCC 和 Clang++ 编译器提供了包含 VLA 的GNU 扩展语法，并且默认引入这些扩展，因此，VLA （例如\texttt{int n; int a[n];}）在这些编译器下可行。反之，如果关闭这些扩展（通过添加 -pedantic-errors 选项）或者非 GNU 兼容的编译器（如 MSVC），则 VLA 不可用。在实际操作中，我们不要去写VLA，它们可能会导致代码在不同编译器下的表现不一致。C中，我们需要使用数组但是长度不确定的时候，可以将数组开得大一些，例如题目有1000个元素，那么就开1000个元素或者稍多元素的数组；C++中，我们可以使用向量\texttt{std::vector}来代替数组，该类可以动态扩展。    
\end{tcolorbox}

\subsubsection{字符串}
C++风格的字符串类型是\texttt{std::string}，它可以存储一串字符。字符串的基本格式如下：
\begin{lstlisting}[language=C++]
#include <string>   // 引入字符串库
string str = "Hello, World!";
\end{lstlisting}
引用字符串库是必要的，否则编译器可能会报错；这个库还提供了一些对字符串进行操作的方法，非常方便。

字符串的本质是一个数组，存储了一串字符（C风格的字符串正是char[]）。我们可以通过索引来访问字符串中的字符，例如str[0]表示第一个字符，str[1]表示第二个字符，以此类推。

字符串的长度可以通过\texttt{str.length()}方法来获取。除此以外，还有很多字符串操作方法，例如\texttt{str.substr()}（获取子串）、\texttt{str.find()}（查找子串）等。

字符串是一个复杂类，和以上提到的所有数据类型都有区别。具体为什么是“复杂类”，这涉及到C++的面向对象编程（OOP）特性。我们会在后续章节中详细介绍。

\subsubsection{结构体}
结构体是一个可以存储多个不同类型数据的变量。它的基本格式如下：
\begin{lstlisting}[language=C++]
struct 结构体名 {
    类型 成员名1;
    类型 成员名2;
    // ...
};
\end{lstlisting}
以上代码的意思是：声明一个名为结构体名的结构体，它可以存储多个不同类型的数据。结构体的成员可以是任意类型，包括基本类型、数组、字符串等。
例如，我们可以声明一个表示学生的结构体：
\begin{lstlisting}[language=C++]
struct Student {
    string name;  // 学生姓名
    int age;      // 学生年龄
    double gpa;   // 学生绩点
};

Student student1;  // 声明一个学生变量
student1.name = "Alice";  // 设置学生姓名
student1.age = 20;  // 设置学生年龄
student1.gpa = 3.5;  // 设置学生绩点
cout << "Name: " << student1.name << ", Age: "
     << student1.age << ", GPA: " << student1.gpa << endl;
\end{lstlisting}

以上内容很好地展示了怎么定义、声明、使用一个结构体。结构体的成员可以通过点（.）运算符来访问，例如\texttt{student1.name}表示学生1的姓名。

结构体可以帮助我们更好地组织数据，使得代码更易读。

\subsection{联合体}

联合体（union）是一个特殊的结构体，它的所有成员共享同一块内存空间。联合体的基本格式如下：
\begin{lstlisting}[language=C++]
union 联合体名 {
    类型 成员名1;
    类型 成员名2;
    // ...
};
\end{lstlisting}
以上代码的意思是：声明一个名为联合体名的联合体，它可以存储多个不同类型的数据，但它们共享同一块内存空间。联合体的成员可以是任意类型，包括基本类型、数组、字符串等。

例如，我们可以声明一个表示数据的联合体：
\begin{lstlisting}[language=C++]
union Data {
    int intValue;       // 整数值
    float floatValue; // 双精度浮点数值
};
Data data;  // 声明一个数据变量
data.intValue = 42;  // 设置整数值
cout << "Int Value: " << data.intValue << endl;
\end{lstlisting}
以上代码的意思是：声明一个名为Data的联合体，它可以存储整数值、双精度浮点数值和字符值。我们可以通过访问联合体的成员来获取数据。

当然，对于上述代码中使得data为int的值为42的情况，data中的其他成员也已经随之确定：也就是把floatValue的二进制表示设定为42的二进制表示。但是，根据Mini ICS的知识我们知道，整数和浮点数的二进制表示是不同的，因此这个浮点数是一个确定的值，但它并不是42。

\subsection{指针}

指针可以说是奠定C和C++地位的最重要特性之一，它允许用户像汇编一样直接操作内存地址。

指针实际上也是一个变量，但是它并不是像前文所说的变量“存储数据”，而是“存储地址”。例如，我们\texttt{int a = 10}，这个a确实是一片内存空间，但是我们没办法利用a访问这片内存空间的地址。指针可以做到这一点。比如说，\texttt{int* p = \&a}，这个p就是一个指针，它存储了变量a的地址（\&a）。我们可以通过\texttt{*p}来访问这个地址上的数据。

如果依然云里雾里，可以试着print一下\texttt{p}和\texttt{*p}的值。我们发现，前者输出的是一串十六进制数，而后者输出的是10。

我们可以利用指针进行一些较为高级的控制。例如控制数组的访问、动态内存分配等。比方说：

\begin{lstlisting}[language=C++]
int arr[5] = {1, 2, 3, 4, 5};  // 声明一个数组
int* p = arr;  // 声明一个指针，指向数组的首元素
for (int i = 0; i < 5; i++) {
    cout << *(p + i) << " ";  // 通过指针访问数组元素
}
\end{lstlisting}

指针是一种非常强大的工具，但也需要小心使用。错误地使用指针可能会导致程序崩溃或内存泄漏，有时候也有可能会导致悬空指针的问题。悬空指针是指指向已经释放的内存空间的指针，这种指针无法访问有效的数据，可能会导致程序崩溃或产生不可预知的后果。除此之外，滥用指针还可能导致指向错误的、未初始化的地址等，这些被称为“野指针”。

\begin{tcolorbox}
  悬空指针不是空指针！空指针是指向空地址的指针，是安全的；悬空指针是指向已经释放的内存空间（现在可能已经装进去一些其他数据）的指针，是不安全的。
\end{tcolorbox}

在C++中，有一些比较高级的指针特性，例如智能指针（smart pointer）。它可以自动管理内存，避免内存泄漏和野指针等问题。常见的智能指针有\texttt{std::unique\_ptr}、\texttt{std::shared\_ptr}和\texttt{std::weak\_ptr}。

\subsection{引用}

引用是C++中的一个重要特性，它允许我们创建一个变量的别名。引用的基本格式如下：
\begin{lstlisting}[language=C++]
类型& 引用名 = 原变量名;
\end{lstlisting}
以上代码的意思是：声明一个名为引用名的引用，它是原变量名的别名。引用的作用是可以通过别名来访问原变量。例如，我们可以声明一个整数的引用：
\begin{lstlisting}[language=C++]
int a = 10;  // 声明一个整数变量
int& ref = a;  // 声明一个整数的引用
cout << "a: " << a << ", ref: " << ref << endl;
ref = 20;  // 修改引用的值
cout << "a: " << a << ", ref: " << ref << endl;
\end{lstlisting}

以上代码的意思是：声明一个名为ref的引用，它是变量a的别名。我们可以通过ref来访问a。当我们修改ref的值时，实际上也修改了a的值。

引用的本质其实也是一个指针，但是它的语法简洁得多。引用可以用于函数参数传递、返回值等场景，可以避免不必要的内存拷贝，提高程序性能。在C++中，比起指针，我们更推荐使用安全、简洁的引用。

\subsection{函数和变量的作用域}

有时候，我们需要在这个地方使用一些代码，在另外一个地方也使用同样的代码。为了避免重复编写代码，我们可以将这些代码封装成一个函数。函数是一个可以重复调用的代码块，它可以接受参数并返回结果。

函数的基本格式如下：
\begin{lstlisting}[language=C++]
返回类型 函数名(参数列表) {
    // 函数体
    return 返回值;  // 如果返回类型不是void，则需要返回一个值
}
\end{lstlisting}
以上代码的意思是：声明一个名为函数名的函数，它可以接受参数列表中的参数，并返回一个返回类型的值。函数体是函数的具体实现。

例如，我们可以声明一个计算两个整数和的函数：
\begin{lstlisting}[language=C++]
int add(int a, int b) {
    return a + b;  // 返回a和b的和
}
\end{lstlisting}
我们可以在其他函数中调用这个函数：
\begin{lstlisting}[language=C++]
int main() {
    int x = 5;
    int y = 10;
    int sum = add(x, y);  // 调用add函数
    cout << "Sum: " << sum << endl;  // 输出结果
    return 0;
}
\end{lstlisting}

函数可以有任意数量的参数，也可以没有参数。函数的返回类型可以是任意类型，包括基本类型、结构体、数组等。如果函数不需要返回值，可以将返回类型设置为\texttt{void}。

我们发现，在上述方法add中定义的变量a和b只能在函数add内部使用，不能在其他地方使用。这是因为函数的作用域是局部的。这说明，变量具有一定的可访问范围，我们把这个可访问范围叫做“作用域”。一般来说，全局变量在任何位置都可以访问，而局部变量只能在它所在的函数或代码块中访问。

\subsection{函数的递归调用}

函数可以调用自己，这种调用方式叫做递归。递归函数通常用于解决一些具有重复结构的问题，例如计算阶乘、斐波那契数列等。
递归函数的基本格式如下：
\begin{lstlisting}[language=C++]
int foo(){
    if (base_case) {
        return base_value;  // 基础情况，直接返回结果
    } else {
        return foo();  // 递归调用
    }
}
\end{lstlisting}

以上代码：在执行第一个foo的时候，会判断是不是基本情况，如果是则直接结束；如果不是，则会调用foo函数本身。这个过程会一直重复，直到满足基本情况为止。某种程度上，递归也是一种循环的形式。

需要注意的是，递归需要一个基础情况来跳出递归，否则则会产生无限递归错误。例如，我们都知道计算阶乘可以使用$n!=n\times(n-1)!$，但是只有这一个公式是不够的，不停地递归下去没有尽头。这时候，我们需要一个基础情况来结束递归：$0!=1$。因此，我们可以写出递归公式：$factorial(n) = n \times factorial(n-1)$，其中$factorial(0) = 1$。然后，我们就可以用程序语言来描述这个数学语言：
\begin{lstlisting}[language=C++]
int factorial(int n) {
    if (n == 0) {
        return 1;  // 基础情况
    } else {
        return n * factorial(n - 1);  // 递归调用
    }
}
\end{lstlisting}

\subsection{函数的传参}

刚刚说到，函数可以接受一些参数。一般情况下，有三个传参方式：值传递、引用传递和指针传递。
\begin{itemize}
  \item 值传递：函数接收参数的副本，修改参数不会影响原变量。基本类型（如int、double等）默认使用值传递。
  \item 引用传递：函数接收参数的引用，修改参数会影响原变量。可以通过在参数类型前加\texttt{\&}来实现。
  \item 指针传递：函数接收参数的指针，修改参数会影响原变量。可以通过在参数类型前加\texttt{*}来实现。
\end{itemize}
例如，我们可以使用引用传递来交换两个整数的值：
\begin{lstlisting}[language=C++]
void swap(int& a, int& b) {
    int temp = a;  // 使用临时变量交换
    a = b;
    b = temp;
}
\end{lstlisting}
使用传指针其实也可以实现同样的功能。但是，传值不能实现同样的功能：传值的本质是复制参数的值到函数内部，因此在函数内部修改参数不会影响原变量。至于引用和指针，则对应的可以理解为剪切，因此能够直接修改原变量的值。

\subsection{小练}

\begin{tcolorbox}[title={小练：判断素数}]
素数在数学中是一个非常重要的概念，它指的是只能被1和它本身整除的自然数。素数在密码学、数据加密等领域有着广泛的应用。一般我们可以使用筛法找到素数：在一系列整数中，先找到最小的素数（2），然后将它的倍数都去掉；然后再找到下一个最小的素数（3），再将它的倍数都去掉；如此反复，直到所有的数都被处理完。请编写一个C++程序，输入一些整数n1，n2，...，然后输出这些整数是不是素数。n的数值在0到1000之间。
\end{tcolorbox}

\subsubsection{解答}

我们阅读题目：在一系列整数中，这个“一系列”整数提示我们可以使用数组来存储这些整数；先找到最小的素数，然后将它的倍数都去掉；然后再找到下一个最小的素数（3），再将它的倍数都去掉；如此反复，直到所有的数都被处理完，这句话提示我们需要使用循环来处理这些整数。

数组的索引天然是自然数集合，因此我们可以使用索引表示整数。我们可以声明一个比较大的数组，来存储从1到n的整数。假设n不超过1000，我们可以声明一个大小为1000的数组来存储这些整数，并将它们全部初始化为0（表示未处理）。对于数组中的每一个元素，我们都可以将他的索引作为整数的值，而元素的值为0说明是素数，1说明不是素数。

然后我们可以使用一个循环来遍历这个数组，找到素数。写成代码就是：
\begin{lstlisting}[language=C++]
bool arr[1000] = {};
// 声明一个数组来存储0和1，并将全部数值初始化为0
arr[0] = 1;  // 0不是素数
arr[1] = 1;  // 1不是素数
for (int i = 2; i < 1000; i++){
    if (arr[i] == 0) {  // 如果这个数是素数
        for (int j = 2; j < 1000; j++) {
            // 将它的倍数都标记为1
            arr[j * i] = 1;
        }
    }
}
\end{lstlisting}

接下来，我们需要输出素数。我们可以直接查询n1，n2，...是否在数组中对应的索引处的值为0，如果是，则说明这个数是素数。写成代码就是：
\begin{lstlisting}[language=C++]
if (arr[i] == 0) {  // 如果这个数是素数
    cout << i << " 是素数" << endl;
}
else {
    cout << i << " 不是素数" << endl;
}
\end{lstlisting}
最后，我们需要将这些代码组合起来，形成一个完整的C++程序。我们可以将输入n的部分放在main函数中，然后调用上面的代码来处理素数。写成代码就是：
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;

bool arr[1000] = {};
// 声明一个数组来存储0和1，并将全部数值初始化为0

int findPrimes() {
    arr[0] = 1;  // 0不是素数
    arr[1] = 1;  // 1不是素数
    for (int i = 2; i < 1000; i++) {
        if (arr[i] == 0) {  // 如果这个数是素数
            for (int j = 2; j * i < n; j++) {
                // 将它的倍数都标记为1
                arr[j * i] = 1;
            }
        }
    }
    return 0;
}

int main() {
    int n;
    cin >> n;  // 输入一个整数n
    findPrimes(1000);  // 调用函数来筛出素数
    while(cin >> i){
        if (arr[i] == 0) {  // 如果这个数是素数
            cout << i << " 是素数" << endl;
        }
        else {
            cout << i << " 不是素数" << endl;
        }
    }
    return 0;  // 返回0，表示程序正常结束
}
\end{lstlisting}
上述代码中的\texttt{while(cin >> i)}可以在无法确定输入的数量的情况下，帮我们自动处理输入。

\begin{tcolorbox}[title=思考]
    不使用筛法的情况下，还有没有其他的算法？
\end{tcolorbox}

\section{C++的高级特性}
C++提供了许多高级特性，可以帮助我们更好地组织代码和数据。

\subsection{命名空间}

命名空间（namespace）是C++中的一个重要特性，它允许我们将代码组织在不同的命名空间中，以避免名称冲突。命名空间的基本格式如下：
\begin{lstlisting}[language=C++]
namespace 命名空间名 {
    // 代码
}
\end{lstlisting}
以上代码的意思是：声明一个名为命名空间名的命名空间，命名空间中的代码可以在这个命名空间内访问。我们可以在不同的命名空间中定义同名的变量、函数等，而不会发生冲突。如果希望在命名空间外调用命名空间内的变量或函数，可以使用\texttt{命名空间名::变量名}或\texttt{命名空间名::函数名}的方式来访问。
例如，我们可以声明一个名为\texttt{MyNamespace}的命名空间：
\begin{lstlisting}[language=C++]
namespace MyNamespace {
    int x = 10;  // 命名空间内的变量
    void foo() {  // 命名空间内的函数
        cout << "Hello from MyNamespace!" << endl;
    }
}

int main() {
    MyNamespace::foo();  // 调用命名空间内的函数
    cout << "x: " << MyNamespace::x << endl;  // 访问命名空间内的变量
    return 0;
}
\end{lstlisting}

在C++中，标准库内大多数函数和方法都定义在\texttt{std}命名空间中，因此我们需要使用\texttt{using namespace std;}来引入标准库的命名空间。这样，我们就可以直接使用标准库中的函数和方法，而不需要每次都加上\texttt{std::}前缀。

\subsection{面向对象编程}

面向对象编程是C++的最重要特性之一。它允许我们将数据和操作数据的函数封装在一起，形成一个对象。对象是一个包含数据和方法的实体，它可以表示现实世界中的事物。同时，面向对象编程还提供了继承、多态等特性，可以帮助我们更好地组织代码和数据。

\subsubsection{类和属性}

类是面向对象编程的基本操作单位。如果不熟悉类，可以把类当成“超级struct”来理解，这里面除了存储数据（C++叫“属性”）以外，还可以顺便把函数（C++叫“方法”）也打包进去。
\begin{lstlisting}[language=C++]
class Point2D{
public:
    static const int DIMENSION = 2;  // 类的常量属性
    static int count;  // 类的静态属性
    int x, y;
    void move(int dx, int dy) {
        x += dx;
        y += dy;
    }
    Point2D(int x = 0, int y = 0) : x(x), y(y)
    {
        count++;
    }  // 构造函数
    ~Point2D() { count--; }  // 析构函数
}
\end{lstlisting}
于是，这下变量和函数成了一家人：
\begin{lstlisting}[language=C++]
Point2D p(1, 2);  // 创建一个Point2D对象p，x=1, y=2
p.move(5, -3);  // 移动点p，它自己知道怎么动！
cout << Point2D::count << endl;  // 输出类的静态属性
\end{lstlisting}
这就是“把数据和对数据的操作绑在一起”——面向对象的核心思想。

在类中，你可以看到我打了一个\texttt{public}，这说明以下属性和方法是公开的，其他所有类或者类外的东西都可以访问它。如果你不打\texttt{public}，那么默认是私有的（private），只有这个类内部可以访问；另一种访问权限是\texttt{protected}，它允许子类访问，但不允许类外的东西访问。（至于什么是子类，请先收起疑问，往下看就懂了）

部分属性前面，你可以发现打了\texttt{static}符号。这说明这个属性是静态的，属于\texttt{类本身}，而不是类的实例（实例指的就是可操作的对象，例如上面的p）。静态属性可以通过类名直接访问，例如\texttt{Point2D::count}。静态属性在所有实例之间共享，因此它们的值是全局的。

\subsubsection{自指}

类可以包含指向自身的指针或引用，这种特性称为自指，用\texttt{this}可以访问当前对象的指针。自指允许我们在类中定义链表、树等数据结构。自指的基本格式如下：
\begin{lstlisting}[language=C++]
class Node {
public:
    int data;  // 节点数据
    Node* next;  // 指向下一个节点的指针
    Node(int value) : data(value), next(nullptr) {}
    Node& GetThis() const {
        return *this;  // 返回当前对象的引用
    }
};
\end{lstlisting}

\subsubsection{构造、析构、拷贝和赋值}

类的构造函数和析构函数是特殊的方法，用于对象的初始化和清理。构造函数在创建对象（也叫实例化）时自动调用，而析构函数在对象销毁时自动调用。构造函数的名称与类名相同，并且既没有返回值也没有返回类型；析构函数的名称是波浪号（\textasciitilde）加上类名，同样既没有返回值也没有返回类型。

构造函数用于初始化对象的属性，析构函数通常用于释放对象占用的资源。\textbf{这是C++的一个重要特性RAII（Resource Acquisition Is Initialization）：资源获取在初始化中获取、在析构中释放。}我们在C++中不需要（也尽可能不要）像C一样手动malloc和free内存，而是通过构造函数和析构函数来自动管理资源，代码更简洁也更安全。

一般情况下，类有着默认的构造和析构函数，它们不含有任何参数，且不执行任何操作。默认的构造函数只会将所有属性初始化为默认值（例如整数为0，布尔值为false等），默认析构函数则按成员逆序调用成员的析构函数。满足这种条件的类也叫做\textbf{平凡且标准布局类}，在旧的实现中也叫POD类型：这种类型没有自定义构造函数、析构函数和拷贝构造函数，它们的行为类似于C语言中的结构体。相应的，在构造函数、析构函数中执行一些其他操作的类则叫做\textbf{非POD类型}，也往往叫做\textbf{复杂类}。一个类可以有多个构造函数（本质上是函数重载），但是只能有一个析构函数。

比如说：
\begin{lstlisting}[language=C++]
class Point2D{
    public:
        int x, y;
        Point2D() {} // 默认构造函数，防止覆盖
        Point2D(int _x, int _y){ // 自己写的构造函数
            x = _x;
            y = _y;
        }
        ~Point2D() {} // 自己写的析构函数
};
\end{lstlisting}

如果我们写了自己的构造和析构函数，那么编译器就不会再隐式地生成任何默认构造函数和析构函数。比方说，上文\texttt{Point2D}类中，我们定义了一个带参数的构造函数和一个析构函数。这样，当我们创建一个\texttt{Point2D}对象时，就会调用这个构造函数来初始化对象的属性（将全局点数量增加1）；当对象被销毁时，就会调用析构函数来干点别的（将全局点数量减1），然后清理资源。

在较新版本的C++标准中，构造函数的属性初始化部分可以使用初始化列表来简单地编写。例如：
\begin{lstlisting}[language=C++]
Point2D(int _x, int _y) : x(_x), y(_y) { ... }
\end{lstlisting}

\begin{tcolorbox}
  需要注意的一点是：在C++中对象的资源管理由构造函数和析构函数自动完成，因此我们不要在构造函数中\texttt{malloc}，也不要在析构函数中\texttt{free}或者\texttt{delete this}。当\texttt{malloc/free}未配对时几乎必然导致内存出毛病，而随便\texttt{delete this}导致的双重释放也是非常危险的。如果一定要用构造函数和析构函数管理资源，应使用 RAII 资源句柄（如 \texttt{std::unique\_ptr}）而非裸指针。    
\end{tcolorbox}

拷贝构造函数\footnote{没有“拷贝函数”这种东西。}是一个特殊的构造函数，它用来复制对象。一般情况下，C++会自动生成一个拷贝构造函数，它会逐个复制对象的属性。但是，如果类中有指针或动态分配的资源，我们需要自定义拷贝构造函数来正确地复制对象。拷贝构造函数的参数是类本身的常量引用，而对方法本身没有什么要求。

一般拷贝分为浅拷贝和深拷贝。浅拷贝只是复制指针的值，而深拷贝则会复制指针指向的内容。对于包含指针的类，我们通常需要实现深拷贝，以避免多个对象的指针指向同一块内存空间，导致资源管理混乱。默认拷贝操作对数据成员逐个复制；如果成员是指针，则仅复制指针值（即所谓“浅拷贝”）。当类拥有动态资源时，通常需要自定义深拷贝逻辑。

拷贝赋值运算符是一个特殊的运算符，用于将一个对象的值赋给另一个对象。它的基本格式如下，而下面这一段代码也展示了深拷贝操作中常见的“先复制、后交换”写法：
\begin{lstlisting}[language=C++]
class Foo {
    int* data;
public:
    Foo(const Foo& rhs) : data(new int[*rhs.data]) {} // 构造函数，深拷贝
    Foo& operator=(Foo rhs) {      // 按值接收，已拷贝/移动
        swap(*this, rhs);          // 交换资源
        return *this;
    }
    friend void swap(Foo& a, Foo& b) noexcept { std::swap(a.data, b.data); }
    // noexcept表示这个函数不会抛出异常
};
\end{lstlisting}
由此，我们看到了我们对\texttt{=}进行了重载。这实际上是定义了一个赋值函数，因此也被叫做类的赋值。

\subsubsection{封装}

封装是面向对象编程的一个重要特性，它允许我们将数据和方法封装在一起，形成一个对象。封装的目的是隐藏实现细节，只暴露必要的接口给外部使用。这样可以提高代码的可维护性和可重用性。

比方说：
\begin{lstlisting}[language=C++]
class BankAccount {
private:
    int balance;  // 私有属性，外部无法直接访问
public:
    BankAccount(int initialBalance) : balance(initialBalance) {}
    void deposit(int amount) {  // 公共方法，允许外部调用
        if (amount > 0) {
            balance += amount;  // 增加余额
        }
    }
    void withdraw(int amount) {  // 公共方法，允许外部调用
        if (amount > 0 && amount <= balance) {
            balance -= amount;  // 减少余额
        }
    }
    int getBalance() const {  // 公共方法，允许外部查询余额
        return balance;  // 返回余额
    }
};
\end{lstlisting}
这样可以阻止外部直接修改余额，只能通过存款和取款方法来操作余额。问我为什么余额用int而不是double或者float的，建议重读Mini ICS。

\begin{tcolorbox}
  在C\#中，封装有一对非常优雅的名词：Getter和Setter。Getter是获取属性值的方法，Setter是设置属性值的方法，同样是上述的代码我们在C\#中可以写成\texttt{public int Balance \{ get; private set; \}}，意思是只有类内可以设置这个属性的值，而类内外可以获取这个属性的值。这样就实现了封装，同时又不失优雅。C++中没有这个优雅的语法，因此我们只能像上述代码中手动实现getter。    
\end{tcolorbox}

\subsubsection{继承}

继承是面向对象编程的一个重要特性，它允许我们创建一个新的类（子类），它继承了另一个类（父类）的属性和方法。子类可以添加自己的属性和方法，也可以重写父类的方法。基类中被重写的方法应被声明为 virtual，也就是\textbf{虚函数}。重写方法时建议加 override 关键字。

继承的基本格式如下：
\begin{lstlisting}[language=C++]
class Shape { public: virtual double area() = 0; };
class Circle : public Shape { ... };
\end{lstlisting}
以上代码的意思是：声明一个名为Shape的类，它有一个纯虚函数area()，表示这个类是一个抽象类。然后声明一个名为Circle的类，它继承了Shape类，并实现了area()方法。

除了重写父类已有的方法，我们也可以在子类中新增一些父类没有的属性和方法。例如：
\begin{lstlisting}[language=C++]
class Circle : public Shape {
private:
    double radius;  // 圆的半径
public:
    Circle(double r) : radius(r) {}  // 构造函数
    double area() override {  // 重写父类的area()方法
        return M_PI * radius * radius;  // 计算圆的面积
    }
    double circumference() {  // 新增方法，计算圆的周长
        return 2 * M_PI * radius;  // 计算圆的周长
    }
};
\end{lstlisting}

现在只剩下“子类的构造函数怎么写”这个问题了。在C++的继承中，子类的构造函数需要调用父类的构造函数来初始化父类的属性。当\textbf{父类有公共的默认构造函数（无参）}，且\textbf{子类没有需要手动初始化的属性}时，子类的构造函数可以不写，编译器会自动生成一个公共且无参的默认构造函数，并调用父类的默认构造函数来初始化父类的属性。只要不满足以上情况，就必须要显式的提供子类的至少一个构造函数。
\begin{lstlisting}[language=C++]
class Base {
public:
    Base(int value) {
        cout << "Base constructor with value: " << value << endl; 
    }  // 带参数的构造函数
    Base(int v1, int v2) { 
        cout << "Base constructor with values: " << v1 << ", " << v2 << endl; 
    }  // 另一个带参数的构造函数
    Base() { 
        cout << "Base default constructor" << endl; 
    }  // 默认构造函数
};
class Derived : public Base {
public:
    Derived(int value) : Base(value) {
        cout << "Derived constructor with data: " << value << endl;
    }  // 子类的构造函数，调用父类的带参数构造函数
    Derived(int v1, int v2) : Base(v1, v2) {
        cout << "Derived constructor with data: " << value << endl;
    }  // 另一个子类的构造函数，调用父类的另一个带参数构造函数
    Derived() : Base() {
        cout << "Derived default constructor" << endl;
    }  // 子类的默认构造函数，调用父类的默认构造函数
};
\end{lstlisting}

C++11以上的标准中，如果子类只是想照抄父类的所有构造函数而不需要写自己的，可以使用\texttt{using}关键字来简化代码：
\begin{lstlisting}[language=C++]
class Derived : public Base {
public:
    using Base::Base;  // 直接继承父类的所有构造函数
};
\end{lstlisting}

需要注意的是，以下两种代码是不过编译的：
\begin{lstlisting}[language=C++]
    class Base;
    class Derived : public Base { ... };  // 错误，Base类未定义
\end{lstlisting}
\begin{lstlisting}[language=C++]
    class Base { ... };
    class Derived : public Base; // 错误，子类的定义必须紧跟类体
\end{lstlisting}
在上述代码中，一开始我们声明出了一个类\texttt{Base}，但是并未定义它。这样的类是“不完整的”，C++规定不能继承一个不完整的类。另一方面，即使预先定义了基类，但是在继承的时候没有跟出定义也是不允许的。

在实际操作中，子类一般属于父类的一个特例，或者更简单地说\textbf{子类是父类}。例如，我们要创建一个“大舅”类和一个“二舅”类，一个非常差的设计是让“二舅”继承自“大舅”，因为二舅并不是大舅的一个特例（或者说二舅不是大舅），反过来也一样。一个好的设计是让这两个类都继承自一个“舅舅”类（他大舅他二舅都是他舅），这样就可以避免这种问题。

\subsubsection{多态}

多态指的是同一个方法在不同的对象上有不同的表现。多态是通过继承和虚函数实现的。当我们调用一个虚函数时，实际调用的是子类中重写的方法，而不是父类中的方法。这种特性使得我们可以使用父类指针或引用来调用子类的方法。

以继承中涉及到的Shape和Circle类为例：
\begin{lstlisting}[language=C++]
Shape* shape = new Circle();  // 创建一个Circle对象，并将其赋值给Shape指针
shape->area();  // 调用Circle类的area()方法
\end{lstlisting}
上述代码中会自动调用Circle类的area()方法，而不是Shape类的area()方法。这就是多态的体现：不用去关心具体的对象类型，省去了switch语句的麻烦。

\subsubsection{友元函数}

我们已经知道，对于一个类的属性和方法，有的是私有的、有的是公共的；从类外无法访问类的私有属性和方法。但是友元函数是一个例外，它可以访问类的私有属性和方法。友元函数的声明方式非常简单，只需要在函数前面加上\texttt{friend}关键字即可。友元函数可以是类的成员函数，也可以是全局函数。但是，友元函数的定义必须在类的外部，而非在类的内部。
\begin{lstlisting}[language=C++]
class MyClass {
private:
    int secret;  // 私有属性
public:
    MyClass(int value) : secret(value) {}  // 构造函数
    friend void revealSecret(const MyClass& obj);  // 声明友元函数
};
void revealSecret(const MyClass& obj) {
    cout << "The secret is: " << obj.secret << endl;  // 访问私有属性
}
\end{lstlisting}

一般情况下我们很少用到友元函数，因为它破坏了类的封装性。然而，在某些情况下，友元函数可以提供更高效的访问方式，尤其是在需要频繁访问类的私有属性时。

\subsection{重载}

重载是C++中的一个重要特性，它允许我们定义多个同名的函数或运算符，但它们的参数列表或返回类型不同。写一个例子就好了：

\begin{lstlisting}[language=C++]
class Tensor{
    int x, y;
public:
    Tensor(int x, int y) : x(x), y(y) {}
    Tensor operator+(const Tensor& other) {  // 重载加法运算符
        return Tensor(x + other.x, y + other.y);
    }
}
Tensor t1(1, 2);
Tensor t2(3, 4);
Tensor t3 = t1 + t2;  // 调用重载的加法运算符
cout << t3.x << ", " << t3.y << endl;  // 输出结果
\end{lstlisting}
以上代码就是重载的一个鲜活实例。我们重载了加法运算符，这使得我们能够对Tensor类的对象进行加法运算。合适的重载可以使代码更简洁、更易读。

除了重载运算符，还可以重载流运算符来实现自定义输入输出，重载函数实现对不同参数的处理等。重载的关键是参数列表的不同，返回类型可以相同或不同。

\subsection{模板}

模板也是一个很重要的特性，它允许我们编写通用的代码，可以处理不同类型的数据。模板可以分为函数模板和类模板。

比方说我们想写一个加法：
\begin{lstlisting}[language=C++]
template <typename T>
T add(T a, T b) {
    return a + b;  // 返回a和b的和
}
int main() {
    int x = 5, y = 10;
    cout << add(x, y) << endl;  // 调用add函数，输出15
    double a = 3.14, b = 2.71;
    cout << add(a, b) << endl;  // 调用add函数，输出5.85
    return 0;
}
\end{lstlisting}
这个函数就可以对任何类型的数据进行加法操作，只要这个类型支持加法运算符。对于不支持加法运算符的类型，编译器会报错（但是我们可以为这些类型重载加法运算符）。

类模板的语法类似，只不过是定义一个类而不是一个函数：
\begin{lstlisting}[language=C++]
template <typename T>
class Box {
public:
    T value;  // 存储一个值
    Box(T v) : value(v) {}  // 构造函数
    T getValue() const { return value; }  // 获取值的方法
};
Box<int> intBox(42);  // 创建一个存储整数的Box对象
Box<double> doubleBox(3.14);  // 创建一个存储双精度浮点数的Box对象
\end{lstlisting}
使用模板可以显著降低代码量，提高代码的可重用性。

\subsection{类型推断}

类型推断是C++11引入的一个特性，它允许编译器根据变量的初始值自动推断变量的类型。使用类型推断可以使代码更简洁、更易读。
类型推断的基本语法是使用\texttt{auto}关键字：
\begin{lstlisting}[language=C++]
auto x = 5;  // 编译器推断x的类型为int
auto y = 3.14;  // 编译器推断y的类型为double
auto str = "Hello, World!";  // 编译器推断str的类型为const char*
\end{lstlisting}
以上代码中，编译器会根据初始值自动推断变量的类型。但是我们并不推荐在定义简单类型变量（如\texttt{int}）的时候使用类型推断，因为这会使得代码的可读性降低，尤其是当变量的类型不明显时。我们只推荐在\textbf{变量的类型非常确定}且\textbf{类型的名称非常冗长}的情况下使用类型推断，例如在循环中使用迭代器时。关于迭代器，请参考后面的章节。

\subsection{类型别名}

类型别名是C就有的一个特性，但是C++11对它进行了扩展。类型别名允许我们为现有的类型创建一个新的名称，使得代码更易读。

C++中可以使用\texttt{using}关键字来定义类型别名。
\begin{lstlisting}[language=C++]
using ll = long long;  // 定义一个长整型的别名
using IntVector = std::vector<int>;  // 定义一个整型向量的别名
IntVector v = {1, 2, 3};  // 使用别名创建一个整型向量
\end{lstlisting}

如果使用C风格的语法，则是：
\begin{lstlisting}[language=C++]
typedef long long ll;  // 定义一个长整型的别名
typedef std::vector<int> IntVector;  // 定义一个整型向量的别名
IntVector v = {1, 2, 3};  // 使用别名创建一个整型向量
\end{lstlisting}

using和typedef几乎没有什么区别，只不过using的语法更加符合直觉（用这个作为这个的别名），类似于声明变量；而typedef则更像是定义一个宏（虽然实际上不是），阅读方向是反直觉的。

using的另一个独特之处是可以用于模板类型的别名：
\begin{lstlisting}[language=C++]
template <typename T>
using Matrix = std::vector<std::vector<T>>;  // 定义一个二维向量的别名
Matrix<int> m = {{1, 2}, {3, 4}};  // 使用别名创建一个二维向量
Matrix<double> dm = {{1.1, 2.2}, {3.3, 4.4}};  // 使用别名创建一个二维向量
\end{lstlisting}
typedef就无法应用于模板类型别名。因此，在C++中，我们推荐使用using来定义类型别名。

\subsection{类型强转}

有时候，在编程中我们需要将一个类型转化成另一个类型，以满足特定的需求。

C语言就有类型强转的功能：
\begin{lstlisting}[language=C++]
    float f = 3.14;
    int i = (int)f;  // 将float类型强制转换为int
    // 也可以写成 int i = int(f);

    printf("i: %d\n", i);  // 输出结果，结果是3
\end{lstlisting}
在变量前面加上括号和目标类型，就可以将变量强制转换为目标类型。

在C++中，类型强转被拆成了四个方式（四大金刚）：
\begin{itemize}
  \item \texttt{static\_cast}：\textbf{编译期安全的强转}，包括数值提升/截断，枚举/整型，子类指针转父类指针、void*转型等。它是最常用的类型转换方式，适用于大多数情况。
  \item \texttt{dynamic\_cast}：\textbf{运行时安全的强转}，几乎仅用于父类指针转子类指针。它会在运行时检查类型安全，如果转换不安全，则返回nullptr。它只能用于有虚函数的类。同时，它是唯一一个在运行时检查强转安全性的转换方式。
  \item \texttt{const\_cast}：\textbf{常变转换}，其他啥都不干。它是唯一一个能去const的转换方式。
  \item \texttt{reinterpret\_cast}：\textbf{按位重解释}，用于int指针互转、void指针互转、无关类指针互转等。它是危险的转换方式，仅在编译期做极弱的检查。它也可以用于转引用，但是如果转不了不会返回空引用\footnote{没有“空引用”这种东西。}而是报错。除非我们知道在干什么，否则不要使用它。
\end{itemize}

举例说明：
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;

double d = 3.14;
int a = static_cast<int>(d);  // 使用static_cast进行数值转换
int a = (int)d;  // C风格的强转，也行

const int c = 42;
int* p = const_cast<int*>(&c);  // 使用const_cast去掉const属性
*p = 100;  // 修改p指向的值，即使C是const的也能改

class Base;
class Derived : public Base; 
// 注意：以上两行代码仅用于说明继承关系，实际过不了编译
Base* b = new Derived();
Derived* d = dynamic_cast<Derived*>(b);  // 使用dynamic_cast将父类指针转为子类
Derived* d = static_cast<Derived*>(b);  // 使用static_cast转型（不安全，但是能过编译）

uintptr_t ptr = reinterpret_cast<uintptr_t>(b);  // 使用reinterpret_cast将指针转换为整数
\end{lstlisting}

那么有些同学可能会问：为什么C++要提供这么多种类型强转？难道C风格的强转不行吗？没错，两种代码实际上都可以用。不过，C风格的强转像个大锤，一口气把任何东西都能砸成目标东西，但是它可不带管安全性的；而C++强转四大金刚分别是四把精确的手术刀，功能单一、语义明确，编译器会帮助你把关；要是危险或者出错了，编译器给你兜底。这样就可以避免很多潜在的错误。

C语言的强转实际上会先尝试常变转换，再尝试数值转换，要是不行就常变数值一起转，还不行就按位重解释。所以说这玩意实际上是四合一，不过也导致它隐形语义极为复杂、易于出错，出错了也不容易搜索定位。

\begin{lstlisting}[language=C++]
const volatile void* v = ...;
int* bad = (int*)v;  // C风格的强转，实际上一口气把const和volatile都去掉了，顺便做了个按位重解释
\end{lstlisting}

所以说，我们非常建议优先使用C++四大强转做显式强转。我们非常不建议在C++中使用旧式风格的强转，除非要做向下兼容等不这么做不行的事情。

\begin{tcolorbox}
  \texttt{volatile}是C/C++中的一个关键字，表示变量可能会被外部因素改变，因此编译器不会对它进行优化。它通常用于多线程编程或硬件寄存器的访问等。这个东西和移位运算符一样，绝大多数人一辈子都不会用到。    
\end{tcolorbox}

\section{STL}

STL（Standard Template Library）是C++的最重要特性，它提供了一组通用的模板类和函数，可以帮助我们更高效地处理数据结构和算法。STL包含了许多常用的数据结构和算法，例如向量（vector）、链表（list）、集合（set）、映射（map）等。

简单地说，STL可以看作是：容器+迭代器+算法。容器把数据结构当变量类型用，迭代器把指针当普通函数用，算法把现成高复杂的轮子当函数用，这玩意能让你用三行代码完成 C 里三十行甚至三百行的工作，还自带内存管理和类型安全。

于是，C++开发就变成了：打开编辑器，敲下头文件，剩下的一律交给STL。

\subsection{容器}

举个最常见的例子：
\begin{lstlisting}[language=C++]
std::vector<int> v = {3,1,4};   // 自动扩容的数组
std::set<int> s = {3,1,4};      // 自动排序的红黑树
std::unordered_map<std::string,int> m;  // 哈希表
\end{lstlisting}
以上代码中，我们使用了STL提供的向量（vector）、集合（set）和映射（unordered\_map）容器。它们都是模板类，可以存储任意类型的数据。使用它们非常容易：头文件即声明、自动管理内存、接口几乎全STL统一。

常见的容器有以下几种：（如果我没记错的话，C++正课会要求全部掌握这些容器，我只能说：祝你好运！）
\begin{itemize}
  \item \texttt{vector}：动态数组（向量），可以自动扩容，支持随机访问。实际上是单一内存连续块。
  \item \texttt{list}：双向链表，支持高效的插入和删除操作，但不支持随机访问。
  \item \texttt{deque}：双端队列，支持在两端高效地插入和删除操作。实际上是分段连续的内存块。
  \item \texttt{set}：集合，存储唯一元素，并自动排序。
  \item \texttt{map}：映射，存储键值对，并根据键自动排序。
  \item \texttt{unordered\_set}：无序集合，存储唯一元素，不自动排序，查询效率高。
  \item \texttt{unordered\_map}：无序映射，存储键值对，不自动排序，查询效率高。
  \item \texttt{stack}：栈，后进先出（LIFO）。
  \item \texttt{queue}：队列，先进先出（FIFO）。
  \item \texttt{priority\_queue}：优先队列，支持按优先级访问元素。
  \item \texttt{array}：固定大小的数组，类似于C风格的数组，但提供了更多的功能。
  \item \texttt{bitset}：位集合，支持高效的位操作。
  \item \texttt{tuple}：元组，可以存储不同类型的多个值。
  \item \texttt{forward\_list}：单向链表，类似于list，但只支持单向遍历。
  \item \texttt{unordered\_multiset}：无序多重集合，存储可以重复的元素，不自动排序。
  \item \texttt{unordered\_multimap}：无序多重映射，存储可以重复的键值对，不自动排序。
\end{itemize}
其实遇事不决的情况下，我们可以按照需求选择容器：
\begin{itemize}
  \item 速查：如果需要快速查找元素（建哈希表），使用\texttt{unordered\_set}或\texttt{unordered\_map}。
  \item 排序：如果需要自动排序，\texttt{set}和\texttt{map}是最好的选择。
  \item 只要最大最小：如果只关心最大值或最小值，使用\texttt{priority\_queue}。
  \item 频繁在中间插入删除：如果需要频繁插入和删除元素，使用\texttt{list}。
  \item 频繁需要两头插入删除：如果只关心两端（尤其是头部）的插入和删除，使用\texttt{deque}。如果能确定用的是栈或队列，使用\texttt{stack}或\texttt{queue}。
  \item 遇事不决：如果不确定用什么容器，使用\texttt{vector}。如果只关心尾部的频繁增删，也可以不用\texttt{deque}，直接用\texttt{vector}。
\end{itemize}

\begin{tcolorbox}[title={容器适配器}]
虽然我把stack和queue也当成容器、实际上在工程上也不怎么区分这东西，但是这里我有必要提及：这两个玩意实际上是容器适配器（container adapter），它们是基于其他容器实现的，提供了栈和队列的接口。一般情况下，默认参数是vector或者deque（因此不必指明），但是你也可以指定其他容器作为底层容器。
\end{tcolorbox}

\begin{tcolorbox}[title={\texttt{std::vector<bool}的特殊性}]
\texttt{std::vector<bool>}和\texttt{std::vector<T>}实现有区别。前者是一个极为特殊的实现，使用位压缩来存储布尔值，因此它不是一个真正的向量，而是一个位集合（bitset）。这使得\texttt{std::vector<bool>}在某些情况下效率更高，但也导致了一些不兼容的问题。例如，\texttt{v[i]}返回的是一个代理对象而不是一个引用；\texttt{auto x = v[i]}返回的是值拷贝而不是常规的数据类型。

我们使用者不关心\texttt{std::vector<bool>}的实现细节，只需要记住以下五件事就行了：
\begin{enumerate}
    \item 不能使用\texttt{auto\& x = v[i]}来获取元素的引用，因为代理对象不能绑定到非常引用；
    \item 不能使用\texttt{\&v[i]}，因为单个位没有地址；
    \item \texttt{std::vector<bool>}的迭代器不是常规迭代器的实现，不是指针；
    \item \texttt{std::vector<bool>}线程不安全；
    \item 排序、查找等算法能用但是缓慢。
\end{enumerate}
\end{tcolorbox}

\subsection{迭代器}

迭代器可以认为是指针的语法糖。一个示例：
\begin{lstlisting}[language=C++]
for(auto it=v.begin(); it!=v.end(); ++it) cout<<*it<<' ';
// 或者直接：
for(auto x : v) cout<<x<<' '; // auto最应该这么用！
\end{lstlisting}

所有容器风格完全一致，完全不必关心装的是什么玩意。一些常见的迭代器和方法：
\begin{itemize}
  \item \texttt{begin()}：返回容器的起始迭代器。
  \item \texttt{end()}：返回容器的结束迭代器。
  \item \texttt{rbegin()}：返回容器的反向起始迭代器。
  \item \texttt{rend()}：返回容器的反向结束迭代器。
  \item \texttt{cbegin()}：返回容器的常量起始迭代器。
  \item \texttt{cend()}：返回容器的常量结束迭代器。
  \item \texttt{next(it)}：返回迭代器it的下一个位置。
  \item \texttt{prev(it)}：返回迭代器it的上一个位置。
  \item \texttt{distance(it1, it2)}：返回迭代器it1和it2之间的距离。
\end{itemize}

迭代器也可以加减，例如\texttt{it+1}表示下一个元素，\texttt{it-1}表示上一个元素。

\subsection{算法}
STL提供了许多常用的算法，可以帮助我们更高效地处理数据，直接拿出来用就行：
\begin{lstlisting}
std::sort(v.begin(), v.end()); // 混合高速排序，结合快排、堆排等算法
std::binary_search(v.begin(), v.end(), 4);  // 二分
std::reverse(v.begin(), v.end());        // 原地翻转
\end{lstlisting}

以上代码中，我们使用了STL提供的排序（sort）、二分查找（binary\_search）和翻转（reverse）算法。STL的算法通常是模板函数，可以处理任意类型的数据。

除此之外，还有一些常用的算法：
\begin{itemize}
  \item \texttt{std::find}：查找元素。
  \item \texttt{std::count}：统计元素出现的次数。
  \item \texttt{std::accumulate}：计算元素的累加和。
  \item \texttt{std::max\_element}：找到最大元素。
  \item \texttt{std::min\_element}：找到最小元素。
  \item \texttt{std::shuffle}：随机打乱元素顺序。
  \item \texttt{std::unique}：去除重复元素。
  \item \texttt{std::merge}：合并两个已排序的范围。
  \item \texttt{std::partition}：对元素进行分区。
  \item \texttt{std::transform}：对元素进行转换。
  \item \texttt{std::for\_each}：对每个元素执行操作。
  \item \texttt{std::set\_union}：计算两个集合的
  \item \texttt{std::set\_intersection}：计算两个集合的交集。
  \item \texttt{std::set\_difference}：计算两个集合的差集。
  \item \texttt{std::set\_symmetric\_difference}：计算两个集合的对称差集。
  \item \texttt{std::nth\_element}：找到第n小的元素。
  \item \texttt{std::lower\_bound}：找到第一个不小于给定值的元素。
  \item \texttt{std::upper\_bound}：找到第一个大于给定值的元素。
\end{itemize}

利用头文件\texttt{<algorithm>}可以使用这些算法。STL的算法通常是模板函数，可以处理任意类型的数据；配合迭代器，算法和容器原地解耦。

\subsection{Lambda表达式}

Lambda表达式是C++11引入的一个特性，它允许我们在代码中定义匿名函数。Lambda表达式可以捕获外部变量，并且可以作为参数传递给其他函数。它的基本语法如下：
\begin{lstlisting}[language=C++]
[捕获列表](参数列表) -> 返回类型 {
    // 函数体
}
\end{lstlisting}
捕获列表用于指定哪些外部变量可以在Lambda表达式中使用，参数列表和返回类型与普通函数类似。Lambda表达式可以直接在代码中定义，不需要单独声明。

例如：
\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3, 4, 5};
    int sum = 0;
    for_each(nums.begin(), nums.end(), [&sum](int n) { sum += n; });  // 使用Lambda表达式计算总和
    cout << "Sum: " << sum << endl;  // 输出结果
    return 0;
}
\end{lstlisting}
以上代码中，我们定义了一个Lambda表达式，该表达式能够捕获外部变量\texttt{sum}，并对\texttt{nums}向量中的每个元素进行求和操作。Lambda表达式可以使代码更简洁。

\subsection{小练}

\begin{tcolorbox}[title={练习：武士的角斗}]
    
假设现在有许多武士要角斗。每个武士都有一个名字和一个体力值，当两个武士相互角斗的时候，体力值较高的武士将会获胜，而体力值较低的武士会耗尽体力，并被淘汰。然而，角斗会消耗武士的体力值，因此每一次角斗后，胜者的体力值会减少等同于败者当前体力值的数值。如果有两个武士体力相等，则他们都会耗尽体力被淘汰。为了保证公平，武士们决定按照体力值从高到低的顺序进行角斗；如果有多个体力值最高的武士，那么他们会在这些武士中选择姓名字典序最靠前的两个武士进行角斗（例如有abc三个武士，则a的姓名字典序最靠前，b次之，c最靠后）。每次角斗后，胜者会继续参与角斗，直到只剩下一个武士或者没有武士剩下为止。

请编写一个程序，模拟武士们的角斗过程，并输出角斗的结果。

输入格式：共n+1行。你会接收到一个数字n，表示武士的数量。接下来n行，每行包含一个武士的名字和体力值（用空格分隔）。保证n不大于一百万，且保证没有两个武士的名字相同。

输出格式：输出最后剩下的武士的名字和体力值。如果没有武士剩下，则输出“None Left”。

\end{tcolorbox}

上述题目看起来难度颇高。这也会是在类似于OJ上出现的常见题目类型之一：不会像前两个题目一样，给你明显的提示和思路（例如“使用筛法”），而是需要你自己思考解决问题的思路。对于这种题目，我们除了需要会语言以外，还要有一定的算法知识。好在这个题目比较简单，算法很直接，重点是怎么实现。

\subsubsection{思路}
我们看到，\texttt{武士们按照体力值从高到低的顺序角斗}，这说明我们非常需要一个数据结构来存储武士们的信息，并且能够不停地获取体力最高的武士（对于体力值次高的武士，我们取两次就行），这让我们想到STL的一个重要成员：优先队列。另一方面，我们发现n的数量级在一百万，这对算法的时间要求较高，而优先队列能够很好地满足这个要求。

那么我们定义一下武士这个数据类型和优先队列：
\begin{lstlisting}[language=C++]
class Warrior {
public:
    string name;  // 武士的名字
    int health;  // 武士的体力值
    Warrior(string n, int h) : name(n), health(h) {}  // 构造函数
    bool operator<(const Warrior& other) const {    // 按照体力值从高到低排序
        if (health != other.health) {
            return health < other.health;  // 体力值较低的武士排在后面
        }
        else {
            return name > other.name;  // 体力值相同的武士按照名字字典序排序
        }
    }
};

priority_queue<Warrior> warriors;  // 定义一个优先队列，存储武士
\end{lstlisting}

接下来，处理读取逻辑：
\begin{lstlisting}[language=C++]
int n;
cin >> n;  // 读取武士数量
for (int i = 0; i < n; ++i) {
    string name;
    int health;
    cin >> name >> health;  // 读取武士的名字和体力值
    warriors.push(Warrior(name, health));  // 将武士加入优先队列
}
\end{lstlisting}

再下一步就是处理角斗的逻辑了。由于优先队列会自动处理上述武士的排序问题，我们只需要不断地从优先队列中取出两个武士进行角斗即可：
\begin{lstlisting}[language=C++]
while(warriors.size() > 1) {  // 当优先队列中还有多个武士时
    Warrior w1 = warriors.top();  // 取出体力值最高的武士
    warriors.pop();  // 弹出这个武士
    Warrior w2 = warriors.top();  // 取出体力值第二高的武士
    warriors.pop();  // 弹出这个武士

    if (w1.health == w2.head) {
        continue;  // 体力相等时，同归于尽，不用放回去了
    } else {
        w1.health -= w2.health;  // 体力不等时胜者体力值减少
        warriors.push(w1);  // 将胜者重新加入优先队列
    }
}
\end{lstlisting}

最后，处理输出：
\begin{lstlisting}[language=C++]
if (warriors.empty()) {
    cout << "None Left" << endl;  // 如果没有武士剩下，输出“None Left”
} else {
    Warrior last = warriors.top();  // 取出最后剩下的武士
    cout << last.name << " " << last.health << endl;  // 输出武士的名字和体力值
}
return 0;
\end{lstlisting}

当然，我们肯定不能把这些代码直接交上去，我们需要把它们拼接在一起，成为一个可以执行的程序。

\begin{tcolorbox}[title=练习]
    请将上述代码拼接在一起，完成一个完整的C++程序，并在本地编译运行。
\end{tcolorbox}

\begin{tcolorbox}[title=思考]
    请试着使用set、map、vector等其他容器来重新实现上述题目，比较数据量较大时的性能差异。
\end{tcolorbox}

部分同学可能会想：为什么我要用优先队列，而不是用set、map、vector等其他容器？这个问题问得很好。

我们先来解释“优先队列为什么行”的问题。优先队列是一个特殊的容器，它使用二叉堆实现，速度很快，且我们仅考虑“每次只关心全局最大值”的问题。在上述题目中，我们实际上只将两件事反复循环：把人放进去，把最该打架的两个人拿出来，这两件事恰好符合优先队列的特性。优先队列插入弹出的时间复杂度是$O(\log n)$\footnote{对于不熟悉算法分析的同学们，以上表示可以通俗地理解为：问题规模是n与问题规模是1的时候相比，执行时间最坏情况下大概变为大O里面的函数倍。}，且获取最大值的时间复杂度是$O(1)$，因此上述问题使用优先队列的时间复杂度是$O(n \log n)$，空间复杂度是$O(n)$，非常高效。

而对于set、map等容器，它们是用红黑树实现的，天然有序：简单地说，无论如何它们都会把所有元素排好（而优先队列并不会把所有元素排好，它只会把最大值放在最前面！）。上述问题中，每一次打架都会改变武士的体力值，这就意味着每次打架后都需要重新排序；为了保持有序，必须先删除、再插入，这个操作本身是两个$O(\log n)$的操作。而在更极端的情况下，加入胜者的体力值极低，它可能从队列首一直沉到队列尾，而set们仍然保留这个没什么竞争力的数据——这意味着后面每一次取“当前最大值”时，都会把这条记录再比较一遍，白白浪费$n log n $的时间！上述问题中，我们知道n是百万级别的，这种反复比较的额外开销总归是需要让复杂度爆炸的，或者说$O(n^2 \log n)$的复杂度，慢了一百万倍。

而对于vector而言，每次重新排序则更加直观：一次排序就得$O(n \log n)$，而每次打架后都需要重新排序，这就意味着每次打架后都需要$O(n \log n)$的时间复杂度。这样一来，整个问题的时间复杂度就变成了$O(n^2 \log n)$，显然超时。综上所述，只有保留全局极值但是不必保留元素具体顺序的数据结构才能较好地完成了这个问题，而优先队列正是这样一个数据结构\footnote{这个题其实有更快的手段，例如胜者树、败者树等，它们本质上是二叉堆的工业级优化，时间复杂度都是$O(n \log n)$，但是常数应该会更小。但是它们写起来非常困难，要考虑各种诸如淘汰等的边界情况，且需要相当的算法基础。胜者树/败者树在竞赛或工程里通常服务于多路归并这类需要“反复取最小/最大并立刻替换”的场景；而本题只需要“全局最大”，STL 的堆已经够用而且很简洁，杀鸡焉用牛刀。我们这里就不讲了。}。

以上，就是C++的全部内容了（也不是全部内容，毕竟C++14、C++17等版本有越来越多的新特性，但是能掌握C++11的全部特性就已经不得了了）。C++的语法和特性非常丰富，学习曲线较陡，但一旦掌握，就可以编写高效、可维护的代码。

\end{document}