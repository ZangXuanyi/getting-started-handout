\chapter{C语言入门}

\begin{outline}
C语言（C Programming Language）是一种通用的编程语言，由Dennis Ritchie在20世纪70年代初期开发。它最初是为了编写操作系统而设计的，后来逐渐发展成为一种广泛使用的编程语言。本章将介绍C语言的基本概念、语法和编程技巧，帮助初学者快速入门C语言编程。

本章节奏极快，不要试图一口气吃成胖子。建议读者在阅读本章时，边看边动手实践，编写简单的C程序，以加深对C语言的理解和掌握。建议将所有练习题都动手做一遍。
\end{outline}

\begin{prerequisite}
\begin{itemize}
    \item 在任意操作系统上配置C/C++编程环境；
    \item 使用GCC或其他编译器编译和运行代码；
    \item 使用GDB调试器或VS Code调试器进行调试。
\end{itemize}
\end{prerequisite}

本章默认大家此前没有任何编程基础。

所谓“编程”，就是让计算机按照我们想要的方式工作。计算机本身并不会思考，它只能听从我们的指令去做事。因此，我们需要用一种计算机能够理解的语言来告诉它我们想要它做什么，这种语言就叫做“编程语言”。

C语言是最早的编程语言之一，在上世纪70年代被发明出来。它是一种结构化的、过程式的编程语言，具有高效、灵活和可移植等特点。C语言广泛应用于系统软件开发、嵌入式系统、游戏开发等领域，著名软件如Linux内核、Git、GCC、Vim等简单但强大的软件都是用C语言编写的；Python的官方实现也是C语言（Cpython），很多高性能的Python库（如NumPy、Pandas、sklearn的大部分等）也是用C语言写的。

安装C编译器的方法见第\ref{sec:c-install-on-windows}节，这里不再赘述。我们要写C，首先应该创建一个以 \texttt{.c} 结尾的文本文件，例如 \texttt{hello.c} 。然后，在这个文件中写入C代码，最后使用C编译器将其编译成可执行文件。而对于初学者而言，编译这种脏活累活全部丢给VS Code的C/C++扩展来做就好了。

\section{C语言的基本语法}

\subsection{你的第一个C程序}
\begin{lstlisting}
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
\end{lstlisting}

把这些内容敲到你的C文件中，保存，编译并运行（如果你按照我所推荐的方式安装并配置好了，那么按下 \texttt{F5} 就可以编译并运行了），你就会看到终端上输出了 \texttt{Hello, World!} 。

上述程序就算是一个最简单的C程序了。

第一次写C的时候，记住以下事项：

\begin{enumerate}
  \item 程序有入口；
  \item 先声明，再计算；
  \item 算完告诉外面。
\end{enumerate}

剩下的内容和说话一样，只不过是用C的语法来表达。我们说话的句号在C中是分号。

逐行拆解上述示例代码：
\begin{itemize}
  \item  \texttt{\#include <stdio.h>} ：告诉编译器，我要用输入输出工具。
  \item  \texttt{int main()} ：程序的入口函数，告诉电脑：程序从这里开始执行。 \texttt{int} 表示这个函数返回一个整数值。
  \item  \texttt{printf("Hello, World!\textbackslash n");} ：把东西一股脑全送到屏幕上。 \texttt{\textbackslash n} 表示换行。
  \item  \texttt{return 0;} ：返回0，告诉操作系统：一切OK。除非你知道你在做什么，否则这里不要改成其他数字。本行就是“算完告诉外面”。
\end{itemize}

在C中，有两种代码：一种是以 \texttt{\#} 开头的预处理指令，另一种是常规语句。预处理指令指的是在编译之前进行的一些操作，例如包含头文件、定义宏等，详见\ref{sec:macro}。常规语句则指的是程序的主要逻辑。常规语句应以分号结尾，且在结尾之后应换行（除非写注释）。压行是不好的行为，会影响代码的可读性，尽量自然地换行。

\subsection{变量及其运算}

编程的本质是对数据进行操作，而经过操作的数据可能会变化。对于会变化的数据，我们称之为“变量”。而这些量也有不同的类型，例如“人数”肯定是整数，而“身高”则可能是小数。

在C中，变量要\textbf{先声明，再使用。}声明的方法是：先写类型，再写名字。这个“名字”是我们之后用来使用这个变量的标识符，类似别人提到“张三”就能对应到这个人的头上。这个使用在编程上被叫做\textbf{调用}。

取名有一定的规则：不能用已经用过的名字，这个名字包括C保留的关键字和你自己已经定义过的名字；名字只能包含字母、数字和下划线，不能包括其他符号，且不能以数字开头；名字区分大小写，例如 \texttt{age} 和 \texttt{Age} 是两个不同的名字。

\begin{lstlisting}[language=C]
    int age = 18; // 声明一个整数变量age，并初始化为18
    double pi = 3.14; // 声明一个双精度浮点数变量pi，并初始化为3.14
    char grade = 'A'; // 声明一个字符变量grade，并初始化为'A'

    age = 19; // 把age的值改为19
\end{lstlisting}

这些语言本质上都可以用自然语言解释为：我有个xx叫xx，它的值是xx。例如第一行代码：我有个整数叫age，它的值是18。如果之后我想用age这个变量，就可以直接写 \texttt{age} ，不需要再次声明“我有个整数叫age”了。

上述 \texttt{int} 等四个排在第一个的关键字是变量的类型，分别表示整数、双精度浮点数、字符和布尔类型。在C中，变量类型不能在运行时改变，一旦声明则类型固定，因此C也被归类为“静态类型”语言。

上述声明中的等号和数学中的等号\textbf{不相同}。在这里，等号的意思是“赋值”，指的是让等号左边的值变成等号右边的值。也就是说，等号右边的值会被计算出来，然后存储到等号左边的变量中。

而变量的运算则和数学差不多，比方说
\begin{lstlisting}
    int a = 10;
    int b = 20;
    int c = a + b;
    c = a * 2;
    c += 5;
\end{lstlisting}

第三行中， \texttt{int c = a + b} 的意思是“我要创建一个变量c，把a+b的结果放进去”。可以看到，从这一行以后再提到c，就不需要再写 \texttt{int} 了，因为电脑已经知道c是个什么东西了；就像我们告诉李四“有个人叫张三”，之后再提到张三的时候就不需要再说“有个人叫张三”了。

下一行 \texttt{c = a * 2} 的意思是“我要把a乘以2的结果放到c里面，c以前不管是什么我都不要了”，而再下一行 \texttt{c += 5} 的意思是“我要把c加上5”。在上述代码中，我们发现变量c的值会随着每一行代码的执行而变化，例如第三行代码执行后，c的值变成了30；第四行代码执行后，c的值变成了20；第五行代码执行后，c的值变成了25。所以说c是一个变量。

变量的值也可以在声明时不确定（初始化），例如 \texttt{int a;} 这样也是可以的。如果在声明的时候不初始化局部变量的值，那么这个变量的初始值将会是一个\textbf{未定义行为}，这个值取决于内存中该位置之前存储的内容。我们不能依赖于这个，因此最好在声明变量的时候就给它赋初始值，例如 \texttt{int a = 0;} 。对于全局变量，如果不初始化，编译器会自动将其0初始化。

让我们看看常见的运算符：
\begin{itemize}
  \item 四则运算： \texttt{+} （加）、 \texttt{-} （减）、 \texttt{*} （乘）、 \texttt{/} （除）。注意，除法运算中，如果两个整数相除，结果仍然是整数，余数会被舍弃。
  \item 取模： \texttt{\%} ，表示取余数。例如 \texttt{5 \% 2} 的结果是1，因为5除以2的余数是1。
  \item 自增和自减： \texttt{++} （自增）和 \texttt{--} （自减）。例如， \texttt{a++} 表示将a的值加1， \texttt{b--} 表示将b的值减1。
\end{itemize}
不要过分纠结 \texttt{i++} 和 \texttt{++i} 的区别，初学者完全可以认为这两个和 \texttt{i += 1} 没有区别。

\begin{caution}
  尽量单独使用 \texttt{++} 和 \texttt{--} ，不要把它们和其他运算混在一起使用，更不要在同一个表达式中对同一个变量使用多次 \texttt{++} 或 \texttt{--} 。例如， \texttt{a = b++} 虽然不推荐但还勉强可以，但是 \texttt{a = b++ + b++} 和 \texttt{i = i++} 都是未定义行为。一个饱受诟病的题目“ \texttt{i = 3, i++ + i++ = ?} ”答：这个题目是错误的，至少是不良定义的。不同的编译器对上述代码的处理方式不同。

  笔者个人从工程的眼光上看来，非常不建议弄出 \texttt{a = b++} 这类的代码，尽管这类代码在竞赛中会让很多OIer感到Tricky，但是在工程中会让人无比恼火。如果想先用b的值再加1，可以写成 \texttt{a = b; b++;} ；如果想先加1再用b的值，可以写成 \texttt{b++; a = b;} 。上述写法一般只有非常约定俗成的场合才会使用，例如 \texttt{while(T--)} 或者 \texttt{stk[++top]=x} ——不过即使是我，也更习惯于写成\lstinline[language=C++]|for(;T>0;T--)| 和 \lstinline[language=C++]|stack<int> stk; stk.push(x);|。
\end{caution}

\subsection{注释}

注释是代码中的说明文字。它们会被编译器忽略，因此注释完全是给编写者和阅读者看的。

在C中，注释有两种方法来写：
\begin{itemize}
  \item 单行注释：使用 \texttt{//} ，例如 \texttt{// 这是一个单行注释} 。注释符号后面的内容会被编译器忽略，直到行尾为止。
  \item 多行注释：使用 \texttt{/* ... */} ，例如 \texttt{/* 这是一个多行注释 */} 。两个注释符号之间的内容会被编译器忽略，可以跨越多行。
\end{itemize}

在阻止部分代码执行的时候，我们一般不习惯于直接删除这些代码，而是使用注释。这样做的好处是可以留痕，便于以后的恢复（解注释）；这就是程序员们常说的“注释掉”代码。在VS Code等编辑器中，常用的一键注释是 \texttt{Ctrl + /} ，它会自动将光标所在的一行或多行代码注释掉。

\subsection{输入、输出及其格式化}

输入和输出是程序与外界进行交互的方式。在C中，常用的输入输出函数有 \texttt{printf} 和 \texttt{scanf} 。这两个函数都定义在 \texttt{stdio.h} 头文件中，因此在使用它们之前需要包含该头文件。

\texttt{printf} 用于输出数据到屏幕上，其基本语法如下：
\begin{lstlisting}[language=C]
    printf("格式字符串", 参数1, 参数2, ...);
\end{lstlisting}

而 \texttt{scanf} 用于从键盘读取输入，其基本语法如下：
\begin{lstlisting}[language=C]
    scanf("格式字符串", &变量1, &变量2, ...);
\end{lstlisting}
上述输入中的\&符号不能省略，也就是需要写成 \texttt{\&a} 的形式。

那这个“格式字符串”是什么东西呢？它是一个字符串，其中包含了文本和格式说明符。格式说明符用于指定要输出或输入的数据类型和格式。常见的格式说明符有：
\begin{itemize}
  \item \texttt{\%d} ：表示整数类型。
  \item \texttt{\%f} ：表示浮点数类型。
  \item \texttt{\%c} ：表示字符类型。
  \item \texttt{\%s} ：表示字符串类型。
\end{itemize}

例如，下面的代码演示了如何使用 \texttt{printf} 和 \texttt{scanf} 进行输入输出：
\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int age;
    printf("请输入你的年龄：");
    scanf("%d", &age); // 这里的输入是1个整数
    printf("你输入的年龄是：%d\n", age); // 这里你看到的的输出是：“你输入的年龄是：xx”，xx是age的值
    return 0;
}
\end{lstlisting}

在字符串中，除了上述格式说明符，还可以有控制字符，也就是类似于上文\texttt{\textbackslash n} 这样的东西。上述代码中的 \texttt{\textbackslash} 是“转义符号”，表示后面的字符有特殊含义，而不是其本身的含义。
常见的控制字符有：
\begin{itemize}
  \item \texttt{\textbackslash n} ：换行符。
  \item \texttt{\textbackslash t} ：制表符（Tab）。
  \item \texttt{\textbackslash r} ：回车符。
  \item \texttt{\textbackslash "} ：双引号字符。
  \item \texttt{\textbackslash '} ：单引号字符。
  \item \texttt{\textbackslash \textbackslash} ：反斜杠字符。
  \item \texttt{\%} ：百分号字符。
  \item \texttt{\textbackslash 0} ：字符串结束符。
\end{itemize}

\begin{exercise}[加减运算]
    写一个程序，接受两个整数输入，然后输出它们的和、差。

    \textbf{程序输入}：两个整数a和b，用空格分割。
    
    \textbf{程序输出}：两行，第一行输出$a+b$，第二行输出$a-b$。
\end{exercise}

\begin{answer}
    由于这是第一个题，我们就给出一个参考答案吧。这个题目的答案是显然的，但需要让同学们知道这种题目应该以一种什么形式去写。

    在OJ等平台上，我们一般需要提交一个完整的程序。

    首先，我们要处理问题的核心逻辑：加法和减法。
    \begin{lstlisting}[language=C]
        int a = 0;
        int b = 0;
        
        int sum = a + b; // 计算和
        int diff = a - b; // 计算差
    \end{lstlisting}
    下一步，处理输入输出：
    \begin{lstlisting}[language=C]
        scanf("%d %d", &a, &b); // 读取输入
        printf("%d\n", sum); // 输出和
        printf("%d\n", diff); // 输出差
    \end{lstlisting}
    我们应该把这些代码按照一个正确的顺序组织起来，并且放在一个完整的C程序框架内：
    \begin{lstlisting}[language=C]
    #include <stdio.h>

    int main() {
        int a = 0;
        int b = 0;
        
        scanf("%d %d", &a, &b); // 读取输入
        
        int sum = a + b; // 计算和
        int diff = a - b; // 计算差
        
        printf("%d\n", sum); // 输出和
        printf("%d\n", diff); // 输出差
        
        return 0;
    }
    \end{lstlisting}
    这样，我们就完成了这个练习题的解答。

    OJ等自动评测平台会根据题目的输出格式来验证程序的正确性，因此我们必须严格按照题目要求来编写程序，不要输出其他内容，例如“请输入两个整数：”之类的提示语句，这样会导致判错。而在实际生活中，我们可以添加这些提示语句来提高程序的用户体验。
\end{answer}

\subsection{常变量}

常变量（也叫不可变变量、只读变量）是指在程序运行过程中其值不能被修改的变量。在C中，可以使用 \texttt{const} 关键字来声明常变量。例如：
\begin{lstlisting}[language=C]
    const int MAX_VALUE = 100;
    // MAX_VALUE = 200; // 这行代码编译不通过，因此要注释掉
\end{lstlisting}

也就是在常规的声明前面加上 \texttt{const} 关键字。上述代码的意思是：我要创建一个常变量MAX\_VALUE，它的值是100。

我们发现，任何对常变量的修改操作都会使得编译不通过。因此，常变量的值一旦确定就不会在程序运行时改变。常变量的名字通常使用全部大写字母来表示，以便于和变量区分。

\subsection{条件判断}

有时候我们想要设计一个网站，给不同的人显示不同的内容。这个时候，我们就需要用到条件判断。条件判断可以让程序根据不同的条件执行不同的代码块。在C中，常用的条件判断语句有 \texttt{if} 语句和 \texttt{switch} 语句，以及三元运算符。

\subsubsection{条件表达式}

一个条件表达式，最简单的情况肯定是“真”或“假”。C语言规定：true等价于1，false等价于0；但非0的数值还是什么别的非空的东西全部视作true。因此， \texttt{if (1)} 和 \texttt{if (-42)} 甚至 \texttt{if (3.14)} 和 \texttt{if ("hello")}都肯定会执行，而 \texttt{if (0)} 和 \texttt{if ("")} 则肯定不会执行。

但是实际上情况肯定没这么简单，所以需要用比较运算符和逻辑运算符来构造更复杂的条件表达式。常见的比较运算符有：
\begin{itemize}
  \item \texttt{==} ：等于。
  \item \texttt{!=} ：不等于。
  \item \texttt{>} ：大于。
  \item \texttt{<} ：小于。
  \item \texttt{>=} ：大于等于。
  \item \texttt{<=} ：小于等于。
  \item \texttt{\&\&} ：逻辑与（AND）：前后两个条件都为真时，结果才为真。
  \item \texttt{||} ：逻辑或（OR）：前后两个条件有一个为真时，结果就为真。
  \item \texttt{!} ：逻辑非（NOT）：反转后面条件的真假。
  \item \texttt{()} ：括号，用于改变运算优先级。
\end{itemize}

也就是说：\texttt{3+2==5} 是true， \texttt{3+2!=5} 是false， \texttt{3 > 2} 和 \texttt{3 >= 2} 也都是true。而 \texttt{(3 > 2) \&\& (2 > 1)} 是true， \texttt{(3 > 2) || (2 < 1)} 也是true，而 \texttt{!(3 > 2)} 则是false。于是，借助这些比较运算符和逻辑运算符，我们就可以构造出复杂的条件表达式了。

\begin{tip}
  在C++中，不能使用类似 \texttt{1 <= x <= 2} 这样的连续记号来表示区间。正确的写法是 \texttt{(1 <= x) \&\& (x <= 2)} ，即把每个比较都单独写出来，然后用逻辑与运算符连接起来。
\end{tip}

在C++中，与或非运算符是有一定的运算顺序的。一般情况下，逻辑非运算符的优先级最高，其次是逻辑与运算符，最后是逻辑或运算符。不过笔者非常不建议同学们背诵这个顺序；实际在工程上不仅不建议大量嵌套使用这些运算符，而且遇事不决可以加括号——括号可比记运算顺序靠谱得多了！

\subsubsection{if语句}

\texttt{if} 语句的基本语法如下：
\begin{lstlisting}
if (cond1){
    // codes...
}
else if (cond2){
    // codes...
}
else {
    // codes...
}
\end{lstlisting}
上述\texttt{cond1} 和 \texttt{cond2} 是条件表达式，它们的结果是布尔值（真或假）。如果 \texttt{cond1} 为真，则执行第一个代码块；否则，如果 \texttt{cond2} 为真，则执行第二个代码块；否则，执行最后一个代码块。在实际操作中，可以没有任何\texttt{else if} 或 \texttt{else} 分支。

例子：
\begin{lstlisting}[language=C]
if (age < 18) {
    cout << "未成年";
}
else if (age < 60) {
    cout << "成年人";
}
else {
    cout << "老年人";
}
\end{lstlisting}
一目了然，不言而喻。这个age变量可以是前面提到的许多类型。

\subsubsection{switch语句}

\texttt{switch} 语句的基本语法如下：

\begin{lstlisting}
switch (expression) {
    case value1:
        // codes...
        break;
    case value2:
        // codes...
        break;
    ...
    default:
        // codes...
}
\end{lstlisting}
上述 \texttt{expression} 是一个表达式，其结果将与各个 \texttt{case} 后面的值进行比较。如果结果与某个 \texttt{case} 后面的值相等，则执行对应的代码块，直到遇到 \texttt{break} 语句为止。如果没有任何 \texttt{case} 匹配，则执行 \texttt{default} 代码块（如果有的话）。注意， \texttt{break} 语句用于跳出 \texttt{switch} 语句，否则程序会继续执行后续的代码块。在实际操作中，也可以没有 \texttt{default} 分支。

例子：
\begin{lstlisting}[language=C]
switch (day) {
    case 1:
        cout << "星期一";
        break;
    case 2:
        cout << "星期二";
        break;
    case 3:
        cout << "星期三";
        break;
    // ......其他的，基本一个写法
}
\end{lstlisting}
这也一目了然不言而喻了。

\subsubsection{三元表达式}

三元表达式也是一种条件表达式，只不过它可以在一行代码中完成条件判断和结果返回，因此显得更简洁。它通常用于简单的条件判断和赋值操作。它的基本格式如下：
\begin{lstlisting}[language=C]
条件 ? 真值 : 假值
\end{lstlisting}
以上代码的意思是：如果条件为真，整个表达式的值和真值一样；否则，整个表达式的值和假值一样。它非常适合简单的条件判断和赋值操作，但是我们不建议在复杂的条件判断中使用它或者者嵌套使用它，这样会大大降低代码的可读性。

比方说，我们可以用它来判断一个数是奇数还是偶数：
\begin{lstlisting}[language=C++]
int n = 5;
string result = (n % 2 == 0) ? "偶数" : "奇数";
\end{lstlisting}
以上代码的意思是：如果n是偶数，就把字符串“偶数”赋值给result；否则把字符串“奇数”赋值给result。

如果使用if语句来实现同样的功能，可以写成：
\begin{lstlisting}[language=C]
int n = 5;
string result;
if (n % 2 == 0) {
    result = "偶数";
} else {
    result = "奇数";
}
\end{lstlisting}

\begin{exercise}[闰年判断]
    写一个程序，接受一个年份输入，然后判断这一年有多少天（365或366）。提示：闰年的判断规则是：四年一闰，百年不闰，四百年再闰。

    \textbf{程序输入}：一个整数year，表示年份。

    \textbf{程序输出}：一个整数，表示该年份的天数（365或366）。
\end{exercise}

\begin{exercise}[天数判断]
    写一个程序，接受一个月份输入，然后输出该月份有多少天。假设输入的月份是1到12之间的整数，且不考虑闰年。

    \textbf{程序输入}：一个整数month，表示月份。

    \textbf{程序输出}：一个整数，表示该月份的天数。
\end{exercise}

\subsection{循环}

循环是一种重复执行某段代码的结构，直到满足某个条件为止。有的同学可能会问：为什么不直接把代码写多几遍就好了？这是因为有时候我们并不知道需要重复多少次，或者需要根据某个条件来决定是否继续循环，因此这时候就需要用到循环结构。

在C中，常用的循环语句有 \texttt{for} 循环、 \texttt{while} 循环和 \texttt{do-while} 循环。

\subsubsection{for循环}

\texttt{for} 循环的基本语法如下：
\begin{lstlisting}
for (初始化; 条件; 更新) {
    // 循环体代码
}
\end{lstlisting}
上述 \texttt{初始化} 用于设置循环变量的初始值， \texttt{条件} 是一个布尔表达式，用于判断是否继续循环， \texttt{更新} 用于更新循环变量的值。循环体代码会在每次循环中执行。例如，下面的代码演示了如何使用 \texttt{for} 循环打印1到10的数字：
\begin{lstlisting}[language=C]
for (int i = 1; i <= 10; i++) {
    printf("%d\n", i);
}
\end{lstlisting}

\subsubsection{while循环}
\texttt{while} 循环的基本语法如下：
\begin{lstlisting}
while (条件) {
    // 循环体代码
}
\end{lstlisting}
上述 \texttt{条件} 是一个布尔表达式，用于判断是否继续循环。循环体代码会在每次循环中执行，直到条件为假为止。例如，下面的代码演示了如何使用 \texttt{while} 循环打印1到10的数字：
\begin{lstlisting}[language=C]
int i = 1;
while (i <= 10) {
    printf("%d\n", i);
    i++;
}
\end{lstlisting}

实际上，while循环可以和for循环互相转换。上面的for循环可以改写成while循环，反之亦然。

\subsubsection{do-while循环}
\texttt{do-while} 循环的基本语法如下：
\begin{lstlisting}
do {
    // 循环体代码
} while (条件);
\end{lstlisting}
上述 \texttt{条件} 是一个布尔表达式，用于判断是否继续循环。循环体代码会先执行一次，然后再判断条件是否为真，如果为真则继续循环，直到条件为假为止。例如，下面的代码演示了如何使用 \texttt{do-while} 循环打印1到10的数字：
\begin{lstlisting}[language=C]
int i = 1;
do {
    printf("%d\n", i);
    i++;
} while (i <= 10);
\end{lstlisting}
可以看出， \texttt{do-while} 循环至少会执行一次循环体代码，而 \texttt{while} 循环则可能一次都不执行。

\subsubsection{循环控制语句}

有些时候，我们希望在循环中跳过某些迭代，或者提前结束循环。为此，C提供了两种循环控制语句： \texttt{break} 和 \texttt{continue} 。

\texttt{break} 可以立刻跳出整个循环，不再执行后续的迭代。例如：
\begin{lstlisting}[language=C]
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        break; // 当i等于5时，跳出循环
    }
    printf("%d\n", i);
}
\end{lstlisting}
这个代码的输出是1到4，后面的数字都不会被打印出来，因为循环已经被提前结束了。

而 \texttt{continue} 则是跳过当前迭代的剩余所有代码，直接进入下一次迭代。例如：
\begin{lstlisting}[language=C]
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        continue; // 当i是偶数时，跳过当前迭代
    }
    printf("%d\n", i);
}
\end{lstlisting}
这个代码的输出是1到10，除了5这个数字，因为当i等于5时，当前迭代被跳过了。

\begin{exercise}[日期差]
    写一个程序，接受两个日期输入，计算两者之间差了多少天。不考虑闰年问题。

    \textbf{程序输入}：四个整数month1、day1、month2、day2，分别表示第一个日期的月份和天数，以及第二个日期的月份和天数。

    \textbf{程序输出}：一个整数，表示两个日期之间的天数差。

    \textbf{提示}：把上一节的“天数判断”题目作为子任务来完成，也就是说可以试着复用这些代码。
\end{exercise}

\subsection{数组}

数组，顾名思义，也就是“一组数据”。这组数据的类型是相同的，可以是整数、浮点数、字符等。数组中的每个数据都有一个索引（下标），用于标识它在数组中的位置。数组的索引从0开始。

例如，下面的代码声明了一个包含5个整数的数组：

\begin{lstlisting}[language=C]
    int numbers[5] = {10, 20, 30, 40, 50};
    // 访问数组元素
    int firstNumber = numbers[0]; // 访问第一个元素，值为10
    int thirdNumber = numbers[2]; // 访问第三个元素，值为30
    int bad = numbers[5]; // 错误，数组越界访问，可能导致段错误或返回不可知的值
    int bad2 = numbers[-1]; // 错误，数组越界访问

    numbers[1] = 25; // 修改第二个元素的值为25
\end{lstlisting}

有的同学可能会问：我为什么不能用
\begin{lstlisting}
    firstNumber = 25;
\end{lstlisting}
来修改 \texttt{numbers[0]} 的值呢？这是因为 \texttt{firstNumber} 和 \texttt{numbers[0]} 是两个不同的变量，前者是一个独立的变量，而后者是数组中的一个元素。上述初始化语句只是将 \texttt{numbers[0]} 的值复制给了 \texttt{firstNumber} ，它们之间没有任何关联。因此，修改 \texttt{firstNumber} 的值不会影响 \texttt{numbers[0]} 的值，反之亦然。

在C中，我们无法直接打印整个数组，而是需要通过循环来逐个打印数组中的元素。例如：
\begin{lstlisting}[language=C]
for (int i = 0; i < 5; i++) {
    printf("%d\n", numbers[i]);
}
\end{lstlisting}

上述代码使用了一个 \texttt{for} 循环来遍历数组 \texttt{numbers} 中的每个元素，并将其打印出来。\texttt{while} 循环也可以实现同样的功能，读者可以自行尝试。

在C语言中，数组的大小必须是一个能够在编译时确定的常量（如字面值）。

\begin{caution}
  变长数组（VLA）是C99标准引入的特性，允许数组的大小在运行时确定，但它在C11中被变为可选特性。容易引起误会的是，GCC 和 Clang++ 编译器提供了包含 VLA 的GNU 扩展语法，并且默认引入这些扩展，因此，VLA （例如 \texttt{int n; int a[n];} ）在这些编译器下可行。反之，如果关闭这些扩展（通过添加  \texttt{--pedantic-errors}  选项）或者非 GNU 兼容的编译器（如 MSVC），则 VLA 不可用。在实际操作中，我们不要去写VLA，它们可能会导致代码在不同编译器下的表现不一致。C中，我们需要使用数组但是长度不确定的时候，可以将数组开得大一些，例如题目有1000个元素，那么就开1000个元素或者稍多元素的数组。
\end{caution}

\begin{exercise}[计算求和]
写一个程序，该程序接受一些非零整数的输入，直到输入0为止，然后输出这些正整数的和。

\textbf{程序输入}：一系列整数，每个整数占一行，最后一个整数为0，表示输入结束。

\textbf{程序输出}：一个整数，表示输入的非零整数的和。

\textbf{思考}：本题用数组和不用数组分别怎么写？哪种方法更好？如果本题改为“计算平均值”，用数组和不用数组分别怎么写？哪种方法更好？
    
\end{exercise}

\subsection{字符串}

C风格的字符串是以字符数组的形式存储的，并以空字符（ \texttt{\textbackslash 0} ）结尾。字符串可以通过字符数组来表示，例如：
\begin{lstlisting}[language=C]
char str[] = "Hello, World!";
\end{lstlisting}
上述代码声明了一个字符数组 \texttt{str} ，并初始化为字符串 "Hello, World!" 。注意，字符串的长度包括了结尾的空字符。

也就是说：
\begin{lstlisting}
    char str[3] = "Hi"; // 字符串"Hi"占用3个字符：'H'、'i'和'\0'
    char str2[2] = "Hi"; // 错误，数组大小不足以存储字符串及其结尾的空字符
\end{lstlisting}

在做题和实际工程中，很容易遗忘C风格字符串的结尾空字符，因此在操作字符串时要特别小心，确保有足够的空间来存储字符串及其结尾的空字符。

\begin{exercise}[字符串长度]
写一个程序，接受一个字符串输入，然后输出该字符串的长度（不包括结尾的空字符）。

\textbf{程序输入}：一个字符串，长度不超过100个字符。

\textbf{程序输出}：一个整数，表示字符串的长度。

\textbf{提示}：可以使用循环来计算字符串的长度，或者使用标准库函数 \texttt{strlen} 。体会标准库函数在实际编程中的便利性。
\end{exercise}

\subsection{结构体}

结构体（ \texttt{struct} ）是一种用户自定义的数据类型，用于将多个相关的数据组合在一起。结构体可以包含不同类型的成员变量，从而形成一个复杂的数据结构。在C中，结构体的定义和使用方法如下：
\begin{lstlisting}[language=C]
// 定义结构体
struct Person {
    char name[50]; // 姓名
    int age;       // 年龄
    double height;  // 身高
};
// 使用结构体
struct Person person1; // 声明一个结构体变量person1
// 访问和修改结构体成员
strcpy(person1.name, "Alice");
person1.age = 25;
person1.height = 165.5;
\end{lstlisting}

容易看出，结构体可以使得代码更加清晰和有组织，尤其是在处理复杂数据时非常有用。

一个更好的写法是使用 \texttt{typedef} 关键字为结构体定义一个别名，这样在声明结构体变量时就不需要再写 \texttt{struct} 了。例如：
\begin{lstlisting}[language=C]
// 定义结构体并使用typedef为其定义别名
typedef struct {
    char name[50]; // 姓名
    int age;       // 年龄
    double height;  // 身高
} Person;
// 使用结构体
Person person1; // 直接使用别名Person来声明结构体变量person1
\end{lstlisting}

\begin{exercise}[学生信息管理]
写一个程序用于管理学生的高考信息（仅包括学号、姓名、分数）。学号从0开始连续编号，姓名不超过20个字符，分数为整数，在0到750之间。

\textbf{程序输入}：首先输入一个整数n，表示学生人数。接下来输入n行，每行包含一个学生的姓名和分数，姓名和分数之间用空格分隔。然后输入一个整数m，表示查询次数。接下来输入m行，每行包含一个学生的学号。

\textbf{程序输出}：m行。每一行用空格分隔输出三个整数，分别对应查询学号的学生的学号、姓名和分数。如果未能查询到，输出“Not Found”。

\textbf{提示}：本题使用结构体、不使用结构体分别怎么写？哪种方法更好？体会结构体在组织复杂数据时的优势。
\end{exercise}

\subsection{联合体}

联合体（ \texttt{union} ）是一种特殊的数据类型，它允许在同一内存位置存储不同类型的数据。联合体的所有成员共享同一块内存，因此在任何时候只能使用其中的一个成员。联合体的定义和使用方法如下：
\begin{lstlisting}[language=C]
union Data
{
    int intValue;      // 整数值
    float floatValue;  // 浮点值
};
// 使用联合体
union Data data; // 声明一个联合体变量data
// 访问和修改联合体成员
data.floatValue = 10.0; // 设置值

printf("浮点值: %f\n", data.floatValue); // 访问浮点值
printf("整数值: %d\n", data.intValue); // 访问整数值（未定义行为）
\end{lstlisting}

在上述代码中，联合体 \texttt{Data} 包含两个成员： \texttt{intValue} 和 \texttt{floatValue} 。当我们设置 \texttt{floatValue} 的值时， \texttt{intValue} 的值会被覆盖，反之亦然。因此，在使用联合体时需要特别小心，确保只访问当前有效的成员。

\subsection{函数、变量的作用域}

函数是程序中的一个独立模块，用于执行特定的任务。函数可以接受输入参数，执行一些操作，并返回一个结果。使用函数可以提高代码的可读性和可维护性。

函数的定义和使用方法如下：
\begin{lstlisting}[language=C]
// 函数定义
返回类型 函数名(参数类型1 参数名1, 参数类型2 参数名2, ...) {
    // 函数体代码
    return 返回值; // 如果返回类型不是void，则需要返回一个值
}
// 函数调用
返回类型 变量名 = 函数名(参数值1, 参数值2, ...);
\end{lstlisting}

写得太乱了，感觉不如一个实例来得清晰明了：
\begin{lstlisting}[language=C]
int add (int a, int b) { // 函数定义
    return a + b; // 返回两个整数的和
}
int sum = add(3, 5); // 函数调用
printf("和是: %d\n", sum); // 输出结果
\end{lstlisting}

上述代码定义了一个名为 \texttt{add} 的函数，它接受两个整数参数，并返回它们的和。然后，我们调用该函数并将结果存储在变量 \texttt{sum} 中，最后打印出结果。

我们一般把上述a和b叫做“形参”（parameter），而把3和5叫做“实参”（argument）。形参是在函数定义时使用的变量名，用于表示函数接受的输入参数；实参是在函数调用时传递给函数的具体值。

我们不可以在一个函数内部定义另一个函数（即不支持嵌套函数）。main函数也是一个函数，只不过它是程序的入口点，因此也不能在main里面定义另一个函数。

我们发现，在定义上述 \texttt{add} 函数时，使用了两个参数 \texttt{a} 和 \texttt{b} 。这两个参数在函数内部是可以使用的，但是在函数外部是无法访问的。这就是变量的作用域（scope）概念：变量的作用域决定了变量可以被访问的范围。C中，变量要么是局部变量，要么是全局变量。局部变量是在函数内部定义的变量，它们只能在函数内部访问；全局变量是在函数外部定义的变量，它们可以在整个程序中访问。

\begin{lstlisting}[language=C]
int globalVar = 10; // 全局变量
void foo(){
    int localVar = 20; // 局部变量
    printf("局部变量: %d\n", localVar); // 可以访问局部变量
    printf("全局变量: %d\n", globalVar); // 可以访问全局变量
}
int main() {
    foo();
    // printf("局部变量: %d\n", localVar); // 错误，无法访问局部变量
    printf("全局变量: %d\n", globalVar); // 可以访问全局变量
    return 0;
}
\end{lstlisting}
在上述代码中， \texttt{globalVar} 是一个全局变量，可以在函数 \texttt{foo} 和 \texttt{main} 中访问。而 \texttt{localVar} 是一个局部变量，只能在函数 \texttt{foo} 中访问，尝试在 \texttt{main} 中访问它会导致编译错误。

\begin{exercise}[日期差加强版]
写一个程序，接受两个日期输入，计算两者之间差了多少天。

\textbf{程序输入}：空格分隔的6个整数year1、month1、day1、year2、month2、day2，分别表示第一个日期的年份、月份和天数，以及第二个日期的年份、月份和天数。

\textbf{程序输出}：一个整数，表示两个日期之间的天数差。

\textbf{提示}：把前面“天数判断”“闰年判断”题目作为子任务来完成，也就是说可以试着复用这些代码。考虑使用函数来组织代码，提高代码的可读性和可维护性。
    
\end{exercise}

\subsection{函数的递归调用}

函数可以调用自己，这种调用方式叫做递归。递归函数通常用于解决一些具有重复结构的问题，例如计算阶乘、斐波那契数列等。
递归函数的基本格式如下：
\begin{lstlisting}[language=C++]
int foo(){
    if (base_case) {
        return base_value;  // 基础情况，直接返回结果
    } else {
        return foo();  // 递归调用
    }
}
\end{lstlisting}

以上代码：在执行第一个foo的时候，会判断是不是基本情况，如果是则直接结束；如果不是，则会调用foo函数本身。这个过程会一直重复，直到满足基本情况为止。某种程度上，递归也是一种循环的形式。

需要注意的是，递归需要一个基础情况来跳出递归，否则则会产生无限递归错误。例如，我们都知道计算阶乘可以使用$n!=n\times(n-1)!$，但是只有这一个公式是不够的，不停地递归下去没有尽头。这时候，我们需要一个基础情况来结束递归：$0!=1$。因此，我们可以写出递归公式：$factorial(n) = n \times factorial(n-1)$，其中$factorial(0) = 1$。然后，我们就可以用程序语言来描述这个数学语言：
\begin{lstlisting}[language=C++]
int factorial(int n) {
    if (n == 0) {
        return 1;  // 基础情况
    } else {
        return n * factorial(n - 1);  // 递归调用
    }
}
\end{lstlisting}

建立递归思维是非常困难的，但也是非常重要的。在实际生活中，很多问题都可以通过“分治-递归”的思路来解决：把大问题分成相似的小问题，解决这些小问题，然后把小问题的解合并成大问题的解。递归函数正是实现这种思路的有力工具。

\begin{exercise}[小明爬楼梯]
    小明在爬楼梯。他一次可以爬1个或2个台阶。假设楼梯有n个台阶，问小明有多少种不同的爬法？

    \textbf{程序输入}：一个整数n，表示楼梯的台阶数。

    \textbf{程序输出}：一个整数，表示小明爬楼梯的不同方法数。

    \textbf{提示}：考虑：假设小明爬到x级台阶时的爬法有$f(x)$种，那么$f(x)$能不能被它前面的某些项表示出来？基础情况又是什么？这个递推关系就是大名鼎鼎的\textbf{状态转移方程}，是很多复杂问题的核心。
\end{exercise}

递归函数虽然很有效，但是开销非常庞大。每次函数调用都会占用一定的内存空间来存储函数的参数、局部变量和返回地址等信息。如果递归层数过深，可能会导致栈溢出错误。在实际操作中，可以有一些手段来避免递归，例如利用数组来存储中间结果等：
\begin{lstlisting}[language=C++]
int facts[100]; // 假设最大计算到99的阶乘
facts[0] = 1; // 基础情况
for (int i = 1; i < 100; i++) {
    facts[i] = i * facts[i - 1]; // 迭代计算
}
\end{lstlisting}
这样就能避免递归调用带来的巨大开销，但其思路本质和递归相似：递归是从问题本身出发，不停地分解成小问题；而迭代则是从基础情况出发，不停地构建成大问题。而迭代递推则是动态规划这类问题的核心思路。

\subsection{类型强转}

类型强转（type casting）是将一种数据类型转换为另一种数据类型的过程，毕竟大家都不想让5除以2得2。

用括号就可以实现类型强转。例如：
\begin{lstlisting}[language=C]
int a = 5;
int b = 2;
double result = (double)a / (double)b; // 强制将a和b转换为double类型
printf("结果是: %f\n", result); // 输出结果
\end{lstlisting}
在上述代码中，我们将整数变量 \texttt{a} 和 \texttt{b} 强制转换为 \texttt{double} 类型，然后进行除法运算。如果不进行类型强转，整数除法会导致结果被截断为整数部分，得到2；而通过类型强转，我们可以得到正确的浮点数结果2.5。

类型强转在处理不同数据类型之间的运算时非常有用，可以确保运算结果符合预期。

\begin{exercise}[求平均数]
写一个程序，接受一系列整数输入，直到输入0为止，然后输出这些整数的平均值（不包括结尾的0）。

\textbf{程序输入}：一系列整数，每个整数占一行，最后一个整数为0，表示输入结束。

\textbf{程序输出}：一个浮点数，表示输入整数的平均值，保留两位小数。

\textbf{提示}：虽然把输入的整数定义为浮点数是可以避免类型强转的，但在金融上这会产生误差，是不可接受的。因此不得将输入的整数定义为浮点数，而是要定义为整数类型、加和，再通过类型强转来计算平均值。
    
\end{exercise}

\subsection{宏和预处理指令}\label{sec:macro}

宏是一种预处理指令，它可以在编译之前对代码进行替换和扩展。宏的基本格式如下：
\begin{lstlisting}[language=C++]
#define 宏名 替换内容
\end{lstlisting}
宏在编译器对代码进行预处理的时候进行纯文本替换。宏名通常使用大写字母来表示，以便于和变量区分。替换内容可以是任意的代码片段，包括变量、表达式、语句等。宏常用于定义常量，但是用宏定义的常量没有类型，而是字面值。

我们可能会看到，诸如 \texttt{\#define} 、 \texttt{\#include} 等均以符号 \texttt{\#} 开头，这些都是预处理指令，有时候也叫做编译指令。预处理指令和常规代码的行为有区别：它们实际上并非代码的一部分，而是在编译器对代码进行预处理的时候进行处理的。预处理指令通常用于定义宏、包含头文件、条件编译等。常用的预处理指令还有 \texttt{\#pragma} 、 \texttt{\#ifdef} 等。活用编译指令可以让代码更灵活、更高效。

\begin{warning}
  严格禁止使用所谓的“火车头”预处理指令！

  所谓的火车头预处理指令，指的是在代码的开头使用大量的 \texttt{\#pragma} 来指定编译器的行为。这种做法显著地导致了代码的可移植性和可维护性变差。因为不同的编译器对 \texttt{\#pragma} 的支持程度不同，甚至同一编译器的不同版本对某些 \texttt{\#pragma} 的支持也可能不同。而且你辛辛苦苦打一大堆 \texttt{\#pragma} ，实际上优化效果还不如一个简单的 \texttt{-O3} 。这种完全属于歪门邪道的做法，严重违反了代码简洁和可维护的原则。
\end{warning}

\section{指针和内存操作}

指针是C语言的最重要特性，没有之一。该特性彻底奠定了C语言在系统编程领域的统治地位。但对于新手而言，要理解指针难度还是比较大的，因此我们会尽量用通俗易懂的语言来解释指针的概念和使用方法；读者一定要确保理解该内容，而不是背“八股”式的语法，否则后续内容将会变得非常困难。

\subsection{什么是指针}

所有教材（甚至包括C标准）中，对指针的定义实际上都是“一个变量，它存储了另一个变量的内存地址”。但是，这个定义对于初学者来说过于抽象，难以理解。因此，我们可以用一个更形象的比喻来解释指针的概念。

想象内存是一条很长很长的一维走廊，每一个房间1字节，门牌号从0开始依次编号。

现在我们 \texttt{int a = 42;} 。于是，编译器给a分配了4个连续的房间（假设int类型占4字节），并把42这个值存储在这4个房间里。假设起始门牌是0x1000，那么a的4个字节分别存储在0x1000、0x1001、0x1002和0x1003这4个房间里，而变量a就住在0x1000这个房间里，也就是说\textbf{a的地址是0x1000}。

上述内容可以记作：
\begin{lstlisting}[language=C]
    int* p = &a;
    int *p = &a; // 或者这样，但实际没有任何区别
\end{lstlisting}
\begin{note}
    星号写在哪里都无所谓，甚至
    \begin{lstlisting}
        int*p = &a;
    \end{lstlisting}
    也是合法的。

    编译器认为上述写法完全等价。笔者个人习惯第一种写法，因为它清晰地表达了 \texttt{p} 是一个 \texttt{int*} 类型的变量。但大多数人习惯第二种写法，认为这样更符合自然语言的习惯。实际的代码应符合团队的代码风格规范。
\end{note}
可以看到，上述 \texttt{\&a} 就是“取门牌号”，结果类型就是“地址”（ \texttt{int*} ），也就是“指针类型”；而\textbf{指针存的东西就是“地址”，或“门牌号”}。因此，上述代码的意思是“声明一个指针变量p，并把变量a的地址赋值给它”，也就是“让p存储a的门牌号0x1000”。对于其他类型的变量也是类似的，例如 \texttt{char} 类型变量的指针是 \texttt{char*} 类型， \texttt{double} 类型变量的指针是 \texttt{double*} 类型，依此类推。

那么怎么用这个指针呢？我们可以通过指针来访问和修改变量的值。例如：
\begin{lstlisting}[language=C]
    *p = 100; //
    printf("%d\n", p); // 输出指针p的值（地址）
    printf("%d\n", a); // 输出变量a的值
\end{lstlisting}
我们惊奇的发现，虽然我们看似修改的是p，但p并没有改变，但a变了！这是为什么呢？这是因为 \texttt{*p} 表示“通过指针p访问它所指向的变量”，也就是“通过门牌号0x1000访问房间里的东西”。因此 \texttt{*p = 100;} 的意思就是“把p指向的房间里的东西改成100”，也就是把变量a的值改成100。

那么如果这样呢？
\begin{lstlisting}
    p = 100;
    printf("%d\n", p); // 输出指针p的值（地址）
    printf("%d\n", a); // 输出变量a的值
    printf("%d\n", *p); // 试图通过指针p访问它所指向的变量
\end{lstlisting}
这样，p确实是100了，但a并没有变。这是因为这里我们修改的是指针p本身，而不是通过指针p访问的变量。因此，变量a的值保持不变。

但是当我们试图通过指针p访问它所指向的变量时，程序可能会崩溃！这是因为p现在指向的是地址100，而这个地址并没有被分配给任何变量，因此访问这个地址会导致未定义行为！这被叫做“悬空指针”（dangling pointer），俗称“野指针”。因此，在使用指针时，一定要确保指针指向的是一个有效的变量。

因此，在指针中，两个运算符不要弄反：
\begin{itemize}
  \item \texttt{\&} ：取地址运算符，用于获取变量的地址，或“门牌号”。
  \item \texttt{*} ：解引用运算符，用于通过指针访问变量的值，或“门牌号对应房间里的东西”。
\end{itemize}

有一种特殊的指针被称为“空指针”（null pointer），可以理解为“该指针没有指向任何门牌号”，常用作为指针的初始值或者表示指针不指向任何有效变量。在C中，可以使用宏 \texttt{NULL} 来表示空指针。例如：
\begin{lstlisting}[language=C]
    int* p = NULL; // 声明一个空指针

    free(p);    // 释放内存
    p = NULL; // 释放内存后，立刻将指针设置为NULL，避免悬空指针
\end{lstlisting}

\subsection{指针的三条铁律}
在使用指针时，有三条铁律需要牢记于心：
\begin{itemize}
  \item 指针存储的是地址（门牌号），类型必须匹配；\texttt{int*} 类型的指针只能存储 \texttt{int} 类型变量的地址，\texttt{char*} 类型的指针只能存储 \texttt{char} 类型变量的地址，依此类推。至于原因，看到下文就明白了。
  \item 指针必须初始化！直接 \texttt{int* p;} 会得到一个野指针，里面是一个垃圾数值，千万不要使用它，用了大概率段错误。要是真想这么干，声明空指针即可。
  \item 用完的内存要还。这个后面讲到动态内存分配时会讲到为什么。
\end{itemize}

\subsection{指针和数组、函数的配合}

\subsubsection{指针和数组}

在C中，数组名实际上是一个指向数组第一个元素的指针。因此，我们可以使用指针来访问和操作数组元素。而指针的运算也往往无法脱离数组来理解。

例如：
\begin{lstlisting}[language=C]
int numbers[] = {10, 20, 30, 40, 50};
int* p = numbers; // 数组名作为指针，指向第一个元素
for (int i = 0; i < 5; i++) {
    printf("%d\n", *(p + i)); // 通过指针访问数组元素
}
\end{lstlisting}
在上述代码中， \texttt{numbers} 是一个数组名，它在表达式（和函数传参）中，会退化成首元素的地址，因此 \texttt{int* p = numbers;} 实际上等价于 \texttt{int* p = \&numbers[0];} 。

而上述代码中的 \texttt{*(p + i)} 则是通过指针运算来访问数组元素。这里， \texttt{p + i} 表示指针p向后移动i个元素的位置，而 \texttt{*} 则用于解引用该位置，从而获取对应的数组元素的值。实际上上述计算的意思是，“从地址 \texttt{p} 开始，向后移动 \texttt{i} 个 \texttt{int} 类型的字节数，然后访问该地址对应的值”。 \texttt{*(p + i)} 事实上等价于 \texttt{numbers[i]} 。

与之类似的，\texttt{++p} 表示指针p向后移动一个元素的位置，而 \texttt{p+1} 则表示指针p向后移动一个元素的位置，但并不改变指针p本身。

这就解释了为什么指针类型必须匹配的问题：如果指针类型不匹配，那么指针运算时移动的字节数就会出错，从而导致访问错误的内存地址，进而引发未定义行为。

\subsubsection{指针和函数}

指针和函数的配合主要体现在函数参数传递上。

我们可以写一段代码来说明这个问题：
\begin{lstlisting}[language=C]
void swap(int x, int y){
    int temp = x;
    x = y;
    y = temp;
}

swap(a, b);
printf("a = %d, b = %d\n", a, b); // 输出结果
\end{lstlisting}
我们惊奇的发现，虽然写了一个交换函数，但是实际上根本没有交换a和b的值！这是因为在C中，函数参数是通过值传递的，也就是说，当我们调用 \texttt{swap(a, b);} 时，实际上是将a和b的值复制了一份传递给函数 \texttt{swap} 的参数x和y。因此，在函数内部对x和y的修改并不会影响到外部的a和b。

那么怎么才能真正去影响a和b呢？这时就需要用到指针了。我们可以将a和b的地址传递给函数，然后在函数内部通过指针来修改它们的值。例如：
\begin{lstlisting}[language=C]
void swap(int* x, int* y){
    int temp = *x;
    *x = *y;
    *y = temp;
}

swap(&a, &b);
printf("a = %d, b = %d\n", a, b); // 输出结果
\end{lstlisting}
这次运行，就能真正交换a和b的值了。这是因为我们将a和b的地址传递给了函数 \texttt{swap} 的参数x和y，然后在函数内部通过解引用指针来修改它们所指向的变量的值，而非仅仅复制一份值。

\subsubsection{函数指针}

函数指针则是指向函数的指针变量。通过函数指针，我们可以动态地调用不同的函数，从而实现更灵活的代码结构。例如：
\begin{lstlisting}[language=C]
int add(int a, int b) {
    return a + b;
}
int multiply(int a, int b) {
    return a * b;
}

int (*funcPtr)(int, int);
// 将函数指针指向add函数
funcPtr = add;
printf("5 + 3 = %d\n", funcPtr(5, 3)); // 调用add函数
// 将函数指针指向multiply函数
funcPtr = multiply;
printf("5 * 3 = %d\n", funcPtr(5, 3)); // 调用multiply函数
\end{lstlisting}

这样能够让我们在运行时选择要调用的函数，从而实现更灵活的代码结构。

\subsection{动态内存分配}

动态内存分配是指在程序编译时不知道用多少内存，于是在运行时根据需要动态地分配和释放内存空间。

在C中，动态内存分配主要通过以下三个函数来实现：
\begin{itemize}
  \item \texttt{malloc(size\_t size)} ：用于分配指定大小的内存块，返回一个指向该内存块的指针。如果分配失败，返回 \texttt{NULL} 。
  \item \texttt{calloc(size\_t num, size\_t size)} ：用于分配指定数量的内存块，并将其初始化为零。返回一个指向该内存块的指针。如果分配失败，返回 \texttt{NULL} 。
  \item \texttt{free(void* ptr)} ：用于释放之前分配的内存块。参数 \texttt{ptr} 是指向要释放的内存块的指针。
\end{itemize}
例如：
\begin{lstlisting}[language=C]
int n;
scanf("%d", &n); // 读取数组大小
// 动态分配一个包含n个整数的数组
int* arr = (int*)malloc(n * sizeof(int));
if (arr == NULL) {
    perror("内存分配失败");
    exit(EXIT_FAILURE);
}
// 使用数组
for (int i = 0; i < n; i++) {
    arr[i] = i * 2; // 初始化数组元素
}
// 释放内存
free(arr);
arr = NULL; // 好的实践，立即置空，防止悬空指针
\end{lstlisting}
在上述代码中，我们首先读取了数组的大小n，然后使用 \texttt{malloc} 函数动态分配了一个包含n个整数的数组。接着，我们使用该数组进行了一些操作，最后使用 \texttt{free} 函数释放了之前分配的内存。如果不释放这个内存，那么程序常驻时会把内存吃光，导致系统崩溃，这被称为“内存泄漏”；如果不小心释放了两次同一块内存，程序也会崩溃，这被称为“双重释放”。这两个都是非常严重的错误，必须避免。

需要说明的是，malloc返回的是无类型指针（ \texttt{void*} ），C允许直接赋值给任何其他指针类型（例如 \texttt{int*} ），这是C特有的，而C++就不允许这么写。而在C中，我也推荐在赋值前进行强制类型转换。

\subsection{生命周期、静态变量和const指针}

变量的生命周期（lifetime）是指变量在内存中存在的时间段。根据变量的生命周期，变量可以分为以下几种类型：
\begin{itemize}
  \item 自动变量（automatic variables）：也称为局部变量，生命周期从定义开始，到所在的代码块结束为止。自动变量通常存储在栈（stack）中。
  \item 静态变量（static variables）：生命周期从程序开始，到程序结束为止。静态变量通常存储在数据段（data segment）中。静态变量可以在函数内部定义，但使用 \texttt{static} 关键字修饰。
  \item 全局变量（global variables）：生命周期从程序开始，到程序结束为止。全局变量通常存储在数据段（data segment）中。全局变量在函数外部定义。
  \item 动态分配的变量（dynamically allocated variables）：生命周期从调用内存分配函数（如 \texttt{malloc} ）开始，到调用内存释放函数（如 \texttt{free} ）为止。动态分配的变量通常存储在堆（heap）中。
\end{itemize}

\begin{tip}
    栈、堆等概念涉及到操作系统和计算机体系结构的知识。可以通俗的理解为：
    \begin{itemize}
      \item 栈（stack）：用于存储函数的局部变量和函数调用信息，具有先进后出（LIFO）的特点。栈的内存分配和释放由编译器自动管理，速度较快，但空间有限。
      \item 堆（heap）：用于动态分配内存，具有灵活的内存管理特点。堆的内存分配和释放需要程序员手动管理，速度较慢，但空间较大。
      \item 数据段（data segment）：用于存储全局变量和静态变量，生命周期从程序开始到程序结束。数据段的内存分配由编译器在程序加载时完成。
    \end{itemize}
\end{tip}

需要注意的是，静态变量和全局变量在程序运行期间始终存在，因此它们的值在函数调用之间是保持不变的。而自动变量和动态分配的变量则在函数调用结束后被销毁，无法再访问。

因此，如果试图想在函数中保存一些状态信息，可以考虑使用静态变量。例如：
\begin{lstlisting}[language=C]
int* foo(){
    int x = 42; // 自动变量
    return &x; // 错误，返回局部变量地址，x作为局部变量在函数结束后被销毁
}

int* foo_fixed(){
    static int x = 42; // 静态变量
    return &x; // 正确，返回静态变量地址，x在程序运行期间始终存在
}
\end{lstlisting}

至于const指针，则很特殊：
\begin{lstlisting}
int a = 10;
const int* p1 = &a; // 指向常量的指针，不能通过p1修改a的值
int* const p2 = &a; // 常量指针，不能修改p2的值，但可以通过p2修改a的值
const int* const p3 = &a; // 谁都别想动我
\end{lstlisting}
这个估计只能死记硬背了。

\subsection{指针常见错误}

指针是C语言中非常强大但也非常容易出错的特性。以下是一些常见的指针错误（其实我大多都提到过了）：
\begin{itemize}
  \item 没初始化：出现这种情况应该自罚三杯。
  \item 数组越界：一不小心访问了数组之外的内存地址，可能会导致程序崩溃或数据损坏。解决方法是确保访问的索引在数组的有效范围内。
  \item 返回局部变量地址：函数中的局部变量会随着函数的结束而销毁，因此试着返回它们的地址（或在函数外使用它们的地址）会导致悬空指针。解决方法是将变量声明为静态变量。
  \item free以后忘了，接着用：释放内存后继续使用该内存地址会导致未定义行为。解决方法是，free之后，立刻把指针置为NULL，防止悬空指针。
  \item 把int强转成指针乱玩：除非你知道你在做什么，否则不要这么做。
\end{itemize}

\begin{exercise}[指针练习题]
编写一个函数，接受一个整数数组和它的大小作为参数，返回数组中的最大值和最小值。

\textbf{程序输入}：一个整数n，表示数组的大小，接着是n个整数，表示数组的元素。

\textbf{程序输出}：两个整数，分别表示数组中的最大值和最小值。

\textbf{提示}：试着使用指针来遍历数组，并在函数中返回最大值和最小值。另，试着使用动态的内存分配来创建实际上的动态数组，而不是写VLA或预先写一个巨大的静态数组。

\end{exercise}


\section{标准库常用头文件}

C标准库头文件按照C17标准一共29个，其中有一些方法是我们经常会用到的。下面列出一些常用的头文件及其主要功能，基本上覆盖了C代码八成以上的需求。剩余的头文件，读者可以根据需要自行查阅相关资料。

\subsection{stdio.h}

该库主要负责输入输出操作。常用函数包括：
\begin{itemize}
  \item \texttt{printf(format, ...)} ：格式化输出函数，用于将数据输出到标准输出（通常是屏幕）。
  \item \texttt{scanf(format, ...)} ：格式化输入函数，用于从标准输入（通常是键盘）读取数据。
  \item \texttt{fopen(filename, mode)} ：打开文件，返回一个文件指针。
  \item \texttt{fclose(file\_ptr)} ：关闭文件。
  \item \texttt{fread(buffer, size, count, file\_ptr)} ：从文件中读取数据到缓冲区。
  \item \texttt{fwrite(buffer, size, count, file\_ptr)} ：将缓冲区的数据写入文件。
  \item \texttt{fprintf(file\_ptr, format, ...)} ：格式化输出到文件。
  \item \texttt{fscanf(file\_ptr, format, ...)} ：格式化从文件读取数据。
\end{itemize}

\subsection{stdbool.h}

该库主要负责布尔类型的定义和操作。它定义了一个名为 \texttt{bool} 的数据类型，以及两个宏 \texttt{true} 和 \texttt{false} ，分别表示布尔值的真和假。

\subsection{string.h}

该库主要负责字符串操作，顺带一些内存操作。常用函数包括：
\begin{itemize}
  \item \texttt{strlen(str)} ：返回字符串的长度（不包括结尾的空字符）。
  \item \texttt{strcpy(dest, src)} ：将源字符串 \texttt{src} 复制到目标字符串 \texttt{dest} 中。
  \item \texttt{strcat(dest, src)} ：将源字符串 \texttt{src} 连接到目标字符串 \texttt{dest} 的末尾。
  \item \texttt{strcmp(str1, str2)} ：比较两个字符串 \texttt{str1} 和 \texttt{str2} 的大小关系。
  \item \texttt{strchr(str, ch)} ：在字符串 \texttt{str} 中查找字符 \texttt{ch} 的第一次出现位置。
  \item \texttt{strstr(str1, str2)} ：在字符串 \texttt{str1} 中查找子字符串 \texttt{str2} 的第一次出现位置。
  \item \texttt{memcpy(dest, src, n)} ：将源内存块 \texttt{src} 的前 \texttt{n} 个字节复制到目标内存块 \texttt{dest} 中。
  \item \texttt{memset(dest, val, n)} ：将目标内存块 \texttt{dest} 的前 \texttt{n} 个字节设置为值 \texttt{val} 。该方法用来清理数组非常方便。
\end{itemize}

\subsection{stdlib.h}

该库主要负责内存分配、程序控制和数值转换等功能。常用函数包括：
\begin{itemize}
  \item \texttt{malloc(size\_t size)} ：分配指定大小的内存块。
  \item \texttt{calloc(size\_t num, size\_t size)} ：分配指定数量的内存块，并将其初始化为零。
  \item \texttt{free(void* ptr)} ：释放之前分配的内存块。
  \item \texttt{atoi(str)}、 \texttt{atof(str)} 、\texttt{strtol(str, endptr, base)} 等：将字符串转换为整数或浮点数。
  \item \texttt{qsort(base, nmemb, size, compar)} ：对数组进行快速排序。
  \item \texttt{bsearch(key, base, nmemb, size, compar)} ：在已排序的数组中进行二分查找。
  \item \texttt{realloc(ptr, size)} ：重新分配内存块的大小。
  \item \texttt{exit(status)} ：终止程序的执行，并返回状态码。
\end{itemize}

\subsection{math.h}

该库主要负责一些数学运算函数。常用函数包括：
\begin{itemize}
  \item \texttt{sqrt(x)} 、\texttt{pow(x, y)} 、\texttt{sin(x)} 、\texttt{cos(x)} 、\texttt{tan(x)} 、\texttt{log(x)} 、\texttt{exp(x)} 等：各种数学函数，一目了然。
  \item \texttt{abs(x)} 、\texttt{fabs(x)} ：计算整数或浮点数的绝对值。
  \item \texttt{ceil(x)} 、\texttt{floor(x)} ：向上取整和向下取整函数。
  \item \texttt{round(x)} ：四舍五入函数。
  \item \texttt{fmod(x, y)} ：计算浮点数的余数。
\end{itemize}

\chapter{从C到C++}

\begin{outline}
    C++ 是一种通用的编程语言，由Bjarne Stroustrup在1980年代初期开发，最初被称为“C with Classes”（带类的C）。C++在C语言的基础上引入了面向对象编程（OOP）的概念，并添加了许多其他特性，如泛型编程、异常处理和标准模板库（STL）等。本文将介绍C++的基本语法和特性，帮助读者从C语言顺利过渡到C++编程。
\end{outline}

\begin{prerequisite}
    \begin{itemize}
        \item 在任何计算机系统中配置好C++编译环境（如GCC、Clang或MSVC等）；
        \item 熟悉C语言的基本语法和概念，包括变量、数据类型、控制结构、函数和指针等；
        \item 了解基本的编程概念，如输入输出、数组和字符串等。
        \item 能够使用G++编译C++文件、用GDB调试C++程序。
    \end{itemize}
\end{prerequisite}

有的同学可能会问：那为什么又来了个C++呢？C不是已经很好了吗？为什么还要搞个C++出来呢？

理由很简单：C语言的确简单高效，但“太弱”，缺乏现代编程语言的特性，如OOP（面向对象编程）、泛型；其标准库也极小，很多东西都得手搓，在日常编程中这是非常痛苦的。

因此，C++应运而生。C++在保留C语言高效和灵活的同时，引入了许多现代编程语言的特性，如类和对象、继承、多态、模板等，从而使得程序设计更加模块化、可维护和可扩展。此外，C++还提供了一个强大的标准库（STL），包括容器、算法和迭代器等，大大简化了日常编程任务。

C++广泛应用于多种需要兼顾性能和抽象的领域，如系统软件、游戏开发、嵌入式系统和高性能计算等，著名的Chrome、Adobe全家桶、MS Office、Visual Studio都是C++写的，古老的DirectX游戏引擎\footnote{该游戏引擎最著名的作品莫过于《红色警戒2》了。}、现代的虚幻引擎\footnote{这个写出来的东西就太多了，目前大多数3A大作都是用这个引擎写的。}等也都要求用C++开发；而Unity引擎虽然允许用户使用C\#辅助开发，但其底层核心（乃至C\#的.NET运行时）也是用C++完成；Python里相当多的高性能库（如PyTorch、TensorFlow、JAX\footnote{JAX是Numpy的GPU加速版本，Google出品。}等）也是用C++写的。C和C++在事实上构成了当今高性能计算和软件开发的基石，在编程语言排名中常年稳居第三名和第二名，仅次于Python\footnote{Python最通行的解释器CPython甚至也是C写的！}。

\section{C++的基本语法}

C++的基本语法和C语言几乎完全一致，因此如果你已经掌握了C语言，那么学习C++将会非常容易。

\subsection{第一个C++程序}

下面是一个简单的C++程序，它输出“Hello, World!”到屏幕上：
\begin{lstlisting}[language=C++]
#include <iostream> // 引入输入输出流库

int main() {
    std::cout << "Hello, World!" << std::endl; // 输出Hello, World!
    return 0; // 返回0表示程序成功结束
}
\end{lstlisting}

我们发现，这个HelloWorld和C语言的HelloWorld长得很像，但确实存在一些区别：
\begin{itemize}
  \item 引入的头文件有区别；
  \item 输出语句有区别。
\end{itemize}

在C++中，基本的语法结构和C语言类似，包括变量声明、数据类型、控制结构（如条件语句和循环语句）、函数定义等，统统一致。可以说，C怎么写，C++就怎么写，完全没有区别。C语言的标准库在C++中也有其移植版本，一般是从 \texttt{xx.h} 变成了 \texttt{cxx} ，例如C语言的 \texttt{stdio.h} 在C++中变成了 \texttt{cstdio} ，但函数和用法几乎完全一致。

区别在于：C++自带bool类型，不需要 \texttt{\#include <stdbool.h>} ；另，结构体和联合体的定义上有所不同；第三，C++的字符串推荐用 \texttt{std::string} ，而不是C风格的字符串；最后，C++推荐使用流对象来输入输出。

接下来会把C++的新特性一一列举。对于面向对象、泛型和STL则会在后续章节中详细介绍。

\subsection{命名空间}

我们知道，一个软件还是程序，可能由很多人来完成。为了方便，每一个人都有可能定义自己的东西，例如功能（函数）、数据（变量）等。那么，如果两个人给自己不同的东西起了同样的名字怎么办？这时，电脑就无法区分它们了。

一个简单的方法是加强沟通，减少重名的可能性。但是，这样做并不现实。有的项目可能有数百人参与，沟通成本过高；有的项目是给下游使用的，这时又不可能沟通。这个问题非常棘手。

为了解决这个问题，C++引入了\textbf{命名空间}的概念。命名空间可以参照我们说过的虚拟环境概念来理解：每一个人都有自己的一个沙盒，在自己的沙盒里可以随便起名字，互不干扰。这样一来，即使两个人起了同样的名字，也不会冲突，因为它们属于不同的命名空间。
\begin{lstlisting}[language=C++]
    namespace Alice {
        int value = 42; // 数据（变量）
        void show() {   // 功能（方法）
            std::cout << "Alice's value: " << value << std::endl;
        }
    }
    namespace Bob {
        int value = 100; // 数据（变量）
        void show() {    // 功能（方法）
            std::cout << "Bob's value: " << value << std::endl;
        }
    }
\end{lstlisting}
这样，两者并不冲突。

但是新的问题又来了：有时候，别人在他们的命名空间里写了一些东西，而这些东西又是我们想要的。为了方便起见，肯定不能写第二遍。那么，我们该怎么办呢？可以这样写：
\begin{lstlisting}[language=C++]
    Alice::show(); // 调用Alice命名空间中的show函数
    Bob::show();   // 调用Bob命名空间中的show函数
\end{lstlisting}
于是困扰我们的重名问题就彻底解决了。

为了帮助我们更好的开发，C++提供了一些东西减少我们的重复劳动。这些东西被C++放在了“标准”命名空间中，也就是 \texttt{std} 。诸如 \texttt{cout} 、 \texttt{cin} 、 \texttt{endl} 等都在这个命名空间中。因此，我们在使用这些东西的时候，必须加上 \texttt{std::} 前缀，例如 \texttt{std::cout} 、 \texttt{std::cin} 、 \texttt{std::endl} 等。

为了方便起见，可以使用 \texttt{using namespace std;} 来引入整个 \texttt{std} 命名空间，这样在这个文件以及其下游文件中，就可以直接使用标准空间中的东西，而不需要加上 \texttt{std::} 前缀了。但是这样做也是有风险的：这会把整个标准命名空间都引进来，容易导致重名冲突等问题。

举例：假设你自己写了一个swap函数，然后在你的头文件中使用了 \texttt{using namespace std;} ，那么当别人引入你的头文件时，标准命名空间中的 \texttt{std::swap} 函数也会被引入，从而导致重名冲突，最终引发编译错误。

\begin{warning}
  严格禁止在工程头文件中使用 \texttt{using namespace std;} ！这会污染全局的命名空间，从而导致重名冲突等问题。头文件是给别人用的，绝对不应污染别人的命名空间。
  
  如果确实需要，我们有以下手段来解决污染命名空间问题：

  \begin{enumerate}
    \item 每一次使用标准命名空间中的东西时，都加上 \texttt{std::} 前缀。
        \begin{lstlisting}
    std::cout << "Hello, World!" << std::endl;
        \end{lstlisting}
    \item 只引入需要的东西，例如：
        \begin{lstlisting}
    using std::cout;
    using std::endl;
        \end{lstlisting}
      这样就只引入了 \texttt{cout} 和 \texttt{endl} ，而不会污染其他的东西。而一般人也不会去定义诸如 \texttt{cout} 和 \texttt{endl} 这样的名字，所以这样基本上可以认为是安全的。
  \end{enumerate}
\end{warning}

\begin{caution}
  在工程上，源文件也不推荐使用 \texttt{using namespace std;} 。但是这样做是可以容忍的，因为源文件是给自己用的，一般不至于污染命名空间，但是风险也是相当大的。对此，这需要大家自己权衡利弊了。如果项目周期非常短（例如做题），那么这么做没有毛病。但是如果是写工程这种长周期开发，则推荐老老实实用上面提到的两种方法来避免污染命名空间。
\end{caution}

\begin{note}
  为了简便，本书中大部分代码都使用了 \texttt{using namespace std;} ，但是请大家务必牢记上述警告和注意事项。
\end{note}

\subsection{C++的输入输出及其格式化}

在C++中，我们建议使用更安全的输入输出流 \texttt{cin} 和 \texttt{cout} 来进行输入输出操作。它们分别用于从标准输入（通常是键盘）读取数据和向标准输出（通常是屏幕）打印数据。

\texttt{cin} 和 \texttt{cout} 的基本用法如下：
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;
int main() {
    int age;
    cout << "请输入你的年龄：";  // 输出提示信息
    cin >> age;  // 从标准输入读取数据
    cout << "你输入的年龄是：" << age << endl;  // 输出读取到的数据
    return 0;
}
\end{lstlisting}
以上代码的意思是：先输出提示信息“请输入你的年龄：”，然后从标准输入读取一个整数值并存储到变量age中。接着输出“你输入的年龄是：”以及读取到的年龄值。

C风格的 \texttt{printf} 和 \texttt{scanf} 速度更快，因为不需要流操作；但是它们存在一些安全隐患，例如格式化字符串攻击和缓冲区溢出等问题。现代C编程中，微软推荐使用 \texttt{scanf\_s} 和 \texttt{printf\_s} 来代替 \texttt{scanf} 和 \texttt{printf} ，它们允许一个额外的参数来指定缓冲区的大小，从而避免缓冲区溢出的问题。但是，gcc和clang均不支持这两个函数。

不过，虽然在做题的时候确实可以使用 \texttt{scanf} 和 \texttt{printf} 来压榨时间，但是我们仍然建议在C++工程上使用更安全的 \texttt{cin} 和 \texttt{cout} 。

另外，我们在写代码的时候{\color{red}\textbf{一定不要一句C一句C++，或者说不要一句printf一句cout（反过来也不行）}}，这样会导致缓冲区冲突，从而引发一些莫名其妙的问题。要么全用C的输入输出，要么全用C++的输入输出。

\begin{note}
  实际上， \texttt{cin} 和 \texttt{cout} 和 \texttt{printf} 和 \texttt{scanf} 区别巨大。后者是一个函数，而前者是一个“流对象”（可以理解为一个“东西”而不是一个“手段”）。它们是C++标准库中的流对象，真正负责输入输出的实际上是 \texttt{<istream>} 头文件中的 \texttt{istream::read} 和 \texttt{<ostream>} 头文件中的 \texttt{ostream::write} 方法，它们被封装进 \texttt{>>} 和 \texttt{<<} 这两个运算符（流运算符），和我们的加减乘除等运算符一样。这两个运算符必然是返回流对象的一个引用，因此可以链式调用。特别的，当输入失败的时候，会返回流对象的一个“失败”状态，因此可以通过 \texttt{cin.fail()} 来判断输入是否成功，也可以通过布尔上下文转换（例如 \texttt{while(cin>>n)} ）来判断输入是否成功。

  流运算符也不是 \texttt{>>} 和 \texttt{<<} 的原本样子。它们原本是右移和左移运算符：例如 \texttt{a<<b} 是对a进行左移操作，将a的二进制表示整体向左边移动b位，右边补0；右移类似（只不过对于有符号整数最高位是0补0，是1补1；无符号整数默认补0）。在 \texttt{<iostream>} 头文件中，这两个运算符被重载了，使得它们可以用于流对象，进而辅助执行输入输出操作；也正因此，我们需要引用上述头文件才能使用它们。不过值得庆幸的是，我们可能一辈子都不会用到它们的原本样子。

  头文件 \texttt{<stdio.h>} 是C的头文件，而 \texttt{<cstdio>} 是这个头文件在C++中的移植版本。两者内容完全一致，只不过 \texttt{<cstdio>} 使用了C++的命名空间（ \texttt{std} ）；但是由于C++是C的超集，因此大多数实现也允许不套命名空间直接用 \texttt{printf} 等。在现代风格的C++编程中，我们通常使用 \texttt{<iostream>} 或 \texttt{<cstdio>} 来进行输入输出操作，而不是使用 \texttt{<stdio.h>} 。
\end{note}

有时候，我们需要对输入输出进行一些格式化操作，例如设置小数点位数、对齐方式等。C++提供了一些操纵符（manipulator）来实现这些功能。
\begin{itemize}
  \item  \texttt{std::setw(n)} ：设置输出宽度为n个字符。
  \item  \texttt{std::setprecision(n)} ：设置小数点位数为n位。
  \item  \texttt{std::fixed} ：固定小数位数输出浮点数。
  \item  \texttt{std::scientific} ：使用科学计数法输出浮点数。
  \item  \texttt{std::left} ：左对齐输出。
  \item  \texttt{std::right} ：右对齐输出。
\end{itemize}

上述不少操纵符需要引用头文件 \texttt{<iomanip>} 。例如，我们可以使用这些操纵符来格式化输出一个表格：
\begin{lstlisting}[language=C++]
#include <iostream>
#include <iomanip>  // 引入操纵符库
using namespace std;

int main() {
    cout << left << setw(10) << "Name" << setw(5) << "Age" << setw(10) << "GPA" << endl;
    cout << left << setw(10) << "Alice" << setw(5) << 20 << setw(10) << fixed << setprecision(2) << 3.5 << endl;
    cout << left << setw(10) << "Bob" << setw(5) << 22 << setw(10) << fixed << setprecision(2) << 3.8 << endl;
    return 0;
}
\end{lstlisting}

另一方面，我们也可以使用 \texttt{<format>} 头文件中的许多格式化方法来进行输入输出的格式化操作。这个头文件在C++20中引入，提供了一些类似Python的格式化字符串的方法。例如，我们可以使用 \texttt{std::format} 函数来格式化输出一个字符串：
\begin{lstlisting}[language=C++]
#include <iostream>
#include <format>  // 引入格式化库
using namespace std;

int main() {
    string name = "Alice";
    int age = 20;
    double gpa = 3.5;
    cout << format("Name: {}, Age: {}, GPA: {:.2f}\n", name, age, gpa);
    return 0;
}
\end{lstlisting}
此类方式的格式化方法非常灵活，支持多种格式化选项，例如对齐方式、填充字符等。这种方法现代化、格式安全，推荐使用。

如果使用{printf}等C风格的输出函数，则需要引用头文件 \texttt{<cstdio>} 。例如，我们可以使用 \texttt{printf} 函数来格式化输出一个字符串：
\begin{lstlisting}[language=C++]
#include <cstdio>  // 引入C风格输入输出库
using namespace std;

int main() {
    const char* name = "Alice";
    int age = 20;
    double gpa = 3.5;
    printf("Name: %s, Age: %d, GPA: %.2f\n", name, age, gpa);
    return 0;
}
\end{lstlisting}

对于输入方面，则复杂得多。我们推荐同学们使用更安全的C++风格输入输出方法，也就是 \texttt{cin} 、 \texttt{cout} 、 \texttt{getline} 等。

对于确定数量的干净\footnote{这里的干净指的是简单的空格分割或换行符分割，没有诸如逗号等其他符号。与之相对应的脏数据则是指包含了各种符号、格式不统一等复杂情况的数据。}输入，可以直接使用 \texttt{cin} ：
\begin{lstlisting}[language=C++]
int a, b, c;
// 假设输入格式为：1 2 3
cin >> a >> b >> c;  // 读入三个整数
\end{lstlisting}

对于不确定数量的干净输入，可以使用循环配合 \texttt{cin} ：
\begin{lstlisting}[language=C++]
int n;
while (cin >> n) {
    // 处理输入的n
}
\end{lstlisting}
上述代码会一直读取输入，直到遇到文件结束符（EOF）或者输入错误为止。其能工作的原因是 \texttt{cin} 在读取失败时会返回流对象的一个“失败”状态，该失败状态在布尔上下文中被解释为 \texttt{false} ，从而终止循环。

如果遇到脏输入，则情况变得复杂许多。常见的脏输入包括逗号分割的数字、带有多余空格的字符串等。对于这些情况，推荐使用 \texttt{getline} 配合字符串流（ \texttt{stringstream} ）来处理。下文演示了这种方式，并将逗号分割的整数字符串转换为整数数组：
\begin{lstlisting}[language=C++]
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
using namespace std;

int main(){
    string line;
    string tmp;
    vector<int> results;

    // 1. 读一整行
    getline(cin, line);

    // 2. 创建字符串流
    stringstream ss(line);

    // 3. 按逗号分割并处理
    while (getline(ss, tmp, ',')) {
        results.push_back(stoi(tmp)); // 转换为整数并存储
    }
    // 如果转换为double，可以使用stod
}
\end{lstlisting}

此外，C++20引入了 \texttt{std::from\_chars} 函数，可以直接将字符串转换为数字，性能优于 \texttt{stoi} 和 \texttt{stod} 等函数。下文演示了如何使用 \texttt{std::from\_chars} 来处理逗号分割的整数字符串：
\begin{lstlisting}[language=C++]
#include <iostream>
#include <string>
#include <vector>
#include <charconv> // 引入from_chars头文件
using namespace std;

int main(){
    string line;
    string tmp;
    vector<int> results;

    // 1. 读一整行
    getline(cin, line);

    size_t start = 0;
    size_t end = line.find(',');

    // 2. 按逗号分割并处理
    while (end != string::npos) {
        tmp = line.substr(start, end - start);
        int value;
        from_chars(tmp.data(), tmp.data() + tmp.size(), value); // 转换为整数
        results.push_back(value);
        start = end + 1;
        end = line.find(',', start);
    }
    // 处理最后一个数字
    tmp = line.substr(start);
    int value;
    from_chars(tmp.data(), tmp.data() + tmp.size(), value);
    results.push_back(value);
}
\end{lstlisting}

工程上，脏数据非常常见，因此掌握这些输入方式是非常有必要的。
\begin{caution}
  流对象处理输入输出的本质依然是操作缓冲区。因此，有一部分OIer认为他们自己维护缓冲区的输入方式更快、更好。诚然， \texttt{getline} 等方法处理缓冲区的性能大概比手动操作缓冲区低了约5到10\%，但是实际上我并不推荐手动维护缓冲区，尤其是在工程上。原因有三：
  \begin{itemize}
    \item 不安全。这是最大的一个弊病。手动维护缓冲区和不穿衣服在街上乱晃是一个道理，属于是把自己的安全完全交给了用户的善意。恶意用户攻击你的缓冲区将变得轻而易举。
    \item 不易懂。仅代码量一项，手动维护缓冲区就比使用流对象多出不少代码量，且难以阅读。这违背了工程代码的可读性原则。
    \item 难维护。我们在做题的时候，不少题目虽然算法简单但是边界条件复杂（例如日历问题），做这些题目的时候应付边界条件的时间几乎可以占到做题时间的一半。对于工程而言，手动维护缓冲区需要自己处理各种边界情况，估计也没有几个团队会有这个时间和精力去维护这些边界条件。
  \end{itemize}

  综上所述，虽然手动维护缓冲区在某些情况下可能会有一些性能优势，但是这种优势并不值得我们为之付出安全性、可读性和可维护性的代价。这就是工程代码为了安全、可读、可维护而牺牲性能的一个典型例子；另一方面，可以看到竞赛思维和工程思维有显著的差异，不能够混为一谈。
\end{caution}

\subsection{常变量、常量和它们的关系}
常变量（也叫不可变变量、只读变量、运行时常量）、常量（也叫编译期常量）往往笼统地称为常量。它们一旦确定就不会\textbf{在程序运行时}改变，任何试图对它们进行运行时更改的操作都会使得编译不通过。常量的值应当在声明时确定，可以通过赋值或者计算得到。它们的名字通常使用大写字母来表示，以便于和变量区分。

声明常变量的方法和声明变量差不多，但是要在最前面加上 \texttt{const} 关键字，如：
\begin{lstlisting}[language=C++]
const int MAX_VALUE = 100;
const int P = a + b; // 这里的a和b可以是变量
// P = 10 // 这行代码编译不通过，因此要注释掉
\end{lstlisting}
以上代码的意思是：我要创建一个常量MAX\_VALUE，它的值是100。

如果常变量的值\textbf{必须在编译时}确定，可以使用常量。常量的值在编译的时候值就确定了，不过因此也需要在定义中就写明它的值。常量的声明方法和常变量类似，只是把 \texttt{const} 换成 \texttt{constexpr} 。

常量也可以通过计算得到，计算在编译时进行，可以节省程序运行时间，但是要求用于计算的东西也必须是常量、字面值（直接写出来的值）、constexpr函数或者立即函数\footnote{立即函数指的是声明为 \texttt{consteval} 的函数，在 \texttt{C++20} 中被引入，这样的函数\textbf{只能在编译时期调用}}。下文是常量的几个例子。

\begin{lstlisting}[language=C++]
constexpr double E = 2.71828;
constexpr double PI = 3.14159;
constexpr double EPI = E * PI;
\end{lstlisting}

在现代 \texttt{C++} 中， \texttt{const} 常变量不依靠运行时初始化来确定其值（例如\lstinline[language=c++]|const int b = 1;|），其表现就和 \texttt{constexpr} 常量一样了。因此，在大多数时候，我们也可以把 \texttt{const} 常变量当作 \texttt{constexpr} 常量来使用。但如希望严谨表达意图，仍建议使用 \texttt{constexpr} 来声明常量。

\begin{tip}
  还是不懂？可以通过以下例子理解一下变量、运行时常量、编译期常量的区别：
\begin{lstlisting}[language=C++]
    int sqr(int x) { return x * x; } // 普通函数
    const int sqr_c(const int x) { return x * x; } // const函数
    constexpr int sqr_ce(const int x) { return x * x; } // constexpr函数
    consteval int sqr_cv(const int x) { return x * x; } // consteval函数
\end{lstlisting}

  那么对于以下声明，编译器的表现如下表所示。其中，编译失败的情形用红色标出；用 \texttt{const} 声明的运行时常量表现为编译期常量的特殊情形则使用蓝色标出。
  \begin{small}            % 整体字号
    \begin{longtable}[c]{lll}
      \caption{变量/常量声明与编译器表现}
      \label{tab:long}\\
      \toprule
      声明 & 编译器表现 & 理由 \\
      \midrule
      \endfirsthead          % 首页表头

      \multicolumn{3}{c}{\footnotesize 续表~\ref{tab:long}}\\[.5ex]
      \toprule
      声明 & 编译器表现 & 理由 \\
      \midrule
      \endhead               % 后续页表头

      \midrule
      \multicolumn{3}{r}{\footnotesize 接下页}
      \endfoot               % 每页底部（除末页）

      \bottomrule
      \endlastfoot           % 末页底部

      \texttt{int a0 = 5;}  & 变量 & 显然 \\
      \rowcolor{blue!15} \texttt{const int a1 = 5;}  & 常量 & 不依赖运行时初始化 \\
      \texttt{constexpr int a2 = 5;}  & 常量 & 字面值 \\
      \texttt{const int a3 = a0;}  & 常变量 & 依赖运行时值 \texttt{a0}  \\
      \rowcolor{red!15} \texttt{constexpr int a4 = a0;}  & 编译失败 & 严格常量不能用运行时值初始化 \\
      \texttt{int a5 = sqr(1);}  & 变量 & 显然 \\
      \texttt{const int a6 = sqr(1);}  & 常变量 & 依赖运行时函数 \\
      \rowcolor{red!15} \texttt{constexpr int a7 = sqr(1);}  & 编译失败 & 严格常量不能用运行时函数初始化 \\
      \texttt{int a8 = sqr\_c(1);}  & 变量 & 显然 \\
      \texttt{const int a8 = sqr\_c(1);}  & 常变量 & 依赖运行时函数 \\
      \rowcolor{red!15} \texttt{constexpr int a9 = sqr\_c(1);}  & 编译失败 & 严格常量不能用运行时函数初始化 \\
      \texttt{int a10 = sqr\_ce(1);}  & 变量 & 显然 \\
      \rowcolor{blue!15} \texttt{const int a11 = sqr\_ce(1);}  & 常量 & 该函数接受常量则在编译期初始化 \\
      \texttt{const int a12 = sqr\_ce(a0);}  & 常变量 & 依赖运行时值 \texttt{a0}  \\
      \texttt{constexpr int a13 = sqr\_ce(1);}  & 常量 & 显然 \\
      \rowcolor{red!15} \texttt{constexpr int a14 = sqr\_ce(a0);}  & 编译失败 & 严格常量不能用运行时值初始化 \\
      \rowcolor{red!15} \texttt{int a15 = sqr\_cv(1);}  & 编译失败 & 立即函数不可以在运行时调用 \\
      \rowcolor{blue!15} \texttt{const int a16 = sqr\_cv(1);}  & 常量 & 显然 \\
      \rowcolor{red!15} \texttt{const int a17 = sqr\_cv(a0);}  & 编译失败 & 立即函数不可以在运行时调用 \\
      \texttt{constexpr int a18 = sqr\_cv(1);}  & 常量 & 显然 \\
      \rowcolor{red!15} \texttt{constexpr int a19 = sqr\_cv(a0);}  & 编译失败 & 立即函数不可以在运行时调用 \\
    \end{longtable}
  \end{small}
\end{tip}

\begin{tip}
  用宏定义的常量和用 \texttt{const} 或 \texttt{constexpr} 定义的常量有一些区别。宏定义的常量没有类型，因此在使用时需要注意类型转换的问题；而 \texttt{const} 或 \texttt{constexpr} 定义的常量有类型，可以更好地进行类型检查和转换。此外，宏定义的常量在预处理阶段进行替换，因此可能会导致一些意想不到的问题，例如宏展开时的优先级问题等。而 \texttt{const} 或 \texttt{constexpr} 定义的常量在编译阶段进行处理，更加安全可靠。
\end{tip}

\subsection{数组}

C++虽然支持C风格的数组 \texttt{int arr[10];}  ，但是不推荐使用这种方式来声明数组。

在C++中，数组一般使用 \texttt{std::array} 和 \texttt{std::vector} 来声明。它们分别表示静态数组和动态数组。

\subsubsection{静态数组}

静态数组的大小在编译时确定，不能动态改变。它的基本格式如下：
\begin{lstlisting}
#include <array>  // 引入数组库
array<int, 10> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // 声明一个包含10个整数的数组
cout << arr[0] << endl; // 访问数组的第一个元素
\end{lstlisting}

这东西的实现和C风格数组相似，但一个重要的区别是：它是一个复杂类，而不是基本类型，有很多方法能够操作；另一个重要的区别是，在作为函数参数传递时，它\textbf{不会退化}为指针，从而避免了信息丢失的问题。

也就是说：
\begin{lstlisting}[language=C++]
void foo(array<int, 10> arr) {
    cout << arr.size() << endl; // 可以获取数组的大小
}

void bar(int arr[10]) {
    cout << sizeof(arr) / sizeof(arr[0]) << endl; // 这里会输出错误的结果，因为arr退化为指针，sizeof(arr)得到的是指针大小而非数组大小
}
\end{lstlisting}

\subsubsection{动态数组}

动态数组的大小可以在运行时确定，可以动态改变。它的基本格式如下：
\begin{lstlisting}[language=C++]
#include <vector>  // 引入向量库
vector<int> vec; // 声明一个空的动态数组
vec.push_back(1); // 向数组末尾添加一个元素1
vec.push_back(2); // 向数组末尾添加一个元素2
cout << vec[0] << endl; // 访问数组的第一个元素
cout << vec.size() << endl; // 获取数组的大小
vec.pop_back(); // 删除数组末尾的元素
vec.remove(0); // 删除数组中值为0的元素
\end{lstlisting}

动态数组的实现和静态数组类似，也是一个复杂类，有很多方法能够操作。它的大小可以动态改变，因此非常灵活，但性能上有较大的损失，在大型数组上比array慢一倍；但数组如果太大又不得不使用动态数组，否则栈空间不够用。

使用vector能够避免和C一样用malloc和free来直接操作内存，省心省力。

\subsection{字符串}
C++风格的字符串类型是 \texttt{std::string} ，它可以存储一串字符。字符串的基本格式如下：
\begin{lstlisting}[language=C++]
#include <string>   // 引入字符串库
string str = "Hello, World!";
\end{lstlisting}
引用字符串库是必要的，否则编译器可能会报错；这个库还提供了一些对字符串进行操作的方法，非常方便。

字符串的本质是一个数组，存储了一串字符（C风格的字符串正是char[]）。我们可以通过索引来访问字符串中的字符，例如str[0]表示第一个字符，str[1]表示第二个字符，以此类推。

字符串的长度可以通过 \texttt{str.length()} 方法来获取。除此以外，还有很多字符串操作方法，例如 \texttt{str.substr()} （获取子串）、 \texttt{str.find()} （查找子串）等。

字符串是一个复杂类，和以上提到的所有数据类型都有区别。具体为什么是“复杂类”，这涉及到C++的面向对象编程（OOP）特性。我们会在后续章节中详细介绍。

\subsection{结构体、联合体}
C++的结构体和联合体与C中的略有区别。

例如，我们可以声明一个表示学生的结构体：
\begin{lstlisting}[language=C++]
struct Student {
    string name;  // 学生姓名
    int age;      // 学生年龄
    double gpa;   // 学生绩点
};

Student student1;  // 声明一个学生变量
student1.name = "Alice";  // 设置学生姓名
student1.age = 20;  // 设置学生年龄
student1.gpa = 3.5;  // 设置学生绩点
cout << "Name: " << student1.name << ", Age: "
     << student1.age << ", GPA: " << student1.gpa << endl;
\end{lstlisting}

以上内容很好地展示了怎么定义、声明、使用一个结构体。结构体的成员可以通过点（.）运算符来访问，例如 \texttt{student1.name} 表示学生1的姓名。可以看到，不需要再像C语言一样，定义起来那么复杂。联合体也类似，这里不再赘述了。

\subsection{枚举}

枚举是一个可以存储一组命名常量的变量。

枚举有两种类型，一种是传统无作用域枚举 \texttt{enum} ，另一种是C++11引入的有作用域枚举 \texttt{enum class} （也叫强枚举）。它们的区别在于，传统无作用域枚举的常量可以直接访问，枚举名和枚举值都泄漏到所在的作用域；而有作用域枚举的常量需要通过枚举名来访问。

传统无作用域枚举的基本格式如下：
\begin{lstlisting}[language=C++]
    enum Color { RED, GREEN=5, BLUE };
\end{lstlisting}
一般情况下，枚举的底层类型由编译器自选，只要能够容纳所有的值就行了，一般是 \texttt{int} 。常量从0开始依次递增，例如上面的RED的值为0。也可以设定枚举的值，上文中我们将GREEN的值设定为5，那么BLUE的值就是6。调用这种枚举非常简单：
\begin{lstlisting}[language=C++]
Color color = RED; // 正统调用，color的值为0
int n = RED; // 不报错，n的值为0
Color c = 7; // 不报错，但是c的值不是RED、GREEN、BLUE中的任何一个，属于有效但未命名的值
\end{lstlisting}
可以看出，这种枚举没有类型安全性，也没有作用域隔离。

有作用域枚举的基本格式如下：
\begin{lstlisting}[language=C++]
    enum class Color : std::uint8_t { RED, GREEN=5, BLUE };
\end{lstlisting}
上述强枚举的枚举名被限定在作用域内，因此只能通过类似 \texttt{Color::RED} 来访问。强枚举的底层类型可以显式指定，例如上面的 \texttt{std::uint8\_t} 。如果不指定，默认是 \texttt{int} 。调用这种枚举智能使用上述的正统调用：
\begin{lstlisting}[language=C++]
Color color = Color::RED; // 正确，color的值为Color::RED
int n = Color::RED; // 报错，不能将Color类型赋值给int类型
Color c = 6; // 报错，不能将int类型赋值给Color类型
int n = static_cast<int>(Color::RED); // 正确，n的值为0
\end{lstlisting}
可以看出，这种枚举有类型安全性，也有作用域隔离。

枚举作为一个数据类型很笨，不仅没有任何方法，也不能进行运算，唯一的作用是定义一组常量，便于阅读；在 \texttt{switch} 语句中的使用较为多见。而剩下的很多方法，都不得不手动定义。

例如下列代码中，我们定义了一个枚举的遍历方法：
\begin{lstlisting}[language=C++]
enum class Color : std::uint8_t {
    FIRST=RED,
    RED=0,
    GREEN=1,
    BLUE=2,
    LAST=BLUE
};

for (Color c = Color::FIRST; c <= Color::LAST; c = static_cast<Color>(static_cast<int>(c) + 1)) {
    // 遍历 Color 枚举的所有值
}
\end{lstlisting}
这段代码中，我们定义了一个Color枚举，并且手动定义了FIRST和LAST两个常量，分别表示枚举的第一个值和最后一个值。

\subsection{智能指针（穿了衣服版）}

我们已经知道C风格的指针是什么了。C++中虽然也能和C一样使用“裸指针”，但是不推荐这么做。C++引入了智能指针的概念，来帮助我们更好地管理内存，不需要再手动malloc/free了。

智能指针有四个：
\begin{itemize}
  \item \texttt{std::unique\_ptr} ：表示独占所有权的智能指针，一个对象只能有一个 \texttt{unique\_ptr} 指向它。当这个 \texttt{unique\_ptr} 被销毁时，所指向的对象也会被自动释放。
  \item \texttt{std::shared\_ptr} ：表示共享所有权的智能指针，一个对象可以有多个 \texttt{shared\_ptr} 指向它。对象会在最后一个指向它的 \texttt{shared\_ptr} 被销毁时自动释放。
  \item \texttt{std::weak\_ptr} ：表示弱引用的智能指针，它不会影响对象的生命周期。它通常与 \texttt{shared\_ptr} 一起使用，用于解决循环引用的问题。它更像是一个观察者，不拥有对象的所有权。
  \item \texttt{std::auto\_ptr} ：严格唯一所有权的智能指针，在这里仅作介绍。它已经在C++11中被弃用。
\end{itemize}

例如：
\begin{lstlisting}[language=C++]
void foo(){
    auto ptr = std::make_unique<int>(42); // 创建一个unique_ptr，指向一个整数42
    std::cout << *ptr << std::endl; // 输出42
} // ptr超出作用域，所指向的整数自动释放

void bar(){
    auto ptr1 = std::make_shared<int>(42); // 创建一个shared_ptr，指向一个整数42
    {
        auto ptr2 = ptr1; // 共享所有权
        std::cout << *ptr2 << std::endl; // 输出42
    } // ptr2超出作用域，但整数不会释放，因为ptr1仍然指向它
    std::cout << *ptr1 << std::endl; // 输出42
} // ptr1超出作用域，所指向的整数自动释放
\end{lstlisting}

而 \texttt{weak\_ptr} 的使用则更为复杂一些，通常用于解决循环引用的问题。例如：
\begin{lstlisting}[language=C++]
#include <iostream>
#include <memory>
#include <string>
using namespace std;
struct Node {
    string name;
    shared_ptr<Node> next; // 强引用，可能导致循环引用
    weak_ptr<Node> prev;   // 弱引用，避免循环引用

    Node(const string& n) : name(n), next(nullptr), prev() {}
};
\end{lstlisting}
这是写了一个双向链表节点的例子。注意其中的 \texttt{next} 是强引用，而 \texttt{prev} 是弱引用。这样可以避免循环引用的问题，从而防止内存泄漏。这个指针在多线程编程中也很有用，可以安全地访问共享资源。

而数组中也不再建议使用指针来访问了，改为统一使用STL容器，例如 \texttt{std::vector} 、 \texttt{std::array} 等。于是，裸指针在C++中基本光荣退休。

基本上，我们可把使用哪种指针的决策流程总结如下：
\begin{itemize}
  \item 不共享所有权，使用 \texttt{std::unique\_ptr} 。这是99\%的情况。
  \item 共享所有权且肯定没有循环引用，使用 \texttt{std::shared\_ptr} 。
  \item 共享所有权且可能有循环引用，使用 \texttt{std::shared\_ptr} 和 \texttt{std::weak\_ptr} ，后者用于打破循环引用。
  \item 数组？使用 \texttt{std::vector} 、 \texttt{std::array} 等STL容器，而非指针。
\end{itemize}

C++的智能指针极大地简化了内存管理，减少了内存泄漏和悬空指针等问题的发生。推荐大家在C++编程中尽量使用智能指针，而不是裸指针。

\subsection{引用}

引用是C++中的一个重要特性，其核心任务是让变量有第二个名字，但不管理生命周期。引用不能为空、不能重新指向、不拥有对象，但在函数参数传递、返回值等场景中极为有用。

\subsubsection{左值引用}

默认提到引用，指的就是左值引用。

引用的基本格式如下：
\begin{lstlisting}[language=C++]
类型& 引用名 = 原变量名;
\end{lstlisting}
以上代码的意思是：声明一个名为引用名的引用，它是原变量名的别名。引用的作用是可以通过别名来访问原变量。例如，我们可以声明一个整数的引用：
\begin{lstlisting}[language=C++]
int a = 10;  // 声明一个整数变量
int& ref = a;  // 声明一个整数的引用
cout << "a: " << a << ", ref: " << ref << endl;
ref = 20;  // 修改引用的值
cout << "a: " << a << ", ref: " << ref << endl;
\end{lstlisting}

以上代码的意思是：声明一个名为ref的引用，它是变量a的别名。我们可以通过ref来访问a。当我们修改ref的值时，实际上也修改了a的值。

而在函数形参中，引用是较大形参传递的首选。
\begin{lstlisting}[language=C++]
void draw(const Widget& w) {
    // 使用w进行绘制操作
}
\end{lstlisting}
上述一股Qt味的代码中，我们使用了一个常量引用作为函数参数。这样做有两个好处：
\begin{itemize}
  \item 避免了拷贝开销。如果Widget是一个较大的类，那么传递它的引用可以避免拷贝整个对象，从而提高性能。
  \item 保持了对象的不可变性。使用常量引用可以确保函数不会修改传入的对象，从而提高代码的安全性。
\end{itemize}
而使用非常量引用作为函数参数，则表示函数可能会修改传入的对象：
\begin{lstlisting}[language=C++]
void update(Widget& w) {
    // 修改w的状态
}
\end{lstlisting}

为什么不用智能指针？因为智能指针管理生命周期，而引用不管理生命周期。引用更轻量级，适合用于函数参数传递和返回值等场景。除非你要转移或重置指针本身，否则不需要使用 \texttt{unique\_ptr} ；除非你要延长对象寿命（如缓存、异步任务等），否则不需要使用 \texttt{shared\_ptr} 。

但指针也不是万能的：容器里就不要存引用了，这是值（具体对象）和多态基类（智能指针）的天下，引用请靠边站（不是对象，存不了）。

\subsubsection{右值引用}

右值引用是C++11引入的一种新特性，绑定的是“马上要死”的临时变量，这一点和左值引用绑定的“长期活着”的变量不同。

一般，有自己名字的变量，要引用全都是左值引用；而没有自己名字的临时变量，则要用右值引用。另，\texttt{std::move} 可以把左值强制转换为右值引用，从而实现移动语义。

举例：
\begin{lstlisting}[language=C++]
int x = 1; // x 是一个左值，1 是一个右值
int& lref = x; // 左值引用，绑定到左值 x
int&& rref = 2; // 右值引用，绑定到右值 2
int&& rref2 = x // 错误，不能将左值绑定到右值引用
int&& rref3 = x + 3; // 合法，x + 3 是一个右值
rref = x + 3; // 合法，x + 3 是一个右值
\end{lstlisting}

那么这玩意有什么用呢？

第一个用途：把拷贝变成搬运，即“移动语义”。举个例子：
\begin{lstlisting}
    string s1 = "hello";
    string s2 = s1 + "world";
\end{lstlisting}
我们发现，“s1 + "world"”是一个临时对象，生命周期就这一行。但是要把这玩意搬进s2，就不得不做一次深拷贝，挺浪费的。

为了物尽其用，干脆把这个临时对象的资源直接搬进s2好了，不就省事了吗？这就是移动语义的核心思想。

实现移动语义需要用到右值引用，也就是说，重载：
\begin{lstlisting}
    string(const string& other); // 拷贝构造函数
    string(string&& other); // 移动构造函数
\end{lstlisting}
这就是“搬家”实现的关键。右值引用的“马上要死”特性，保证了我们可以放心地把资源搬走，而不会影响原来的对象。这有着典型的写法：
\begin{lstlisting}
    string(string&& other) noexcept
        : data(other.data) {    // 直接抢夺资源指针
        other.data = nullptr; // 搬家后，把原对象的指针置空，防止析构时重复释放
    }
\end{lstlisting}
因为临时对象马上就销毁，所以我们“偷窃”其资源没有人会察觉，从而大大提高了性能。而自己实现的类，往往也需要实现移动构造函数和移动赋值运算符，从而支持移动语义。

而第二个用途就是“完美转发”。这在模板编程中非常有用，可以把参数原封不动地传递给另一个函数，而不会丢失其左值/右值属性。
\begin{lstlisting}
    template<class T>
    void foo(T&& arg) {
        bar(std::forward<T>(arg)); // 完美转发
    }
\end{lstlisting}
上述代码中， \texttt{T\&\&} 是一个通用引用（也叫转发引用），它可以绑定到左值或右值。实际调用时，实参如果是左值， \texttt{T} 会被推导为左值引用类型；如果实参是右值， \texttt{T} 会被推导为右值类型。这样， \texttt{std::forward<T>(arg)} 就能根据 \texttt{T} 的类型正确地转发参数，保持其左值/右值属性。

\texttt{unique\_ptr}只能移动、不能拷贝的特性就是由右值引用实现的：
\begin{lstlisting}
std::unique_ptr<int> p1 = std::make_unique<int>(5);
std::unique_ptr<int> p2 = p1;      // 拷贝构造被删除
std::unique_ptr<int> p3 = std::move(p1); // OK，移动构造
\end{lstlisting}
上述移动完后，p1变成了空指针，p3拥有了原来p1的资源。

\subsection{函数重载}

函数重载是C++中的一个重要特性，它允许我们定义多个同名的函数或运算符，但它们的参数列表或返回类型不同。写一个例子就好了：

\begin{lstlisting}[language=C++]
struct Tensor2D{
    int x_dim, y_dim;
}
Tensor2D operator+(const Tensor2D& other) {
    // 实现加法运算
    Tensor2D result;
    result.x_dim = this->x_dim + other.x_dim;
    result.y_dim = this->y_dim + other.y_dim;
    return result;
}
\end{lstlisting}
以上代码就是重载的一个鲜活实例。我们重载了加法运算符，这使得我们能够对Tensor2D对象进行加法运算。合适的重载可以使代码更简洁、更易读。

除了重载运算符，还可以重载流运算符来实现自定义输入输出，重载函数实现对不同参数的处理等。重载的关键是参数列表的不同，返回类型可以相同或不同。C++不支持仅通过返回类型来区分重载函数。

\subsection{类型推断}

类型推断是C++11引入的一个特性，它允许编译器根据变量的初始值自动推断变量的类型。使用类型推断可以使代码更简洁、更易读。
类型推断的基本语法是使用 \texttt{auto} 关键字：
\begin{lstlisting}[language=C++]
auto x = 5;  // 编译器推断x的类型为int
auto y = 3.14;  // 编译器推断y的类型为double
auto str = "Hello, World!";  // 编译器推断str的类型为const char*
\end{lstlisting}
以上代码中，编译器会根据初始值自动推断变量的类型。

\begin{caution}
  不要滥用 \texttt{auto} ，因为这会使得代码的可读性降低，尤其是当变量的类型不明显时。我们只推荐在\textbf{变量的类型是确定的}、\textbf{类型的名称非常冗长}、\textbf{你知道这个变量的类型是什么或者大概是什么}的情况下使用类型推断，例如\lstinline[language=C++]|auto it = std::max_element(v.begin(), v.end());|中， \texttt{it} 的类型是 \texttt{std::vector<int>::iterator} 是确定的，这个类型名称很长，你也知道它是个迭代器类型，这时候使用 \texttt{auto} 是非常合适的。但是如果你真写了\lstinline[language=C++]|auto x = 5;|这种代码，那就属于滥用了，是不提倡的。

  如果变量的类型确实不确定（例如变量类型会随着初始化方式的不同而改变），这时候可以使用模板函数或模板类，而不是使用 \texttt{auto} 。如果你知道变量的类型是一个确定的类型，但是你不知道具体是什么类型，建议你先搞清楚这个变量的类型再写代码，否则几乎必然会出错。
\end{caution}

\subsection{类型别名}

类型别名是C就有的一个特性，但是C++11对它进行了扩展。类型别名允许我们为现有的类型创建一个新的名称，使得代码更易读。

C++中可以使用 \texttt{using} 关键字来定义类型别名。
\begin{lstlisting}[language=C++]
using ll = long long;  // 定义一个长整型的别名
using IntVector = std::vector<int>;  // 定义一个整型向量的别名
IntVector v = {1, 2, 3};  // 使用别名创建一个整型向量
\end{lstlisting}

如果使用C风格的语法，则是：
\begin{lstlisting}[language=C++]
typedef long long ll;  // 定义一个长整型的别名
typedef std::vector<int> IntVector;  // 定义一个整型向量的别名
IntVector v = {1, 2, 3};  // 使用别名创建一个整型向量
\end{lstlisting}

using和typedef几乎没有什么区别，只不过using的语法更加符合直觉（用这个作为这个的别名），类似于声明变量；而typedef则更像是定义一个宏（虽然实际上不是），阅读方向是反直觉的。

using的另一个独特之处是可以用于模板类型的别名：
\begin{lstlisting}[language=C++]
template <typename T>
using Matrix = std::vector<std::vector<T>>;  // 定义一个二维向量的别名
Matrix<int> m = {{1, 2}, {3, 4}};  // 使用别名创建一个二维向量
Matrix<double> dm = {{1.1, 2.2}, {3.3, 4.4}};  // 使用别名创建一个二维向量
\end{lstlisting}
typedef就无法应用于模板类型别名。因此，在C++中，我们推荐使用using来定义类型别名。

\subsection{类型强转}

有时候，在编程中我们需要将一个类型转化成另一个类型，以满足特定的需求。类型强转包括两类：隐式转换和显式转换。隐式转换是编译器自动进行的，而显式转换则需要程序员手动指定。

在一般情况下，隐式转换是安全的，不会导致数据丢失或错误。然而，有些情况下隐式转换可能会引发诸如精度等问题。默认能够进行的隐式转换包括以下几步：
\begin{enumerate}
  \item \textbf{标准整形提升}：所有比 \texttt{int} 小的整型（如 \texttt{char} 、 \texttt{short} ）会被提升为 \texttt{int} 或 \texttt{unsigned int} 。
  \item \textbf{整形等级转换}：提升之后，如果类型仍不匹配，编译器会尝试将较小的整型转换为较大的整型（如 \texttt{int} 转为 \texttt{long} ）。
  \item \textbf{浮点等级转换}：如果涉及浮点数，编译器会尝试将较小的浮点类型转换为较大的浮点类型（如 \texttt{float} 转为 \texttt{double} ）。
  \item \textbf{混合类别转换}：如果操作数类型不同，编译器会尝试将整型转换为浮点型，以避免精度丢失。转换后的类型为与浮点数的类型相同的浮点类型。
  \item \textbf{其他转换}：包括数组到指针、函数到指针、空指针常量、枚举到整型\footnote{ \texttt{C++11} 起的强枚举不能隐式转换}、类类型的转换\footnote{指的是诸如代码： \lstinline[language=c++]|struct A{ A(int);}; void foo(A); foo(42);| 中， \texttt{foo(42)} 把整数隐式转换为类}等。
\end{enumerate}

在C++中，类型强转被拆成了四个方式（四大金刚）：
\begin{itemize}
  \item  \texttt{static\_cast} ：\textbf{编译期安全的强转}，包括数值提升/截断，枚举/整型，子类指针转父类指针、void*转型等。它是最常用的类型转换方式，适用于大多数情况。
  \item  \texttt{dynamic\_cast} ：\textbf{运行时安全的强转}，几乎仅用于父类指针转子类指针。它会在运行时检查类型安全，如果转换不安全，则返回nullptr。它只能用于有虚函数的类。同时，它是唯一一个在运行时检查强转安全性的转换方式。
  \item  \texttt{const\_cast} ：\textbf{常变转换}，其他啥都不干。它是唯一一个能去const的转换方式。
  \item  \texttt{reinterpret\_cast} ：\textbf{按位重解释}，用于int指针互转、void指针互转、无关类指针互转等。它是危险的转换方式，仅在编译期做极弱的检查。它也可以用于转引用，但是如果转不了不会返回空引用\footnote{没有“空引用”这种东西。}而是报错。除非我们知道在干什么，否则不要使用它。
\end{itemize}

举例说明：
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;

double d = 3.14;
int a = static_cast<int>(d);  // 使用static_cast进行数值转换
int a = (int)d;  // C风格的强转，也行

const int c = 42;
int* p = const_cast<int*>(&c);  // 使用const_cast去掉const属性
// *p = 100; // 但是修改原变量的值是个UB

class Base;
class Derived : public Base;
// 注意：以上两行代码仅用于说明继承关系，实际过不了编译
Base* b = new Derived();
Derived* d = dynamic_cast<Derived*>(b);  // 使用dynamic_cast将父类指针转为子类
Derived* d = static_cast<Derived*>(b);  // 使用static_cast转型（不安全，但是能过编译）

uintptr_t ptr = reinterpret_cast<uintptr_t>(b);  // 使用reinterpret_cast将指针转换为整数
\end{lstlisting}

那么有些同学可能会问：为什么C++要提供这么多种类型强转？难道C风格的强转不行吗？没错，两种代码实际上都可以用。不过，C风格的强转像个大锤，一口气把任何东西都能砸成目标东西，但是它可不带管安全性的；而C++强转四大金刚分别是四把精确的手术刀，功能单一、语义明确，编译器会帮助你把关；要是危险或者出错了，编译器给你兜底。这样就可以避免很多潜在的错误。

C语言的强转实际上会先尝试常变转换，再尝试数值转换，要是不行就常变数值一起转，还不行就按位重解释。所以说这玩意实际上是四合一，不过也导致它隐形语义极为复杂、易于出错，出错了也不容易搜索定位。

\begin{lstlisting}[language=C++]
const volatile void* v = ...;
int* bad = (int*)v;  // C风格的强转，实际上一口气把const和volatile都去掉了，顺便做了个按位重解释
\end{lstlisting}

所以说，我们非常建议优先使用C++四大强转做显式强转。我们非常不建议在C++中使用旧式风格的强转，除非要做向下兼容等不这么做不行的事情。

\begin{note}
  \texttt{volatile} 是C/C++中的一个关键字，表示变量可能会被外部因素改变，因此编译器不会对它进行优化。它通常用于多线程编程或硬件寄存器的访问等。这个东西和移位运算符一样，绝大多数人一辈子都不会用到。
\end{note}

\subsection{Lambda表达式}

Lambda表达式是C++11引入的一个特性，它允许我们在代码中定义匿名函数。Lambda表达式可以捕获外部变量，并且可以作为参数传递给其他函数。它的基本语法如下：
\begin{lstlisting}[language=C++]
[捕获列表](参数列表) -> 返回类型 {
    // 函数体
}
\end{lstlisting}
捕获列表用于指定哪些外部变量可以在Lambda表达式中使用，参数列表和返回类型与普通函数类似。Lambda表达式可以直接在代码中定义，不需要单独声明。

例如：
\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3, 4, 5};
    int sum = 0;
    for_each(nums.begin(), nums.end(), [&sum](int n) { sum += n; });  // 使用Lambda表达式计算总和
    cout << "Sum: " << sum << endl;  // 输出结果
    return 0;
}
\end{lstlisting}
以上代码中，我们定义了一个Lambda表达式，该表达式能够捕获外部变量 \texttt{sum} ，并对 \texttt{nums} 向量中的每个元素进行求和操作。Lambda表达式可以使代码更简洁。

Lambda表达式的类型是特殊的。它是一个\textbf{独一无二}的、\textbf{不可命名}的、\textbf{由编译器生成}的\textbf{闭包类型}。该类是匿名的，每一个Lambda表达式都会生成一个独一无二的类。这个类会重载 \texttt{operator()} ，使得Lambda表达式可以像函数一样被调用。其类型是一个确定的类型，但是该类型既不能命名也不能写出。Lambda表达式也不是一个函数指针，但是可以隐式转换为函数指针（前提是没有捕获任何外部变量）。

例如下列代码：
\begin{lstlisting}[language=C++]
auto lambda = [](int x) { return x * x; };
\end{lstlisting}
其类型实际上类似于：
\begin{lstlisting}[language=C++]
class __lambda_unique_name {
public:
    int operator()(int x) const { return x * x; }
};
\end{lstlisting}
但是你永远不能直接写出这个类名，它是不可以访问的。

有些时候，我们需要对其进行存储或传递，此时需要声明其类型。此时， \texttt{auto} 是好的实践之一。但是如果要传递给函数怎么办呢？为了这个目的，C++11引入了 \texttt{std::function} 模板类，它可以存储任何可调用对象，包括Lambda表达式、函数指针、函数对象等。使用 \texttt{std::function} 可以方便地传递和存储Lambda表达式。
\begin{lstlisting}[language=C++]
#include <iostream>
#include <functional>  // 包含std::function的头文件
using namespace std;

void applyFunction(const function<int(int)>& func, int value) {
    cout << "Result: " << func(value) << endl;  // 调用传入的函数并输出结果
}

int main() {
    auto lambda = [](int x) { return x * x; };  // 定义一个Lambda表达式
    applyFunction(lambda, 5);  // 将Lambda表达式传递给函数
    return 0;
}
\end{lstlisting}
然而值得注意的是，即使是用 \texttt{std::function} ，它也仅仅是一个传递Lambda表达式的手段，而不是Lambda表达式本身的类型。且该类的性能开销比较大，有类型擦除的开销，可能会通过内联或堆分配来优化，因此在性能敏感的场景下应谨慎使用该类。实际上如果Lambda表达式不捕获任何外部变量，我们完全可以直接转成函数指针传递。
\begin{lstlisting}[language=C++]
    using FuncPtr = int(*)(int);  // 定义一个函数指针类型
    FuncPtr func = [](int x) { return x * x; };  // 将Lambda表达式转换为函数指针
    cout << "Result: " << func(5) << endl;  // 调用函数指针并输出结果
\end{lstlisting}

\subsection{多文件编程}

\subsubsection{头文件和源文件}

\textbf{头文件}是一些预先写好的代码的集合。通过包含头文件，我们可以使用这些预先写好的代码，而不需要重新编写它们。头文件的扩展名通常是 \texttt{.h} 或 \texttt{.hpp} 。引入头文件只需要在文件的开头使用 \texttt{\#include} 指令即可。

头文件有两种类型：标准库头文件和自定义头文件。标准库头文件是C++标准库提供的头文件，通常使用尖括号括起来，例如 \texttt{<iostream>} 、 \texttt{<vector>} 等，这样会先在系统路径中查找，再去当前路径中查找；自定义头文件是用户自己编写的头文件，通常使用双引号括起来，例如 \texttt{"myheader.h"} ，这样会先在当前路径中查找，再去系统路径中查找。

与“头文件”相对应的是\textbf{源文件}，它们通常包含程序的主要逻辑和实现代码。源文件的扩展名通常是 \texttt{.cpp} 、 \texttt{.cxx} 或 \texttt{.cc} 。源文件可以包含头文件，并且可以定义函数、类和变量等。

\begin{lstlisting}[language=C++]
// 这是一个源文件
#include <iostream>  // 引入标准库头文件
#include "myheader.h"  // 引入自定义头文件

int main() {
    // 使用头文件中的代码
    return 0;
}
\end{lstlisting}

\begin{warning}
  严格禁止使用所谓的“万能头文件” \texttt{\#include <bits/stdc++.h>} ，\textbf{尤其是在工程中！}该头文件有三个严重的问题：
  \begin{itemize}
    \item 该头文件不是C++标准的一部分，而是GCC编译器提供的一个非标准头文件。使用该头文件会导致代码在不同编译器下表现不同，严重地影响代码的可移植性。
    \item 该头文件会引入整个标准库，从而显著地降低代码的可维护性，具体表现为：
      \begin{itemize}
        \item 显著地增加编译时间，尤其是在大型项目中。
        \item 引入大量实际上并不需要的库，严重地增加了命名冲突的风险。
        \item 引入大量宏定义，可能会导致意想不到的行为。
      \end{itemize}
  \end{itemize}
  综上所述，严格禁止使用该头文件！多背几个常用的头文件名称并不难，且对代码质量有显著提升。
\end{warning}

\subsubsection{自己写个头文件}

有时候，我们自己需要写一个项目，这个项目代码量较大，可能有数千行。此时，我们需要多文件编程，以便于代码的组织和管理。

C++的多文件编程，文件结构通常是这样的：
\begin{lstlisting}
project/
    main.cpp // 主要的程序入口
    module1.cpp // 模块1的实现
    module1.h // 模块1的头文件
    module2.cpp // 模块2的实现
    module2.h // 模块2的头文件
    ... 这里可能还有其他文件
\end{lstlisting}
由此可见，除了主要程序入口（ \texttt{main} 函数所在的文件）之外，其他的头文件和源文件通常是成对出现的。在头文件中，一般包括类、函数、变量等的声明；在源文件中，一般包括类、函数、变量等的定义和实现。

自己写头文件时，通常包括以下内容：
\begin{itemize}
  \item 声明函数、类、变量等的接口。
  \item 使用预处理指令防止重复包含。
\end{itemize}
例如，我们可以编写一个简单的头文件 \texttt{myheader.h} ，包含一个函数的声明和定义：
\begin{lstlisting}[language=C++]
#ifndef MYHEADER_H  // 编译守卫，防止重复包含
#define MYHEADER_H
int add(int, int);  // 函数声明
#endif
\end{lstlisting}
然后在源文件 \texttt{myheader.cpp} 中实现这个函数：
\begin{lstlisting}[language=C++]
#include "myheader.h"  // 引入头文件
int add(int a, int b) {  // 函数定义
    return a + b;
}
\end{lstlisting}
然后在主程序中使用这个函数：
\begin{lstlisting}[language=C++]
#include <iostream>
#include "myheader.h"  // 引入头文件

int main() {
    int x = 5;
    int y = 10;
    int sum = add(x, y);  // 调用add函数
    std::cout << "Sum: " << sum << std::endl;  // 输出结果
    return 0;
}
\end{lstlisting}
最终对其进行编译：
\begin{lstlisting}[language=bash]
g++ main.cpp myheader.cpp -o myprogram
\end{lstlisting}
这样，我们就完成了一个简单的多文件编程。在上述编译命令中，两个源文件的顺序无关紧要。

如果源文件数量过多，那么就不应该使用诸如gcc等工具手动地编译。此时，应该使用 \texttt{Makefile} 、 \texttt{CMake} 、 \texttt{XMake} 、 \texttt{Conan} 等构建工具来管理编译过程。关于后三个构建工具的使用，将在下一章中介绍。

再强调一遍：在多文件编程中，不建议使用 \texttt{using namespace std;} 。尤其是头文件，严格禁止在头文件中使用该语句！

\begin{exercise}[重做]
    试着把上述C语言中的所有练习题，都用C++的方式重写一遍。要求：
    \begin{itemize}
        \item 使用C++的输入输出流（ \texttt{iostream} ）替代C的标准输入输出（ \texttt{stdio.h} ）。
        \item 使用C++的标准库容器（如 \texttt{std::array} 、 \texttt{std::vector} ）替代C的数组。
        \item 不得出现裸指针和直接的内存管理（如 \texttt{malloc} 、 \texttt{free} ）。
    \end{itemize}
    
    比较C和C++的代码风格和编程习惯，体会两者的异同。
\end{exercise}

\section{面向对象编程}

面向对象编程是C++的最重要特性之一。它允许我们将数据和操作数据的函数封装在一起，形成一个对象。对象是一个包含数据和方法的实体，它可以表示现实世界中的事物。同时，面向对象编程还提供了继承、多态等特性，可以帮助我们更好地组织代码和数据。

\subsection{类和属性}

类是面向对象编程的基本操作单位。如果不熟悉类，可以把类当成“超级struct”来理解，这里面除了存储数据（C++叫“属性”）以外，还可以顺便把函数（C++叫“方法”）也打包进去。
\begin{lstlisting}[language=C++]
class Point2D{
public:
    static const int DIMENSION = 2;  // 类的常量属性
    static int count;  // 类的静态属性
    int x, y;
    void move(int dx, int dy) {
        x += dx;
        y += dy;
    }
    Point2D(int x = 0, int y = 0) : x(x), y(y)
    {
        count++;
    }  // 构造函数
    ~Point2D() { count--; }  // 析构函数
}
\end{lstlisting}
于是，这下变量和函数成了一家人：
\begin{lstlisting}[language=C++]
Point2D p(1, 2);  // 创建一个Point2D对象p，x=1, y=2
p.move(5, -3);  // 移动点p，它自己知道怎么动！
cout << Point2D::count << endl;  // 输出类的静态属性
\end{lstlisting}
这就是“把数据和对数据的操作绑在一起”——面向对象的核心思想。

在类中，你可以看到我打了一个 \texttt{public} ，这说明以下属性和方法是公开的，其他所有类或者类外的东西都可以访问它。如果你不打 \texttt{public} ，那么默认是私有的（private），只有这个类内部可以访问；另一种访问权限是 \texttt{protected} ，它允许子类访问，但不允许类外的东西访问。（至于什么是子类，请先收起疑问，往下看就懂了）

部分属性前面，你可以发现打了 \texttt{static} 符号。这说明这个属性是静态的，属于 \texttt{类本身} ，而不是类的实例（实例指的就是可操作的对象，例如上面的p）。静态属性可以通过类名直接访问，例如 \texttt{Point2D::count} 。静态属性在所有实例之间共享，因此它们的值是全局的。

\subsection{自指}

类可以包含指向自身的指针或引用，这种特性称为自指，用 \texttt{this} 可以访问当前对象的指针。自指允许我们在类中定义链表、树等数据结构。自指的基本格式如下：
\begin{lstlisting}[language=C++]
class Node {
public:
    int data;  // 节点数据
    Node* next;  // 指向下一个节点的指针
    Node(int value) : data(value), next(nullptr) {}
    Node& GetThis() const {
        return *this;  // 返回当前对象的引用
    }
};
\end{lstlisting}

\subsection{构造、析构、拷贝和赋值}

类的构造函数和析构函数是特殊的方法，用于对象的初始化和清理。构造函数在创建对象（也叫实例化）时自动调用，而析构函数在对象销毁时自动调用。构造函数的名称与类名相同，并且既没有返回值也没有返回类型；析构函数的名称是波浪号（\textasciitilde）加上类名，同样既没有返回值也没有返回类型。

构造函数用于初始化对象的属性，析构函数通常用于释放对象占用的资源。\textbf{这是C++的一个重要特性RAII（Resource Acquisition Is Initialization）：资源获取在初始化中获取、在析构中释放。}我们在C++中不需要（也尽可能不要）像C一样手动malloc和free内存，而是通过构造函数和析构函数来自动管理资源，代码更简洁也更安全。

一般情况下，类有着默认的构造和析构函数，它们不含有任何参数，且不执行任何操作。默认的构造函数只会将所有属性初始化为默认值（例如整数为0，布尔值为false等），默认析构函数则按成员逆序调用成员的析构函数。满足这种条件的类也叫做\textbf{平凡且标准布局类}，在旧的实现中也叫POD类型：这种类型没有自定义构造函数、析构函数和拷贝构造函数，它们的行为类似于C语言中的结构体。相应的，在构造函数、析构函数中执行一些其他操作的类则叫做\textbf{非POD类型}，也往往叫做\textbf{复杂类}。一个类可以有多个构造函数（本质上是函数重载），但是只能有一个析构函数。

比如说：
\begin{lstlisting}[language=C++]
class Point2D{
    public:
        int x, y;
        Point2D() {} // 默认构造函数，防止覆盖
        Point2D(int _x, int _y){ // 自己写的构造函数
            x = _x;
            y = _y;
        }
        ~Point2D() {} // 自己写的析构函数
};
\end{lstlisting}

如果我们写了自己的构造和析构函数，那么编译器就不会再隐式地生成任何默认构造函数和析构函数。比方说，上文 \texttt{Point2D} 类中，我们定义了一个带参数的构造函数和一个析构函数。这样，当我们创建一个 \texttt{Point2D} 对象时，就会调用这个构造函数来初始化对象的属性（将全局点数量增加1）；当对象被销毁时，就会调用析构函数来干点别的（将全局点数量减1），然后清理资源。

在较新版本的C++标准中，构造函数的属性初始化部分可以使用初始化列表来简单地编写。例如：
\begin{lstlisting}[language=C++]
Point2D(int _x, int _y) : x(_x), y(_y) { ... }
\end{lstlisting}

\begin{note}
  需要注意的一点是：在C++中对象的资源管理由构造函数和析构函数自动完成，因此我们不要在构造函数中 \texttt{malloc} ，也不要在析构函数中 \texttt{free} 或者 \texttt{delete this} 。当 \texttt{malloc/free} 未配对时几乎必然导致内存出毛病，而随便 \texttt{delete this} 导致的双重释放也是非常危险的。如果一定要用构造函数和析构函数管理资源，应使用 RAII 资源句柄（如  \texttt{std::unique\_ptr} ）而非裸指针。
\end{note}

拷贝构造函数\footnote{没有“拷贝函数”这种东西。}是一个特殊的构造函数，它用来复制对象。一般情况下，C++会自动生成一个拷贝构造函数，它会逐个复制对象的属性。但是，如果类中有指针或动态分配的资源，我们需要自定义拷贝构造函数来正确地复制对象。拷贝构造函数的参数是类本身的常量引用，而对方法本身没有什么要求。

一般拷贝分为浅拷贝和深拷贝。浅拷贝只是复制指针的值，而深拷贝则会复制指针指向的内容。对于包含指针的类，我们通常需要实现深拷贝，以避免多个对象的指针指向同一块内存空间，导致资源管理混乱。默认拷贝操作对数据成员逐个复制；如果成员是指针，则仅复制指针值（即所谓“浅拷贝”）。当类拥有动态资源时，通常需要自定义深拷贝逻辑。

拷贝赋值运算符是一个特殊的运算符，用于将一个对象的值赋给另一个对象。它的基本格式如下，而下面这一段代码也展示了深拷贝操作中常见的“先复制、后交换”写法：
\begin{lstlisting}[language=C++]
class Foo {
    int* data;
public:
    Foo(const Foo& rhs) : data(new int[*rhs.data]) {} // 构造函数，深拷贝
    Foo& operator=(Foo rhs) {      // 按值接收，已拷贝/移动
        swap(*this, rhs);          // 交换资源
        return *this;
    }
    friend void swap(Foo& a, Foo& b) noexcept { std::swap(a.data, b.data); }
    // noexcept表示这个函数不会抛出异常
};
\end{lstlisting}
由此，我们看到了我们对 \texttt{=} 进行了重载。这实际上是定义了一个赋值函数，因此也被叫做类的赋值。

\subsection{封装}

封装是面向对象编程的一个重要特性，它允许我们将数据和方法封装在一起，形成一个对象。封装的目的是隐藏实现细节，只暴露必要的接口给外部使用。这样可以提高代码的可维护性和可重用性。

比方说：
\begin{lstlisting}[language=C++]
class BankAccount {
private:
    int balance;  // 私有属性，外部无法直接访问
public:
    BankAccount(int initialBalance) : balance(initialBalance) {}
    void deposit(int amount) {  // 公共方法，允许外部调用
        if (amount > 0) {
            balance += amount;  // 增加余额
        }
    }
    void withdraw(int amount) {  // 公共方法，允许外部调用
        if (amount > 0 && amount <= balance) {
            balance -= amount;  // 减少余额
        }
    }
    int getBalance() const {  // 公共方法，允许外部查询余额
        return balance;  // 返回余额
    }
};
\end{lstlisting}
这样可以阻止外部直接修改余额，只能通过存款和取款方法来操作余额。问我为什么余额用int而不是double或者float的，建议重读Mini ICS。

\begin{tip}
  在C\#中，封装有一对非常优雅的名词：Getter和Setter。Getter是获取属性值的方法，Setter是设置属性值的方法，同样是上述的代码我们在C\#中可以写成 \texttt{public int Balance \{ get; private set; \} }，意思是只有类内可以设置这个属性的值，而类内外可以获取这个属性的值。这样就实现了封装，同时又不失优雅。C++中没有这个优雅的语法，因此我们只能像上述代码中手动实现getter。
\end{tip}

\subsection{继承}

继承是面向对象编程的一个重要特性，它允许我们创建一个新的类（子类），它继承了另一个类（父类）的属性和方法。子类可以添加自己的属性和方法，也可以重写父类的方法。基类中被重写的方法应被声明为 virtual，也就是\textbf{虚函数}。重写方法时建议加 override 关键字。

继承的基本格式如下：
\begin{lstlisting}[language=C++]
class Shape { public: virtual double area() = 0; };
class Circle : public Shape { ... };
\end{lstlisting}
以上代码的意思是：声明一个名为Shape的类，它有一个纯虚函数area()，表示这个类是一个抽象类。然后声明一个名为Circle的类，它继承了Shape类，并实现了area()方法。

除了重写父类已有的方法，我们也可以在子类中新增一些父类没有的属性和方法。例如：
\begin{lstlisting}[language=C++]
class Circle : public Shape {
private:
    double radius;  // 圆的半径
public:
    Circle(double r) : radius(r) {}  // 构造函数
    double area() override {  // 重写父类的area()方法
        return M_PI * radius * radius;  // 计算圆的面积
    }
    double circumference() {  // 新增方法，计算圆的周长
        return 2 * M_PI * radius;  // 计算圆的周长
    }
};
\end{lstlisting}

现在只剩下“子类的构造函数怎么写”这个问题了。在C++的继承中，子类的构造函数需要调用父类的构造函数来初始化父类的属性。当\textbf{父类有公共的默认构造函数（无参）}，且\textbf{子类没有需要手动初始化的属性}时，子类的构造函数可以不写，编译器会自动生成一个公共且无参的默认构造函数，并调用父类的默认构造函数来初始化父类的属性。只要不满足以上情况，就必须要显式的提供子类的至少一个构造函数。
\begin{lstlisting}[language=C++]
class Base {
public:
    Base(int value) {
        cout << "Base constructor with value: " << value << endl;
    }  // 带参数的构造函数
    Base(int v1, int v2) {
        cout << "Base constructor with values: " << v1 << ", " << v2 << endl;
    }  // 另一个带参数的构造函数
    Base() {
        cout << "Base default constructor" << endl;
    }  // 默认构造函数
};
class Derived : public Base {
public:
    Derived(int value) : Base(value) {
        cout << "Derived constructor with data: " << value << endl;
    }  // 子类的构造函数，调用父类的带参数构造函数
    Derived(int v1, int v2) : Base(v1, v2) {
        cout << "Derived constructor with data: " << value << endl;
    }  // 另一个子类的构造函数，调用父类的另一个带参数构造函数
    Derived() : Base() {
        cout << "Derived default constructor" << endl;
    }  // 子类的默认构造函数，调用父类的默认构造函数
};
\end{lstlisting}

C++11以上的标准中，如果子类只是想照抄父类的所有构造函数而不需要写自己的，可以使用 \texttt{using} 关键字来简化代码：
\begin{lstlisting}[language=C++]
class Derived : public Base {
public:
    using Base::Base;  // 直接继承父类的所有构造函数
};
\end{lstlisting}

需要注意的是，以下两种代码是不过编译的：
\begin{lstlisting}[language=C++]
    class Base;
    class Derived : public Base { ... };  // 错误，Base类未定义
\end{lstlisting}
\begin{lstlisting}[language=C++]
    class Base { ... };
    class Derived : public Base; // 错误，子类的定义必须紧跟类体
\end{lstlisting}
在上述代码中，一开始我们声明出了一个类 \texttt{Base} ，但是并未定义它。这样的类是“不完整的”，C++规定不能继承一个不完整的类。另一方面，即使预先定义了基类，但是在继承的时候没有跟出定义也是不允许的。

在实际操作中，子类一般属于父类的一个特例，或者更简单地说\textbf{子类是父类}。例如，我们要创建一个“大舅”类和一个“二舅”类，一个非常差的设计是让“二舅”继承自“大舅”，因为二舅并不是大舅的一个特例（或者说二舅不是大舅），反过来也一样。一个好的设计是让这两个类都继承自一个“舅舅”类（他大舅他二舅都是他舅），这样就可以避免这种问题。

\subsection{多态}

多态指的是同一个方法在不同的对象上有不同的表现。多态是通过继承和虚函数实现的。当我们调用一个虚函数时，实际调用的是子类中重写的方法，而不是父类中的方法。这种特性使得我们可以使用父类指针或引用来调用子类的方法。

以继承中涉及到的Shape和Circle类为例：
\begin{lstlisting}[language=C++]
Shape* shape = new Circle();  // 创建一个Circle对象，并将其赋值给Shape指针
shape->area();  // 调用Circle类的area()方法
\end{lstlisting}
上述代码中会自动调用Circle类的area()方法，而不是Shape类的area()方法。这就是多态的体现：不用去关心具体的对象类型，省去了switch语句的麻烦。

\subsection{友元函数}

我们已经知道，对于一个类的属性和方法，有的是私有的、有的是公共的；从类外无法访问类的私有属性和方法。但是友元函数是一个例外，它可以访问类的私有属性和方法。友元函数的声明方式非常简单，只需要在函数前面加上 \texttt{friend} 关键字即可。友元函数可以是类的成员函数，也可以是全局函数。但是，友元函数的定义必须在类的外部，而非在类的内部。
\begin{lstlisting}[language=C++]
class MyClass {
private:
    int secret;  // 私有属性
public:
    MyClass(int value) : secret(value) {}  // 构造函数
    friend void revealSecret(const MyClass& obj);  // 声明友元函数
};
void revealSecret(const MyClass& obj) {
    cout << "The secret is: " << obj.secret << endl;  // 访问私有属性
}
\end{lstlisting}

一般情况下我们很少用到友元函数，因为它破坏了类的封装性。然而，在某些情况下，友元函数可以提供更高效的访问方式，尤其是在需要频繁访问类的私有属性时。

\section{泛型编程}

泛型编程的意思是：编写与类型无关的代码，从而实现代码的重用。

在C++中，泛型编程的核心机制是模板（Templates）。模板允许我们编写通用的代码，可以处理不同类型的数据。除此之外，C++11引入了类型推断（Type Inference）和类型别名（Type Aliases），进一步增强了泛型编程的能力。

\subsection{函数模板}

比方说我们想写一个加法：
\begin{lstlisting}[language=C++]
template <typename T>
T add(T a, T b) {
    return a + b;  // 返回a和b的和
}
int main() {
    int x = 5, y = 10;
    cout << add(x, y) << endl;  // 调用add函数，输出15
    double a = 3.14, b = 2.71;
    cout << add(a, b) << endl;  // 调用add函数，输出5.85

    return 0;
}
\end{lstlisting}
这个函数就可以对任何类型的数据进行加法操作，只要这个类型支持加法运算符。对于不支持加法运算符的类型，编译器会报错（但是我们可以为这些类型重载加法运算符）。编译器会自动根据调用推导其类型参数，当然也不是不可以手动指定类型参数，例如 \texttt{add<int>(x, y)} 。

\begin{tip}
在试着调用一个函数的时候，编译器会按以下方式查找合适的函数：
\begin{enumerate}
    \item 首先查找是否有与调用参数类型完全匹配的非模板函数。
    \begin{lstlisting}[language=C++]
void add(int a, int b) { cout<<"non-template function called"<<endl; }  // 非模板函数
template <typename T>
T add(T a, T b) { cout<<"template function called"<<endl; }  // 模板函数
add(5, 10);  // 调用非模板函数
    \end{lstlisting}
    \item 如果没有找到，则查找是否有与调用参数类型匹配的模板函数，并进行模板实例化。
    \begin{lstlisting}[language=C++]
template <typename T>
T add(T a, T b) { cout<<"template function called"<<endl; }
add(5, 10);  // 调用模板函数
    \end{lstlisting}
    \item 如果找到多个匹配的模板函数，编译器会尝试进行模板参数推导，以确定最合适的模板实例。
    \begin{lstlisting}[language=C++]
template <typename T>
T add(T a, T b) { cout<<"template function 1 called"<<endl; }
template <typename T>
T add(T a, double b) { cout<<"template function 2 called"<<endl; }
add(5, 3.14);  // 调用模板函数2
    \end{lstlisting}
    \item 如果仍然无法确定唯一的匹配，编译器会报错，提示存在二义性。
    \begin{lstlisting}[language=C++]
template <typename T>
T add(T a, T b) { cout<<"template function 1 called"<<endl; }
template <typename T>
T add(T a, T* b) { cout<<"template function 2 called"<<endl; }
int x = 5;
int* p = &x;
add(x, p);  // 二义性错误，无法确定调用哪个模板函数
    \end{lstlisting}
    \item 如果没有找到任何匹配的函数，编译器会报错，提示找不到合适的函数。
\end{enumerate}

上述规则虽在实际工程中意义有限，但了解其工作原理有助于理解模板函数的行为。
\end{tip}




\subsection{类模板}

类模板的语法类似，只不过是定义一个类而不是一个函数：
\begin{lstlisting}[language=C++]
template <typename T>
class Box {
public:
    T value;  // 存储一个值
    Box(T v) : value(v) {}  // 构造函数
    T getValue() const { return value; }  // 获取值的方法
};
Box<int> intBox(42);  // 创建一个存储整数的Box对象
Box<double> doubleBox(3.14);  // 创建一个存储双精度浮点数的Box对象
\end{lstlisting}
使用模板可以显著降低代码量，提高代码的可重用性。

\subsection{模板特化}

模板特化指的是为特定类型提供专门的实现。模板特化可以分为完全特化和部分特化。完全特化是为某个具体类型提供一个完整的实现，而部分特化则是为一组类型提供一个通用的实现。

语法如下：
\begin{lstlisting}[language=C++]
// 这里需提前定义通用模板
template <typename T>
class Box {
public:
    T value;
    Box(T v) : value(v) {}
    T getValue() const { return value; }
};

template <>
class Box<bool> {  // 为bool类型提供特化实现，完全特化
public:
    bool value;
    Box(bool v) : value(v) {}
    void toggle() { value = !value; }  // 特有的方法，切换布尔值
};

template <typename T>
class Box<T*> {  // 为指针类型提供部分特化实现，部分特化
public:
    T* value;
    Box(T* v) : value(v) {}
    T getValue() const { return *value; }  // 解引用指针获取值
};
\end{lstlisting}

\subsection{非类型模板参数}

非类型模板参数是指模板参数不仅可以是类型，还可以是常量值（如整数、枚举等）。这种特性允许我们在编译时传递一些固定的值，从而实现更灵活的模板设计。
\begin{lstlisting}[language=C++]
template <int N>
void printTimes(const std::string& str) {
    for (int i = 0; i < N; ++i) {
        std::cout << str << std::endl;  // 输出字符串N次
    }
}
printTimes<3>("Hello");  // 输出"Hello"三次
\end{lstlisting}
在上述代码中，模板参数 \texttt{N} 是一个整数常量，它决定了函数 \texttt{printTimes} 输出字符串的次数。

但是这玩意儿用得并不多，毕竟大多数情况下我们并不需要在编译时传递常量值。

\subsection{变参模板}

变参模板允许我们定义接受可变数量模板参数的模板。这样，我们可以编写更加通用和灵活的代码。变参模板使用省略号（ \texttt{...} ）来表示可变数量的参数。
\begin{lstlisting}[language=C++]
template <typename... Args>
void printAll(const Args&... args) {
    ((std::cout << ... << args), ...); // 折叠表达式，输出所有参数
    std::cout << std::endl;  // 最终的输出
}
printAll(1, 2.5, "Hello", 'A');  // 输出
\end{lstlisting}

这个倒是挺有用的，例如计算一组数的均值：
\begin{lstlisting}[language=C++]
template <typename... Args>
double mean(Args... args) {
    return (static_cast<double>(args) + ...) / sizeof...(args); // 计算均值
}
double result = mean(1, 2, 3, 4, 5);  // result = 3.0
\end{lstlisting}

\subsection{模板元编程}

模板元编程是一种利用模板机制在编译时进行计算的编程技术。通过模板元编程，我们可以在编译阶段执行一些复杂的计算，从而生成高效的代码。模板元编程通常用于实现类型特性检测、类型转换等功能。这是一种高级技巧，不是初学者必需掌握的内容，但是C++模板系统的极限玩法，了解一下也无妨。

例如，我们想编译期就把阶乘算了：
\begin{lstlisting}[language=C++]
template <int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;  // 递归计算阶乘
};

template <>
struct Factorial<0> {
    static const int value = 1;  // 阶乘的基例
}; // 0的完全特化

int main() {
    std::cout << "Factorial of 5: " << Factorial<5>::value << std::endl;  // 输出120
    return 0;
}
\end{lstlisting}

这个不是打表！仅是在编译期计算而已。用constexpr和consteval也能做到类似的效果。

\subsection{概念（C++20）}

“概念”是C++20引入的一个新特性，它允许我们为模板参数定义约束条件，从而提高代码的可读性和可维护性。概念可以看作是一种类型特性检测机制，它可以帮助我们确保模板参数满足特定的要求。
\begin{lstlisting}[language=C++]
#include <concepts>

template <std::integral T>  // 约束模板参数为整型
T add(T a, T b) {
    return a + b;  // 返回a和b的和
}

int main() {
    int x = 5, y = 10;
    std::cout << add(x, y) << std::endl;  // 调用add函数，输出15
    // double a = 3.14, b = 2.71;
    // std::cout << add(a, b) << std::endl;  // 错误，double不满足integral概念
    return 0;
}
\end{lstlisting}

\section{STL和其他标准库}

STL（Standard Template Library）是C++的最重要特性，它提供了一组通用的模板类和函数，可以帮助我们更高效地处理数据结构和算法。STL包含了许多常用的数据结构和算法，例如向量（vector）、链表（list）、集合（set）、映射（map）等。

简单地说，STL可以看作是：容器+迭代器+算法。容器把数据结构当变量类型用，迭代器把指针当普通函数用，算法把现成高复杂的轮子当函数用，这玩意能让你用三行代码完成 C 里三十行甚至三百行的工作，还自带内存管理和类型安全。

于是，C++开发就变成了：打开编辑器，敲下头文件，剩下的一律交给STL。

\begin{warning}
  严格禁止自己对STL进行重新实现！STL的实现经过了大量的优化和测试，自己重新实现容易出错且效率低下、维护困难，也不安全。STL确实存在时间复杂度常数项大的问题，但是这永远不应该成为你重新实现的理由，你自己实现的东西几乎必然会比STL更慢、更不安全、更难用；就算是比STL快，也基本上会被 \texttt{-O2} 抹平一切差距（工程上哪有不开优化的）。除非你的实现确实全方位吊打STL，但是那样的话你也不需要STL了，你可以直接去为ISO C++标准委员会做贡献了！
\end{warning}

\subsection{容器}

举个最常见的例子：
\begin{lstlisting}[language=C++]
std::vector<int> v = {3,1,4};   // 自动扩容的数组
std::set<int> s = {3,1,4};      // 自动排序的红黑树
std::unordered_map<std::string,int> m;  // 哈希表
\end{lstlisting}
以上代码中，我们使用了STL提供的向量（vector）、集合（set）和映射（unordered\_map）容器。它们都是模板类，可以存储任意类型的数据。使用它们非常容易：头文件即声明、自动管理内存、接口几乎全STL统一。

常见的容器有以下几种：（如果我没记错的话，C++正课会要求全部掌握这些容器，我只能说：祝你好运！）
\begin{itemize}
  \item  \texttt{vector} ：动态数组（向量），可以自动扩容，支持随机访问。实际上是单一内存连续块。
  \item  \texttt{list} ：双向链表，支持高效的插入和删除操作，但不支持随机访问。
  \item  \texttt{deque} ：双端队列，支持在两端高效地插入和删除操作。实际上是分段连续的内存块。
  \item  \texttt{set} ：集合，存储唯一元素，并自动排序。
  \item  \texttt{map} ：映射，存储键值对，并根据键自动排序。
  \item  \texttt{unordered\_set} ：无序集合，存储唯一元素，不自动排序，查询效率高。
  \item  \texttt{unordered\_map} ：无序映射，存储键值对，不自动排序，查询效率高。
  \item  \texttt{stack} ：栈，后进先出（LIFO）。
  \item  \texttt{queue} ：队列，先进先出（FIFO）。
  \item  \texttt{priority\_queue} ：优先队列，支持按优先级访问元素。
  \item  \texttt{array} ：固定大小的数组，类似于C风格的数组，但提供了更多的功能。
  \item  \texttt{bitset} ：位集合，支持高效的位操作。
  \item  \texttt{tuple} ：元组，可以存储不同类型的多个值。
  \item  \texttt{forward\_list} ：单向链表，类似于list，但只支持单向遍历。
  \item  \texttt{unordered\_multiset} ：无序多重集合，存储可以重复的元素，不自动排序。
  \item  \texttt{unordered\_multimap} ：无序多重映射，存储可以重复的键值对，不自动排序。
\end{itemize}
其实遇事不决的情况下，我们可以按照需求选择容器：
\begin{itemize}
  \item 速查：如果需要快速查找元素（建哈希表），使用 \texttt{unordered\_set} 或 \texttt{unordered\_map} 。
  \item 排序：如果需要自动排序， \texttt{set} 和 \texttt{map} 是最好的选择。
  \item 只要最大最小：如果只关心最大值或最小值，使用 \texttt{priority\_queue} 。
  \item 频繁在中间插入删除：如果需要频繁插入和删除元素，使用 \texttt{list} 。
  \item 频繁需要两头插入删除：如果只关心两端（尤其是头部）的插入和删除，使用 \texttt{deque} 。如果能确定用的是栈或队列，使用 \texttt{stack} 或 \texttt{queue} 。
  \item 遇事不决：如果不确定用什么容器，使用 \texttt{vector} 和 \texttt{array} 。它们是最通用的容器，适用于大多数场景。如果只关心尾部的频繁增删，也可以不用 \texttt{deque} ，直接用 \texttt{vector} 。
\end{itemize}

\begin{tip}
    \texttt{array} 和 C 风格数组的区别在于：前者是一个类，提供了更多的功能和安全性，例如边界检查、迭代器支持等；而后者只是一个简单的内存块，没有任何附加功能。建议尽量使用 \texttt{std::array} ，除非有特殊需求必须使用C风格数组。

    \texttt{array} 比 \texttt{vector} 在大多数情况下更高效，尤其是在小规模数据时，因为它避免了动态内存分配的开销。但是 \texttt{array} 的大小是固定的，不能动态调整；而 \texttt{vector} 可以根据需要动态扩展。但问题上是，\texttt{array} 是栈分配的，而 \texttt{vector} 是堆分配的，栈空间有限，如果开的数组太大会导致栈溢出。因此在开大数组时，建议使用 \texttt{vector} 。
\end{tip}

\begin{note}
  虽然我把stack和queue也当成容器、实际上在工程上也不怎么区分这东西，但是这里我有必要提及：这两个玩意实际上是容器适配器（container adapter），它们是基于其他容器实现的，提供了栈和队列的接口。一般情况下，默认参数是vector或者deque（因此不必指明），但是你也可以指定其他容器作为底层容器。
\end{note}

\begin{note}
  在大多数情况下， \texttt{std::vector<bool>} 和 \texttt{std::vector<T>} 实现有区别。前者是一个极为特殊的实现，使用位压缩来存储布尔值，因此它不是一个真正的向量，而是一个位集合（bitset）。这使得 \texttt{std::vector<bool>} 在某些情况下效率更高，但也导致了一些不兼容的问题。例如， \texttt{v[i]} 返回的是一个代理对象而不是一个引用； \texttt{auto x = v[i]} 返回的是值拷贝而不是常规的数据类型。

  这是因为，在 \texttt{std::vector<bool>} 中，每个布尔值只占用一个位（bit），而不是一个字节（byte）。因此，无法直接返回一个引用，因为引用必须指向一个完整的字节。为了实现对单个位的访问，STL使用了一个代理对象来封装对位的操作，这个代理对象提供了类似引用的行为，但实际上并不是引用。

  我们使用者不关心 \texttt{std::vector<bool>} 的实现细节，只需要记住以下五件事就行了：
  \begin{enumerate}
    \item 不能使用 \texttt{auto\& x = v[i]} 来获取元素的引用，因为代理对象不能绑定到非常引用；
    \item 不能使用 \texttt{\&v[i]} ，因为单个位没有地址；
    \item  \texttt{std::vector<bool>} 的迭代器不是常规迭代器的实现，不是指针；
    \item  \texttt{std::vector<bool>} 线程不安全（位压缩导致读写冲突，完全无法保证原子性）；
    \item 排序、查找等算法能用但是缓慢。
  \end{enumerate}
\end{note}

\subsection{迭代器}

迭代器可以认为是指针的语法糖。一个示例：
\begin{lstlisting}[language=C++]
for(auto it=v.begin(); it!=v.end(); ++it) cout<<*it<<' ';
// 或者直接：
for(auto x : v) cout<<x<<' '; // auto最应该这么用！
\end{lstlisting}

所有容器风格完全一致，完全不必关心装的是什么玩意。一些常见的迭代器和方法：
\begin{itemize}
  \item  \texttt{begin()} ：返回容器的起始迭代器。
  \item  \texttt{end()} ：返回容器的结束迭代器。
  \item  \texttt{rbegin()} ：返回容器的反向起始迭代器。
  \item  \texttt{rend()} ：返回容器的反向结束迭代器。
  \item  \texttt{cbegin()} ：返回容器的常量起始迭代器。
  \item  \texttt{cend()} ：返回容器的常量结束迭代器。
  \item  \texttt{next(it)} ：返回迭代器it的下一个位置。
  \item  \texttt{prev(it)} ：返回迭代器it的上一个位置。
  \item  \texttt{distance(it1, it2)} ：返回迭代器it1和it2之间的距离。
\end{itemize}

迭代器也可以加减，例如 \texttt{it+1} 表示下一个元素， \texttt{it-1} 表示上一个元素。

\subsection{算法}
STL提供了许多常用的算法，可以帮助我们更高效地处理数据，直接拿出来用就行：
\begin{lstlisting}
std::sort(v.begin(), v.end()); // 混合高速排序，结合快排、堆排等算法
std::binary_search(v.begin(), v.end(), 4);  // 二分
std::reverse(v.begin(), v.end());        // 原地翻转
\end{lstlisting}

以上代码中，我们使用了STL提供的排序（sort）、二分查找（binary\_search）和翻转（reverse）算法。STL的算法通常是模板函数，可以处理任意类型的数据。

除此之外，还有一些常用的算法：
\begin{itemize}
  \item  \texttt{std::find} ：查找元素。
  \item  \texttt{std::count} ：统计元素出现的次数。
  \item  \texttt{std::accumulate} ：计算元素的累加和。
  \item  \texttt{std::max\_element} ：找到最大元素。
  \item  \texttt{std::min\_element} ：找到最小元素。
  \item  \texttt{std::shuffle} ：随机打乱元素顺序。
  \item  \texttt{std::unique} ：去除重复元素。
  \item  \texttt{std::merge} ：合并两个已排序的范围。
  \item  \texttt{std::partition} ：对元素进行分区。
  \item  \texttt{std::transform} ：对元素进行转换。
  \item  \texttt{std::for\_each} ：对每个元素执行操作。
  \item  \texttt{std::set\_union} ：计算两个集合的并集。
  \item  \texttt{std::set\_intersection} ：计算两个集合的交集。
  \item  \texttt{std::set\_difference} ：计算两个集合的差集。
  \item  \texttt{std::set\_symmetric\_difference} ：计算两个集合的对称差集。
  \item  \texttt{std::nth\_element} ：找到第n小的元素。
  \item  \texttt{std::lower\_bound} ：找到第一个不小于给定值的元素。
  \item  \texttt{std::upper\_bound} ：找到第一个大于给定值的元素。
\end{itemize}

利用头文件 \texttt{<algorithm>} 可以使用这些算法。STL的算法通常是模板函数，可以处理任意类型的数据；配合迭代器，算法和容器原地解耦。

\subsection{字符串、流和字符串流}

字符串和字符串流是C++中处理文本数据的重要工具。C++提供了两种主要的字符串类型：C风格字符串（以 \texttt{char} 数组表示）和C++字符串（使用 \texttt{std::string} 类）。C++字符串更安全、更易用，推荐优先使用。

C风格字符串（ \texttt{char*} ）在C++中有头文件库 \texttt{<cstring>} ，提供了一些常用的字符串操作函数，例如：
\begin{itemize}
  \item  \texttt{strlen} ：计算字符串长度。
  \item  \texttt{strcpy} ：复制字符串。
  \item  \texttt{strcat} ：连接字符串。
  \item  \texttt{strcmp} ：比较字符串。
  \item  \texttt{strchr} ：查找字符在字符串中的位置。
  \item  \texttt{strstr} ：查找子字符串在字符串中的位置。
\end{itemize}

而C++字符串（ \texttt{std::string} ）在头文件库 \texttt{<string>} 中定义，每一个字符串是一个\textbf{对象}，而不是数组。该类提供了许多方便的方法来操作字符串，例如：
\begin{itemize}
  \item  \texttt{size()} 或 \texttt{length()} ：获取字符串长度。
  \item  \texttt{substr(pos, len)} ：获取子字符串。
  \item  \texttt{find(str)} ：查找子字符串的位置。
  \item  \texttt{replace(pos, len, str)} ：替换子字符串。
  \item  \texttt{append(str)} ：追加字符串。
  \item  \texttt{insert(pos, str)} ：插入字符串。
  \item  \texttt{erase(pos, len)} ：删除子字符串。
  \item  \texttt{c\_str()} ：获取C风格字符串。
\end{itemize}

流是C++中处理输入输出的重要工具。C++提供了两种主要的流类型：输入流（ \texttt{istream} ）和输出流（ \texttt{ostream} ）。输入流用于从标准输入或文件中读取数据，输出流用于向标准输出或文件中写入数据。我们不关心流是怎么实现的，但是应当理解其工作原理：

流有一个内部维护的缓冲区，输入流维护一个读指针（读取位置），输出流维护一个写指针（写入位置）。当我们从输入流中读取数据时，流会从缓冲区中读取数据，读取部分从读指针开始并向后移动，直到读完或者读取被换行符、空格等掐断，此时缓冲区内被读取的这一部分会被输入流吃掉，读指针会移动到读取位置的下一个位置（\textbf{然后缓冲区内就没有被读进去的这部分内容了}）；当我们向输出流中写入数据时，流会将数据写入缓冲区，写入部分从写指针开始并向后移动，直到写完或者缓冲区满，然后把写指针移动到写入位置的下一个位置；至于什么时候把缓冲区内的数据真正写入输出设备（例如屏幕、文件等），这取决于缓冲区什么时候刷新，包括缓冲区满、手动刷新、 \texttt{endl} 、程序结束、关联流（通常是 \texttt{cin} ）请求刷新五种情况。

做题的时候，部分居心叵测（无端）的出题人会在输入输出上做文章。这时，只需要记得在做题的时候少用 \texttt{endl} ，多用 \texttt{\textbackslash n} 就能解决大多数问题了。在极为特殊的情况下，我们可以直接切断 \texttt{cin} 和 \texttt{cout} 的关联，来提升输入输出效率（仅限于极少量的竞赛场景）。切断关联的方法是：
\begin{lstlisting}[language=C++]
std::ios::sync_with_stdio(false); // 关闭C和C++的同步
std::cin.tie(nullptr); // 取消cin和cout的绑定
\end{lstlisting}
当然，使用C风格的输入输出（ \texttt{scanf} 和 \texttt{printf} ）通常会更快一些。

字符串流（ \texttt{std::stringstream} ）在头文件库 \texttt{<sstream>} 中定义，它允许我们将字符串作为输入输出流进行处理。字符串流提供了类似于标准输入输出流的接口，可以方便地进行格式化输入输出操作。例如：
\begin{lstlisting}[language=C++]
#include <iostream>
#include <sstream>
using namespace std;

int main() {
    string str = "123 456 789";
    stringstream ss(str);  // 创建字符串流对象
    int a, b, c;
    ss >> a >> b >> c;  // 从字符串流中读取整数
    cout << "a: " << a << ", b: " << b << ", c: " << c << endl;  // 输出结果
    return 0;
}
\end{lstlisting}
以上代码中，我们使用字符串流将字符串中的整数提取出来，并输出结果。字符串流还提供了其他常用的方法，例如：
\begin{itemize}
  \item  \texttt{str()} ：获取字符串流中的字符串。
  \item  \texttt{clear()} ：清空字符串流的状态。
  \item  \texttt{seekg(pos)} ：设置读取位置。
  \item  \texttt{seekp(pos)} ：设置写入位置。
  \item  \texttt{tellg()} ：获取当前读取位置。
  \item  \texttt{tellp()} ：获取当前写入位置。
\end{itemize}
当然，我们很少对流进行直接操作，更多的还是用它配合 \texttt{std::getline} 等函数来处理输入输出。 \texttt{getline} 函数能够接受三个参数：输入流、输出字符串、分隔符（默认为换行符）。它会从输入流中读取一行数据，直到遇到分隔符为止，并将读取的数据存储到输出字符串中，以便于我们进行后续处理。
\begin{lstlisting}
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

int main() {
    string line; // 一堆逗号分隔的单词
    while (getline(cin, line)) {  // 从标准输入中读取一行数据
        stringstream ss(line);  // 创建字符串流对象
        string word;
        while (getline(ss, word, ',')) {  // 从字符串流中读取单词
            cout << word << endl;  // 输出单词
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{定长整数}

在C++中，有时候我们需要精确地控制整数和浮点数的长度，以满足各种各样奇奇怪怪的要求（例如缓存优化、文件格式、网络协议等）。C++11引入了头文件 \texttt{<cstdint>} ，提供了一组定长整数类型，例如：
\begin{itemize}
  \item  \texttt{int8\_t} ：8位有符号整数。
  \item  \texttt{uint8\_t} ：8位无符号整数。
  \item  \texttt{int16\_t} ：16位有符号整数。
  \item  \texttt{uint16\_t} ：16位无符号整数。
  \item  \texttt{int32\_t} ：32位有符号整数。
  \item  \texttt{uint32\_t} ：32位无符号整数。
  \item  \texttt{int64\_t} ：64位有符号整数。
  \item  \texttt{uint64\_t} ：64位无符号整数。
\end{itemize}
该头文件还提供了一系列宏，分别用于定义定长整数的最大值和最小值，例如：
\begin{itemize}
  \item  \texttt{INT8\_MIN} ：8位有符号整数的最小值。
  \item  \texttt{INT8\_MAX} ：8位有符号整数的最大值。
\end{itemize}

至于定长的浮点数，C++标准库并没有直接提供这样的类型。

\subsection{位运算}

位运算是对整数的二进制位进行操作的运算。常见的位运算符有以下几种：
\begin{itemize}
  \item 按位与（AND）： \texttt{\&} ，对两个整数的每一位进行与运算，只有两个位都为1时结果才为1，否则为0。
  \item 按位或（OR）： \texttt{|} ，对两个整数的每一位进行或运算，只要有一个位为1时结果就为1，否则为0。
  \item 按位异或（XOR）： \texttt{\textasciicircum} ，对两个整数的每一位进行异或运算，当两个位不同时结果为1，否则为0。
  \item 按位取反（NOT）： \texttt{\textasciitilde} ，对一个整数的每一位进行取反运算，0变为1，1变为0。
  \item 左移（Left Shift）： \texttt{<<} ，将一个整数的二进制表示整体向左移动指定的位数，右边补0。
  \item 右移（Right Shift）： \texttt{>>} ，将一个整数的二进制表示整体向右移动指定的位数，左边补0（对于无符号整数）或补符号位（对于有符号整数）。
\end{itemize}
位运算通常用于相当底层的编程，例如操作硬件寄存器、加密算法、图像处理、乘除法加速等，其效率非常高。有时候，在不太底层的地方，位运算往往也有奇效。
\begin{example}
  有一串整数，其中只有一个数出现了奇数次，其他数都出现了偶数次。请编写一个C++程序，找出这个出现奇数次的数。要求时间复杂度为O(n)，空间复杂度为O(1)。

  \textbf{输入}：一串整数，整数之间用空格隔开，输入以-1结束。保证 \texttt{int} 能够存储所有整数。
  \textbf{输出}：出现奇数次的整数。
\end{example}

\begin{answer}
  这道题可以使用按位异或运算来解决。我们知道，按位异或运算有以下性质：
  \begin{itemize}
    \item $a \oplus a = 0$，即一个数和自己异或结果为0。
    \item $a \oplus 0 = a$，即一个数和0异或结果为自己。
    \item 异或运算满足交换律和结合律。
  \end{itemize}
  因此，如果我们将所有整数进行异或运算，那么出现偶数次的数会被抵消掉，最终只剩下出现奇数次的数。

  我们可以用一个变量 \texttt{result} 来存储异或的结果，初始值为0。然后，我们不断读取输入的整数，并将其与 \texttt{result} 进行异或运算，直到遇到-1为止。最后， \texttt{result} 中存储的就是出现奇数次的数。

  下面是关键处的代码实现：
\begin{lstlisting}[language=C++]
while (cin >> num && num != -1)
    result ^= num;  // 使用按位异或运算
\end{lstlisting}
  结合输入输出，我们可以写出完整的程序。该程序留作练习。
\end{answer}

\begin{exercise}
  \begin{enumerate}
    \item 请完成上述程序。
    \item 与、或、非有没有类似的性质？请写下来。
  \end{enumerate}
\end{exercise}

在STL中，有一个专门处理位集合的容器： \texttt{std::bitset} 。它可以看作是一个定长的位数组，支持高效的位操作。我们可以使用它来存储和操作大量的布尔值，例如：
\begin{lstlisting}[language=C++]
#include <iostream>
#include <bitset> // 包含bitset的头文件
using namespace std;
int main() {
    bitset<8> b;  // 创建一个8位的位集合，初始值为00000000
    b.set(3);    // 将第3位（从0开始计数）设置为1，变为00001000
    b.flip(1);   // 将第1位取反，变为00001010
    b.reset(3);  // 将第3位重置为0，变为00000010
    cout << b << endl;  // 输出位集合的值
    cout << "Number of set bits: " << b.count() << endl;  // 计算并输出1的个数
    return 0;
}
\end{lstlisting}
以上代码中，我们创建了一个8位的位集合，并对其进行了设置、取反和重置操作。最后，我们输出了位集合的值和其中1的个数。位集合还提供了其他常用的方法，例如：
\begin{itemize}
  \item  \texttt{all()} ：检查所有位是否都为1。
  \item  \texttt{any()} ：检查是否有任意一位为1。
  \item  \texttt{none()} ：检查是否所有位都为0。
  \item  \texttt{size()} ：获取位集合的大小。
  \item  \texttt{to\_string()} ：将位集合转换为字符串。
\end{itemize}

\subsection{正则表达式}

在\ref{sec:regex}中，我们已经介绍了正则表达式的基本概念和语法。C++11引入了头文件 \texttt{<regex>} ，提供了一组类和函数来处理正则表达式。

主要的类有以下几种：
\begin{itemize}
  \item  \texttt{std::regex} ：表示一个正则表达式对象。
  \item  \texttt{std::smatch} ：表示一个字符串匹配结果容器，需要搭配 \texttt{std::string} 使用。
  \item  \texttt{std::cmatch} ：也是一个字符串匹配结果容器，但需要搭配 \texttt{const char[]} 使用。
\end{itemize}
“字符串匹配结果容器”指的是这是一个容器，能够存储匹配的详细结果。其存储的对象是 \texttt{std::sub\_match} 对象。特别的，其 \texttt{0} 索引存储的是整个字符串匹配的结果，而其余的索引存储各个捕获组\footnote{捕获组指的是把正则表达式里面的一部分模式用圆括号标出来，并告诉引擎这段子串一旦匹配成功就单独记下来方便以后反复使用。}匹配的字符串。

主要的函数有以下几种：
\begin{itemize}
  \item  \texttt{std::regex\_match} ：检查整个字符串是否匹配正则表达式。
  \item  \texttt{std::regex\_search} ：检查字符串中是否包含匹配正则表达式的子串。
  \item  \texttt{std::regex\_replace} ：将字符串中匹配正则表达式的部分替换为指定的字符串。在这里，允许使用诸如 \texttt{\$\&} （整个匹配）、 \texttt{\$ <number>} （ \texttt{<number>} 是捕获组的index，0是整个匹配）
    等占位符。
\end{itemize}

代码举例：
\begin{lstlisting}[language=C++]
#include <iostream>
#include <regex>
#include <string>

int main() {
    /*========  1. 正则与待测字符串  ========*/
    // 匹配中国大陆常见手机号格式：XXX-XXX-XXXXX（3-3-5）
    std::regex  pattern(R"((\d{3})-(\d{3})-(\d{5}))");
    std::string good = "123-456-78910";   // 完全匹配
    std::string bad  = "123-456-789ab";   // 最后一段不是数字
    std::string text = "Call me at 123-456-78910 or 987-654-32100.";

    /*========  2. std::regex_match：整串必须完全匹配 ========*/
    bool is_good = std::regex_match(good, pattern);
    bool is_bad  = std::regex_match(bad,  pattern);
    std::cout << std::boolalpha;
    std::cout << "good match : " << is_good << '\n';   // true
    std::cout << "bad  match : " << is_bad  << '\n';   // false

    /*========  3. 取出捕获组 ========*/
    std::smatch m;
    if (std::regex_match(good, m, pattern)) {
        std::cout << "\n捕获组演示：\n";
        std::cout << "整 match : " << m[0] << '\n';     // 123-456-78910
        std::cout << "第1组    : " << m[1] << '\n';     // 123
        std::cout << "第2组    : " << m[2] << '\n';     // 456
        std::cout << "第3组    : " << m[3] << '\n';     // 78910
    }

    /*========  4. std::regex_search：只要子串匹配即可 ========*/
    if (std::regex_search(text, m, pattern)) {
        std::cout << "\nsearch 找到： " << m[0] << '\n'; // 123-456-78910
    }

    /*========  5. std::regex_replace：替换 + 占位符 ========*/
    // 把电话号码换成“区号$1-局号$2-号码$3”的形式
    std::string repl = std::regex_replace(text, pattern,
                                          "区号$1-局号$2-号码$3");
    std::cout << "\nreplace 结果：\n" << repl << '\n';
    // -> Call me at 区号123-局号456-号码78910 or 区号987-局号654-号码32100.

    /*========  6. 常用占位符小结 ========*/
    // $&   整个匹配
    // $n   第 n 个捕获组，n=0 等价于 $&
    // $$   字面量 '$'
    std::string demo = "Price: 199USD";
    std::regex  pr(R"((\d+)(USD))");
    std::cout << "\n占位符演示：\n"
              << std::regex_replace(demo, pr, "$1 $$100") // 199 $100
              << '\n';

    return 0;
}
\end{lstlisting}

\subsection{小练}

\begin{example}
  假设现在有许多武士要角斗。每个武士都有一个名字和一个体力值，当两个武士相互角斗的时候，体力值较高的武士将会获胜，而体力值较低的武士会耗尽体力，并被淘汰。然而，角斗会消耗武士的体力值，因此每一次角斗后，胜者的体力值会减少等同于败者当前体力值的数值。如果有两个武士体力相等，则他们都会耗尽体力被淘汰。为了保证公平，武士们决定按照体力值从高到低的顺序进行角斗；如果有多个体力值最高的武士，那么他们会在这些武士中选择姓名字典序最靠前的两个武士进行角斗（例如有abc三个武士，则a的姓名字典序最靠前，b次之，c最靠后）。每次角斗后，胜者会继续参与角斗，直到只剩下一个武士或者没有武士剩下为止。

  请编写一个程序，模拟武士们的角斗过程，并输出角斗的结果。

  输入格式：共n+1行。你会接收到一个数字n，表示武士的数量。接下来n行，每行包含一个武士的名字和体力值（用空格分隔）。保证n不大于一百万，且保证没有两个武士的名字相同。

  输出格式：输出最后剩下的武士的名字和体力值。如果没有武士剩下，则输出“None Left”。
\end{example}

\begin{answer}
  上述题目看起来难度颇高。这也会是在类似于OJ上出现的常见题目类型之一：不会像前两个题目一样，给你明显的提示和思路（例如“使用筛法”），而是需要你自己思考解决问题的思路。对于这种题目，我们除了需要会语言以外，还要有一定的算法知识。好在这个题目比较简单，算法很直接，重点是怎么实现。

  \subsubsection{思路}
  我们看到， \texttt{武士们按照体力值从高到低的顺序角斗} ，这说明我们非常需要一个数据结构来存储武士们的信息，并且能够不停地获取体力最高的武士（对于体力值次高的武士，我们取两次就行），这让我们想到STL的一个重要成员：优先队列。另一方面，我们发现n的数量级在一百万，这对算法的时间要求较高，而优先队列能够很好地满足这个要求。

  我们用C++17的语法来做题。

  我们定义一下武士这个数据类型和优先队列：
\begin{lstlisting}[language=C++]
class Warrior {
private:
    std::string name_;  // 武士的名字
    int health_;        // 武士的体力值
public:
    Warrior() = default; // 默认构造函数
    Warrior(std::string name, int health)
        : name_(std::move(name)), health_(health) {} // 构造函数

    // Getters
    const std::string& name() const { return name_; }
    int health() const { return health_; }

    // utils
    void reduce(int amount) { health_ -= amount; } // 减少体力值
};

struct Cmp { // 比较器，用于优先队列排序
    bool operator()(const Warrior& a, const Warrior& b) const {
        return std::tie(b.health(), a.name()) <
                std::tie(a.health(), b.name());
        // 体力值高的优先级高，体力值相等时名字字典序靠前的优先级高
    }
}

using Queue = std::priority_queue<Warrior,
                        std::vector<Warrior>,
                        Cmp>;

Queue warriors; // 定义一个优先队列，存储武士
\end{lstlisting}

  再下一步就是处理角斗的逻辑了。由于优先队列会自动处理上述武士的排序问题，我们只需要不断地从优先队列中取出两个武士进行角斗即可：
\begin{lstlisting}[language=C++]
std::optional<Warrior> run(Queue& q) {
    while (q.size() > 1) { // 当队列中有两个或以上武士时
        Warrior first = q.top(); q.pop();  // 取出体力最高的武士
        Warrior second = q.top(); q.pop(); // 取出体力次高的武士

        if (first.health() == second.health()) {
            // 如果体力相等，则两人都被淘汰
            continue;
        } else {
            // 否则，胜者体力减少败者体力值，且a肯定是胜者
            first.reduce(second.health());
            q.push(std::move(first)); // 将胜者重新加入队列，这里用std::move避免拷贝
        }
    }
    return q.empty() ? 
        std::nullopt : 
        std::make_optional(q.top()); // 返回最后剩下的武士
}
\end{lstlisting}


  接下来，处理读取逻辑：
\begin{lstlisting}[language=C++]
int n;
cin >> n;  // 读取武士数量
for (int i = 0; i < n; ++i) {
    std::string name;
    int health;
    std::cin >> name >> health;  // 读取武士的名字和体力值
    q.emplace(std::move(name), health); // 将武士加入优先队列
    // emplace 直接在队列内构造对象，避免不必要的拷贝
}
\end{lstlisting}

  最后，处理输出：
\begin{lstlisting}[language=C++]
if (auto result = run(std::move(warriors)); result.has_value()) // 这里使用if初始化语句
    std::cout << result->name() << " " << result->health() << "\n";
else 
    // 如果没有武士剩下
    std::cout << "None Left\n";
return 0;
\end{lstlisting}

  当然，我们肯定不能把这些代码直接交上去，我们需要把它们拼接在一起，成为一个可以执行的程序。
\end{answer}

\begin{exercise}
  \begin{enumerate}
    \item 请将上述代码拼接在一起，完成一个完整的C++程序，并在本地编译运行。
    \item 试着使用set、map、vector等其他容器来重新实现上述题目，比较数据量较大时的性能差异。
  \end{enumerate}
\end{exercise}

\begin{note}
  部分同学可能会想：为什么我要用优先队列，而不是用set、map、vector等其他容器？这个问题问得很好。

  我们先来解释“优先队列为什么行”的问题。优先队列是一个特殊的容器，它使用二叉堆实现，速度很快，且我们仅考虑“每次只关心全局最大值”的问题。在上述题目中，我们实际上只将两件事反复循环：把人放进去，把最该打架的两个人拿出来，这两件事恰好符合优先队列的特性。优先队列插入弹出的时间复杂度是$O(\log n)$\footnote{对于不熟悉算法分析的同学们，以上表示可以通俗地理解为：问题规模是n与问题规模是1的时候相比，执行时间最坏情况下大概变为大O里面的函数倍。}，且获取最大值的时间复杂度是$O(1)$，因此上述问题使用优先队列的时间复杂度是$O(n \log n)$，空间复杂度是$O(n)$，非常高效。

  而对于set、map等容器，它们是用红黑树实现的，天然有序：简单地说，无论如何它们都会把所有元素排好（而优先队列并不会把所有元素排好，它只会把最大值放在最前面！）。上述问题中，每一次打架都会改变武士的体力值，这就意味着每次打架后都需要重新排序；为了保持有序，必须先删除、再插入，这个操作本身是两个$O(\log n)$的操作。而在更极端的情况下，加入胜者的体力值极低，它可能从队列首一直沉到队列尾，而set们仍然保留这个没什么竞争力的数据——这意味着后面每一次取“当前最大值”时，都会把这条记录再比较一遍，白白浪费$n log n $的时间！上述问题中，我们知道n是百万级别的，这种反复比较的额外开销总归是需要让复杂度爆炸的，或者说$O(n^2 \log n)$的复杂度，慢了一百万倍。

  而对于vector而言，每次重新排序则更加直观：一次排序就得$O(n \log n)$，而每次打架后都需要重新排序，这就意味着每次打架后都需要$O(n \log n)$的时间复杂度。这样一来，整个问题的时间复杂度就变成了$O(n^2 \log n)$，显然超时。综上所述，只有保留全局极值但是不必保留元素具体顺序的数据结构才能较好地完成了这个问题，而优先队列正是这样一个数据结构\footnote{这个题其实有更快的手段，例如胜者树、败者树等，它们本质上是二叉堆的工业级优化，时间复杂度都是$O(n \log n)$，但是常数应该会更小。但是它们写起来非常困难，要考虑各种诸如淘汰等的边界情况，且需要相当的算法基础。胜者树/败者树在竞赛或工程里通常服务于多路归并这类需要“反复取最小/最大并立刻替换”的场景；而本题只需要“全局最大”，STL 的堆已经够用而且很简洁，杀鸡焉用牛刀。我们这里就不讲了。}。
\end{note}

以上，就是C++的全部内容了（也不是全部内容，毕竟C++20、C++23等版本有越来越多的新特性，但是能掌握C++17的全部特性就已经不得了了）。C++的语法和特性非常丰富，学习曲线较陡，但一旦掌握，就可以编写高效、可维护的代码。

\section{为什么不抛弃C？}

学到这里，不少人估计又会问：C++这么好，为啥不让C直接光荣退休？实际上这句话在技术上听起来确实很爽，但是忽略了语言生态、历史路径和硬件底层几个因素。

首先，在操作系统、启动文件、硬件裸机上，C是最后一层“可移植的汇编”：Linux全是C+内联的汇编，Linus明确“no C++”；POSIX标准上，系统API全是C接口，要保持C的ABI才能被后续C++、Python、Rust、Go等语言调用；Bootloader等只有8kBROM，没有C++喜欢的堆，其异常表、RTTI占空间，体积就是成本。所以说，换C++等于重做整个世界，代价巨大。

另，C由于其简单性，导致其编译器、工具链、嵌入式支持等生态极其成熟，几乎所有平台都支持C，保持C标准实际上是保持全世界软件互相操作的“插头”继续正常工作。虽然C++也已经将近50岁、非常成熟，但因为其重载、模板、命名空间、符号重命名规则复杂，导致其ABI不稳定，跨编译器、跨版本互操作性差，无法取代C的地位。

又，C和C++的两个委员会代表了不同的利益：WG14（C委员会）代表了嵌入式、操作系统、编译器等底层软件的利益，核心诉求是稳定、轻量、ABI，反对C++的特性污染；而WG21（C++委员会）代表了应用软件、游戏、图形等高层软件的利益，核心诉求是抽象、零开销、泛型，反对C的限制演进。脑壳更疼的是编译器厂商，他们要维护多重前端，合并了工作量也跟着翻倍。这“分家”实际上是政治和市场的平衡结果，不是技术优劣的简单问题。

最终，现有的C代码库数量实在是太大了，估计怎么也已经有了几千亿行。要是随便乱换，那成本也是不可估量的。

现在C和C++的委员会官方立场是和平共处、互不阻塞，WG14明确其“不与C++竞争泛型和OOP”，WG21也承诺“C++标准库头文件会和C头文件保持一致，不会破坏C的ABI”。所以说，C和C++各有各的用武之地，互不冲突。

而我之所以要先讲C再讲C++，主要原因是C++中“指针”这个概念几乎完全隐身，其高级抽象掩盖了底层的内存模型和运行机制，如数组越界、函数指针、手动内存分配等在C++中都被STL、智能指针等抽象掉了，初学者很难理解其底层原理。而C语言则直接暴露了这些底层细节，能够帮助初学者更好地理解计算机的运行机制和内存模型，为后续学习C++打下坚实的基础。换句话说，我是为了“裸指针”这碟醋而包了“C语言语法”这盘菜；也只有知道C控制内存有多麻烦，才能体会C++智能指针和RAII的真正价值。

要不然……同学，你也不想不知道什么是迭代器吧？

\section{怎样写出真正的C++？}

很多C++使用者实际上写的是“C with STL”，也就是仅用C++的语法糖和STL容器，却没有真正利用C++的面向对象、泛型编程等特性。这样写出来的代码往往冗长、低效、难以维护，无法发挥C++的真正优势。

\subsection{从实例出发，到实例中去}

任务：读取文件内容到字符串，并统计非空行数。我们只要得到结果的函数即可，不需要完整的程序框架。这些代码都对应着当时主流编译器、标准库、硬件和工程组织的硬约束，不能脱离实际。

\subsubsection{C99，2000}
\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

size_t count_non_empty_lines(const char* path)
{
    FILE* fp = fopen(path, "r"); // 以读模式打开文件
    if (!fp) return (size_t)-1; // 打开失败，返回-1表示错误

    size_t cnt = 0; // 非空行计数器
    char*  line = NULL; // 存储读取的行
    size_t n = 0; // 行缓冲区大小
    ssize_t len; // 读取的行长度
    while ((len = getline(&line, &n, fp)) != -1) {
        /* 至少有一个非空白字符 */
        int non_blank = 0;
        for (ssize_t i = 0; i < len; ++i)
            if (!isspace((unsigned char)line[i])) { non_blank = 1; break; }
        cnt += non_blank;
    }
    free(line);
    fclose(fp);
    return cnt;
}
\end{lstlisting}
这个是很好的C代码，使用了标准库函数，处理了错误情况，逻辑清晰：手动管理文件、getline动态扩容、逐行读取、逐字符检查非空白。

\subsubsection{C++03，2003}
\begin{lstlisting}[language=C++]
#include <cstdio>
#include <vector>
#include <string>

std::size_t count_non_empty_lines(const std::string& path)
{
    FILE* fp = std::fopen(path.c_str(), "r");
    if (!fp) return -1;

    std::size_t cnt = 0;
    std::vector<char> buf(1024);
    while (std::fgets(buf.data(), buf.size(), fp)) {
        bool blank = true;
        for (char c : buf) {
            if (c == '\0') break;
            if (!std::isspace(static_cast<unsigned char>(c))) { blank = false; break; }
        }
        cnt += !blank;
    }
    std::fclose(fp);
    return cnt;
}
\end{lstlisting}

我们发现，上述代码和C代码几乎一模一样，逻辑完全没有变化，错误处理依然是靠返回值，资源管理依然是手动的\footnote{虽然ifstream是RAII的，但是这个风格太C}，编程方式也依然是相当面向过程的。

\subsubsection{C++11，2011}
\begin{lstlisting}[language=C++]
#include <fstream>
#include <string>
#include <algorithm>

std::size_t count_non_empty_lines(const std::string& path)
{
    std::ifstream ifs(path, std::ios::ate); // std::ios::ate表示打开文件后立即将读写位置移动到文件末尾，以便获取文件的大小。
    if (!ifs) return -1;

    std::size_t len = static_cast<std::size_t>(ifs.tellg()); // 获取文件大小
    ifs.seekg(0);   // 把读写位置移动到文件开头
    std::string content(len, '\0');
    ifs.read(content.data(), len); // 一次性读入文件内容

    std::size_t cnt = 0;
    std::string::iterator bg = content.begin(); // 迭代器指向字符串开头
    while (bg != content.end()) {
        auto nl = std::find(bg, content.end(), '\n');
        if (std::any_of(bg, nl,
               [](unsigned char c){ return !std::isspace(c); }))
            ++cnt;
        bg = (nl == content.end()) ? nl : nl + 1;
    }// 这段就是找行首和行尾，中间检查非空白字符
    return cnt;
}
\end{lstlisting}
这个代码的最大改进之处：
\begin{itemize}
  \item 一次性读入文件内容，避免逐行读取的系统调用开销；
  \item 使用了STL的算法 \texttt{std::find} 和 \texttt{std::any\_of} ，代码更简洁，几乎没有任何手动循环；
  \item 彻底的RAII，资源自动管理。
\end{itemize}


\subsubsection{C++17，2017}
\begin{lstlisting}[language=C++]
#include <fstream>
#include <string>
#include <optional>
#include <sstream>
#include <algorithm>

std::optional<std::string> slurp(const std::string& path)
{
    std::ifstream ifs(path, std::ios::binary | std::ios::ate);  // 以二进制模式打开文件，并将读写位置移动到文件末尾
    if (!ifs) return std::nullopt; // 打开失败，返回空的optional
    std::size_t n = ifs.tellg();
    ifs.seekg(0);
    std::string s(n, '\0');
    ifs.read(s.data(), n);
    return s;
}

std::size_t count_non_empty_lines(const std::string& path)
{
    auto content = slurp(path);
    if (!content) return -1;

    std::istringstream in(content.value()); // 字符串流
    return std::count_if(
        std::istreambuf_iterator<char>(in), // 输入流迭代器
        std::istreambuf_iterator<char>(),
        [&in](char) mutable // mutable允许修改捕获的变量
        {
            std::string line;
            std::getline(in, line);
            return !line.empty() &&
                   std::any_of(line.begin(), line.end(),
                               [](unsigned char c){ return !std::isspace(c); });
        });
}
\end{lstlisting}
和之前的代码相比，这段代码有以下改进：
\begin{itemize}
  \item 使用了optional（C++17）来处理可能失败的文件读取，更加语义化；
  \item 使用了 \texttt{std::istreambuf\_iterator} 来逐字符遍历输入流，避免了手动循环；
  \item 使用了 \texttt{std::count\_if} 来统计非空行数，代码更加简洁明了。
\end{itemize}

\subsubsection{C++20，2020}
\begin{lstlisting}[language=C++]
#include <fstream>
#include <sstream>
#include <string>
#include <optional>
#include <ranges>
#include <algorithm>

std::optional<std::string> slurp(const std::string& path)
{
    std::ifstream ifs(path, std::ios::binary | std::ios::ate);
    if (!ifs) return std::nullopt;
    auto n = ifs.tellg();
    ifs.seekg(0);
    std::string s(n, '\0');
    ifs.read(s.data(), n);
    return s;
}

std::size_t count_non_empty_lines(const std::string& path)
{
    auto content = slurp(path);
    if (!content) return -1;

    auto lines = std::views::split(content.value(), '\n') // 分割成行
               | std::views::filter([](auto&& line) { // 过滤这些行：
                   return !std::ranges::empty(line) && // 非空行
                          !std::ranges::all_of(line,    // 且不全是空白字符
                               [](unsigned char c){ return std::isspace(c); });
                 });
    return std::ranges::distance(lines); // 计算非空行数
}
\end{lstlisting}
这个风格更是极端：
\begin{itemize}
  \item 全程没有显式循环；
  \item 用管道操作符组合逻辑；
  \item 声明式风格；
  \item 类型安全，零拷贝。
\end{itemize}

我们看出，以上五段代码，虽然功能完全相同，但是风格和质量却有天壤之别，以C++11为显著分界线，区别主要有五：
\begin{itemize}
  \item 资源管理：从手动管理到C++11 RAII；
  \item 错误处理：从返回值检查到C++17 optional等类型；
  \item 算法和数据结构：从手动循环到C++11 STL算法和迭代器，再到C++20 ranges；
  \item 内存策略：从逐行读取到C++11 一次性slurp，再到C++20的零拷贝视图；
  \item 可读性和可组合性：从命令式到声明式。
\end{itemize}


\subsection{现代C++的思维方式}

如果一个代码出现了以下特征，那么它很可能是“C with STL”：
\begin{itemize}
  \item 使用裸指针和手动内存管理。
  \item 命令式、过程式，许多循环和条件判断。
  \item 缺乏抽象，没有利用面向对象的特性。
  \item 逻辑静态，重载一堆，难以复用。
  \item 忽略异常安全，在异常情况下容易导致资源泄漏。
\end{itemize}
而真正的现代 C++ 思维方式是其反面，从上到下分别对应着：
\begin{itemize}
  \item RAII；
  \item 面向对象，甚至多范式结合；
  \item 泛型编程；
  \item 元编程；
  \item 异常安全。
\end{itemize}

这些思想在C++11就能很好写出来，而后续两次大更新（C++17和C++20）则进一步提升了代码的简洁性和表达力，使得C++代码能够更加接近声明式编程的风格。比如说，我们即使是在C++11，也可以问自己以下问题：
\begin{itemize}
    \item RAII：有没有用智能指针、容器等自动管理资源？
    \item 泛型：有没有用模板、Lambda函数等泛型编程手段？
    \item STL：有没有坚持使用 \texttt{copy\_if} 、 \texttt{accumulate} 等STL算法代替手动循环？
    \item 异常安全：有没有考虑异常情况下的资源管理？（C++11只能自己写一个optional，但这玩意太好用了）
    \item 性能（尤其是拷贝）：有没有用 \texttt{std::move} 、完美转发、emplace等手段减少不必要的拷贝？
    \item 可读性：有没有用auto、范围for（感觉不如 \texttt{std::for\_each} ）等手段提升代码可读性？有没有用别名、命名空间等手段提升代码可维护性？
\end{itemize}

所以说，我们写代码的时候，尽可能利用C++的特性，把C++当成一种思维方式，而非仅用来抽象C的语法糖，这样才能写出真正的C++代码。

例如，现有一个vector，要求所有元素都加一，我们的第一反应是什么？我给出四行代码：
\begin{lstlisting}[language=C++]
for (size_t i = 0; i < vec.size(); ++i) vec[i] += 1;
for (auto& x : vec) x += 1;
std::for_each(vec.begin(), vec.end(), [](auto& x) { x += 1; });
std::ranges::for_each(vec, [](auto& x) { x += 1; });
\end{lstlisting}
这四行在功能乃至优化后的汇编上几乎等价，但是它们的思维方式却大相径庭。如果你的第一反应是后面三行当中的一个，那说明你的思维很现代C++化；如果是第一个，那说明你的思维模式还停留在古典C。

所以说，我们写代码的时候，尽可能利用 C++ 的特性，把 C++ 当成一种思维方式，而非仅用来抽象 C 的语法糖，这样才能写出\textbf{在当前约束下最优雅、最安全、可维护}的代码。

\section{否定之否定：FakeC++是否真正罪大恶极？}

\subsection{再回到实例}

任务依旧：把文件搬进内存，统计非空行数。依然是上述五段代码，但这一次请带着历史唯物主义的眼光看待它们，每一层都对应了当时主流编译器、标准库、硬件与工程组织的硬约束。

\subsubsection{C99，2000}

当时的约束是：没有RAII、没有异常，操作系统一次分配4kB页，文件IO系统调用开销较大，内存分配开销较大，代码必须一次性 \texttt{gcc -std=c99 -pedantic} 通过，要不然进不了仓库（当时甚至连Git都没有）。于是我们发现，代码也只能这么写。

\subsubsection{C++03，2003}

项目组确实刚刚同意G++也可以提交，但是审查规则依然是禁止模板和异常。老工程师对C++的唯一诉求仅仅是“自动释放内存”，所以大家都只用STL容器来替代C的malloc/free，其他的编程习惯和C几乎没有区别。

\subsubsection{C++11，2011}

我们看着一次性读入文件内容很爽，但是在当时很多老派程序员依然是反对这么搞的。能做到这些，有赖于硬件和操作系统的进步：内存带宽超过硬盘带宽，一次性读文件反而成了性能更好、代码更简单的双赢；编译器也开始支持auto、lambda表达式，STL算法等现代C++特性，且性能优化也足够好了，大家终于敢用这些新特性了。

\subsubsection{C++17，2017}

而此时的编译器发展：optiondal刚刚进标准，编译器对现代C++的解析也稳定下来。而且硬件也更强了，内存更大了，文件更大了，大家终于开始用字符串流来处理文件内容了。编译器对STL算法的优化也更好了，istreambuf\_iterator来逐字符遍历输入流也不是什么大问题了。

\subsubsection{C++20，2020}

现代的C++20，代码简洁到令人发指，完全没有显式循环，逻辑清晰到仿佛在写SQL查询语句——而这也因为硬件和软件约束的进一步放松：编译器对range的优化终于做到了“零抽象惩罚”，split 视图不产生额外内存。而对应的代码审查也要求“禁止手动循环”，否则就要被打回重写。

\subsection{启示}

如果我们能真正理解上述五段代码背后的历史背景和技术约束，我们就会发现两条有趣的曲线。

我们会发现一条单调递减的曲线：运行时开销，C99如果是100，那么C++11大概是60，C++20大概就只有10了。

而还有另一条单调递增的曲线：让编译器做的事。2000年，编译器仅负责帮你翻译成汇编；2011年，编译器开始帮你做内联、模板实例化、自动内存管理等；2020年，编译器甚至帮你做了零拷贝视图、管道优化等，临时对象几乎为0。

这两条曲线，Bjarne在1994年就已经预见到了：
\begin{quote}
    You don’t pay for what you don’t use, and what you do use you couldn’t hand-code any better.
\end{quote}
这就是C++的零开销抽象（Zero-Cost Abstraction）理念：抽象本身不应该带来额外的运行时开销，编译器应该能够把高层抽象优化成和手写低层代码一样高效的机器码。这句话立刻可以拆成三条原则：
\begin{itemize}
  \item 你不使用的特性，不会带来任何开销；
  \item 你使用的特性，编译器会帮你把它优化到和手写代码一样高效；
  \item 如果编译器做不到，那就是编译器的错，不是语言设计的错。
\end{itemize}
于是顺便带来了三条启示：
\begin{itemize}
  \item \textbf{先问约束，再选抽象}：嵌入式64KB RAM的环境，\texttt{ranges::distance} 还真就不如 \texttt{for (char c : container)} 高效；而云端128vCPU的大型服务，不写ranges反而成了性能瓶颈。
  \item \textbf{让错误尽早爆掉}：用optional、断言检查概念、用constexpr把运行时量变成编译时常量，都是让错误尽早爆掉的手段：如果能在编译期发现错误，就不要等到运行时才发现。
  \item \textbf{零拷贝是默认策略，拷贝必须有理由}：从slurp到字符串视图，从传值到传引用，本质上说的一个事：把数据移动降级成指针移动，除非profiler说“不行”，否则不要轻易拷贝数据。
\end{itemize}

\subsection{再回看 Fake C++}

于是，我们再把眼光放回到Fake C++中，或者C++03时代中的代码：\textbf{它们从来不是真正的 Fake C++，而是时代约束下的局部最优解}。

真正的原罪只有一条：\textbf{明明约束条件已经改变，但仍然抱残守缺、固步自封、把旧的局部最优当成新的全剧最优}。如果你维护的是老库，那 \texttt{vector<char>} 是好的，接着用；但你要是在2025年写新服务，却因为同样的理由拒绝用 \texttt{ranges} 甚至拒绝 \texttt{string}，那这就是问题了。

现代C++程序员的手里应该始终有一把锤子（Fake C++），但更应该有一整套电动工具（现代C++特性）。什么时候用锤子，什么时候用电钻，什么时候用激光切割机，全凭你对约束的理解和对工具的熟练程度；我们应该知道，从手写循环到ranges之间，每一级抽象背后的代价和收益；我们更应该知道，在当前需求、硬件、团队、编译器四维空间里，什么才是最优解。

把这两套工具永远对立起来，只会让我们停滞不前，错失良机；不管黑猫白猫，抓到老鼠就是好猫，只要能做到以上两点，不管你写的是20年前的 \texttt{getline}，还是20年后的 \texttt{std::views::split}，那都是真正的C++：因为你让编译器在当前约束下，帮你写出了最优雅、最安全、最可维护、代价最低的代码。

\section{解剖和验证：ranges 真的免费吗？}

在前文中，我们多次提到C++20的ranges特性能够实现“零开销抽象”，并且能够让代码更加简洁和易读。但是，ranges真的完全免费吗？它真的不会带来任何运行时开销吗？

\textbf{实践是检验真理的唯一标准}。为了验证ranges的性能，我们可以通过一个简单的实验来比较使用ranges和不使用ranges的代码在运行时的性能差异。这个我没办法带着同学们做，但是我给出一个实验方案，同学们可以在自己的机器上尝试。

\subsection{任务}

还是喜闻乐见的任务：读取一个大文件，统计其中非空行的数量（总行数约1亿行）。

控制变量：在同一台机器、同一个编译器和编译选项上测试， \texttt{-O0} 、 \texttt{-O2} 、 \texttt{-O3} 三种优化等级都测试。文件先mmap进内存，防止磁盘的IO干扰。

编译选项（以O3为例）：
\begin{lstlisting}
g++ -std=c++20 -O3 -march=native -DNDEBUG
\end{lstlisting}

写出四个版本的代码：
\begin{itemize}
    \item ranges+管道（真正零拷贝视图）；
    \item algorithm + stringview（部分零拷贝）；
    \item 裸指针 + 手动循环（完全手动）；
    \item STL迭代器 + 手动循环（STL风格）。
\end{itemize}

测试：用perf测量每个版本的cycles、branch-misses、cache-misses三个指标；总用时可以用cpp的chrono库测量，直接按日志打印出来；汇编行数，可以用 \texttt{objdump -d} 来查看；源代码行数，可以自己数一下。

对比上述结果，看看ranges版本和其他版本在性能上和代码简洁性上有什么差异。

\subsection{预期结果}

根据C++20的设计理念和编译器的优化能力，我预期结果如下：当内存够大时，在O3激进优化面前，ranges的零拷贝视图版本和充分优化的裸指针版本在性能上应该非常接近，差异可以忽略不计，估计不超过裸指针版本的2\%；而在代码简洁性上，ranges版本应该明显优于其他版本，代码行数和可读性都有显著提升。

因此，\textbf{只要你的约束里不包含‘调试器必须单步进最简汇编’或者‘编译器必须是 2017 年之前’，就请默认用 ranges；否则，perf 出现 2 \% 以上回退时再考虑降级。}

同学们也可以用实验验证我的上述断言。

\subsection{启示}

通过这个实验，我们可以得出以下启示：零开销从不是零成本，而是零“不必要的”成本。最终，管它是ranges还是手动写，perf才是唯一的裁判；只要在当前约束下，编译器能够把高层抽象优化成和手写低层代码一样高效的机器码，那这就是零开销抽象。


\section{C++中的一些良好实践}

在C++编程中，良好的代码风格可以提高代码的可读性，而遵守一些基本的编程规范则有助于减少错误和未定义行为。我在上述文本中已经提到过一些基本的代码规范。在这里，我将汇总并补充一些常见的代码规范和最佳实践，供大家参考。

\begin{itemize}
  \item 禁止使用 \texttt{\#include <bits/stdc++.h>} ：该头文件\textbf{非标准且不可移植}，包含不必要内容，增加编译时间，引入不可忍受的命名冲突和宏污染。
    \begin{lstlisting}[language=C++]
        #include <iostream>  // 只包含需要的头文件，是好的实践
        std::cout << "Hello, World!" << std::endl;

        #include <bits/stdc++.h>  // 绝对禁止
    \end{lstlisting}
  \item 减少使用 \texttt{using namespace std;} ：该语句会引入命名冲突，污染全局命名空间。严格禁止在头文件中使用，源文件应谨慎使用。
    \begin{lstlisting}[language=C++]
        using std::cout;  // 只引入需要的名称，是好的实践
        std::cout << ... // 直接使用std命名空间下的名称，也是好的实践

        using namespace std;  // 尽量避免使用
    \end{lstlisting}
  \item 声明即初始化 ：变量声明时应立即初始化，防止使用未初始化的变量。如果不知道初始化为什么可以零初始化。
    \begin{lstlisting}[language=C++]
        int x = 0; // 好的实践
        int x;     // 不推荐
    \end{lstlisting}
  \item 多用STL ：STL提供了丰富的容器和算法，使用STL可以显著的提高代码质量和可读性。
    \begin{lstlisting}[language=C++]
        std::array<int, 5> arr = {1, 2, 3, 4, 5}; // 好的实践
        int arr[5] = {1, 2, 3, 4, 5}; // 不推荐在C++中这么做，但C只能这么做
    \end{lstlisting}
  \item 强枚举替代传统枚举 ：使用 \texttt{enum class} 定义强枚举，防止命名冲突和隐式类型转换。
    \begin{lstlisting}[language=C++]
        enum class Color { RED, GREEN, BLUE }; // 好的实践
        Color c = Color::RED;

        enum Color { RED, GREEN, BLUE }; // 不推荐
        Color c = RED; // 可能引发命名冲突
    \end{lstlisting}
  \item 避免魔法数字 ：使用具名常量或强枚举来代替代码中的魔法数字，提高代码可读性和可维护性。
    \begin{lstlisting}[language=C++]
        case Status::SUCCESS: // 好的实践
        case 0: // 不推荐

        constexpr int MAX_SIZE = 100; // 好的实践
        for (int i = 0; i < MAX_SIZE; ++i) { ... }

        for (int i = 0; i < 100; ++i) { ... } // 不推荐
    \end{lstlisting}
  \item 多用 \texttt{const} ：对于不需要修改的变量，使用 \texttt{const} 修饰，防止意外修改。与之类似的是在函数传递引用的时候，如果不需要修改传入的对象，应该使用 \texttt{const T\&} 作为参数类型。
    \begin{lstlisting}[language=C++]
        const int MAX_SIZE = 100; // 好的实践
        int foo(const std::vector<int>& vec) { ... } // 如果不修改vec，这是好的实践

        int MAX_SIZE = 100; // 不推荐
        int foo(std::vector<int>& vec) { ... } // 如果不修改vec，不推荐
    \end{lstlisting}
  \item 小对象传值，大对象传引用 ：对于小型数据类型（如基本类型、 \texttt{std::pair} 、 \texttt{std::tuple} 等），传值通常很高效；对于大型数据类型（如 \texttt{std::vector} 、 \texttt{std::string} 等），传引用可以避免不必要的拷贝开销。
    \begin{lstlisting}[language=C++]
        int foo(int x) { ... } // 小对象传值
        void bar(const std::vector<int>& vec) { ... } // 大对象传引用

        int foo(int& x) { ... } // 不推荐，反而增加开销
        void bar(std::vector<int> vec) { ... } // 不推荐，拷贝开销巨大
    \end{lstlisting}
  \item 使用智能指针替代C风格指针：智能指针（如 \texttt{std::unique\_ptr} 和 \texttt{std::shared\_ptr} ）可以自动管理内存，防止内存泄漏和悬空指针。
    \begin{lstlisting}[language=C++]
        std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>(); // 好的实践
        // 使用ptr，无需手动释放内存

        MyClass* ptr = new MyClass(); // 不推荐
        delete ptr; // 容易忘记释放内存
    \end{lstlisting}
  \item 避免使用宏：宏缺乏类型检查，容易引发难以调试的错误。尽量使用 \texttt{const} 、 \texttt{inline} 函数或模板来替代宏。
    \begin{lstlisting}[language=C++]
        inline int square(int x) { return x * x; } // 好的实践
        const int MAX_SIZE = 100; // 好的实践
        #define SQUARE(x) ((x) * (x)) // 不推荐
        #define MAX_SIZE 100 // 不推荐
    \end{lstlisting}
  \item 尽量避免隐式类型转换：隐式类型转换可能导致数据丢失或未定义行为。使用显式类型转换（如 \texttt{static\_cast} ）来提高代码的可读性和安全性。
    \begin{lstlisting}[language=C++]
        int x = static_cast<int>(3.14); // 好的实践
        int x = 3.14; // 不推荐
    \end{lstlisting}
  \item 使用范围for循环：范围for循环（range-based for loop）可以简化对容器的遍历，提高代码的可读性。
    \begin{lstlisting}[language=C++]
        for (const auto& item : container) { // 好的实践
            // 使用item，你当然也可以把const去掉，视情况而定
        }

        for (size_t i = 0; i < container.size(); ++i) { // 不推荐
            auto& item = container[i];
            // 使用item
        }
    \end{lstlisting}
  \item 头文件自卫：在头文件中使用包含保护（include guards）或 \texttt{\#pragma once} 来防止重复包含，避免编译错误。虽然后者不是标准，但被几乎全部的现代编译器支持，工程上更简洁。
    \begin{lstlisting}[language=C++]
        #ifndef MY_HEADER_H  // 好的实践
        #define MY_HEADER_H

        // 头文件内容

        #endif // MY_HEADER_H

        // 或者使用
        #pragma once  // 好的实践
    \end{lstlisting}
\end{itemize}
