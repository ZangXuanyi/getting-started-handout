\documentclass[../main.tex]{subfiles}

\begin{document}

\chapter{正式踏入编程世界}

对于计算机小白而言，编程的世界可能会显得有些陌生和复杂。要想在这个世界中游刃有余，我们需要掌握的两个重要要素是\textbf{工具}和\textbf{环境}。

工具，指的是我们用来编写和运行程序的东西。包括语言、编辑器等。它们帮助我们更高效地达成我们的目标，例如调试程序、管理项目等。

环境，指的是我们编写和运行代码所依赖的操作系统、编程语言版本以及相关的库和框架。一个良好的编程环境可以大大提高我们的工作效率；同时，我们写出的代码，最终是也要运行在某个环境中的。编程语言本身就是为了让我们能够更方便地与计算机进行交流。

\section{编程语言初探}

\subsection{编程语言的发展简史}

编程语言的发展经历了几个重要阶段：

\begin{itemize}
  \item \textbf{机器语言}：最早的编程语言，直接与计算机硬件对应，使用二进制代码。最早的机器语言是通过拔插电缆实现的，是一个体力活，非常不便。后来改为采用打孔纸带的形式，但仍然非常繁琐和不直观。同时，对于不同的硬件架构，机器语言也不兼容，导致了可移植性差的问题。
  \item \textbf{汇编语言}：在机器语言基础上发展而来，引入了助记符，使得编程更加人性化。同时，汇编语言与特定的指令集相关联，这大大增强了其可移植性，但仍然需要对硬件有一定的了解。汇编语言虽然比机器语言更易读，但仍然需要手动管理内存和硬件资源。
  \item \textbf{高级语言}：高级语言的出现使得编程过程更像说话，而不是在机器上进行什么精确控制硬件的操作，显著增强了其可维护性和可读性；同时同一个高级语言在不同的硬件平台上只需要在对应系统上有一个编译器或解释器就可以运行，这也大大增强了其可移植性。高级语言可以分为两类：
    \begin{itemize}
      \item \textbf{编译型语言}：如C系语言，代码在运行前需要经过编译器转换为机器码，这样可以提高运行效率，但编译过程可能较慢。
      \item \textbf{解释型语言}：如Python，代码在运行时由解释器逐行解释执行，虽然运行速度可能较慢，但开发效率更高，调试更方便。
    \end{itemize}
\end{itemize}

现代的编程语言通常结合了编译型和解释型的优点，提供了更高的抽象层次和更丰富的功能库，使得编程变得更加高效和便捷。微软的.NET系就是一个典型的例子，它提供了一个统一的编程环境，支持多种语言，并且可以在不同的平台上运行。

\subsection{编程语言的特点和选择}

不同的编程语言往往有着自己的特点，选择合适的语言取决于项目需求和个人偏好。

一般情况下，涉及到底层硬件操作、性能要求高的项目，通常会选择编译型语言，如C/C++、Rust等。这些语言提供了对内存和硬件的直接控制，能够实现高效的性能优化；而对于快速开发、原型设计等任务，解释型语言如Python或JavaScript则更为合适。

除了这些通用性语言，还有一些语言能够对特定内容进行极好的支持，例如C\#用于游戏开发，LaTeX用于排版，SQL用于数据库查询，MATLAB用于科学计算和数据分析，R用于统计分析等。这些语言通常在特定领域内有着广泛的应用。

不过归根结底，编程语言只是工具。初学者在学习编程的时候，更应该关注的是编程的思想和方法，而不是具体的编程语言。每一门语言都有自己的长处和缺点，在实际使用的时候应该具体情况具体应对。

\section{编程环境的搭建}

编程环境的搭建是编程的第一步。一个良好的编程环境可以大大提高我们的工作效率。

在搭建编程环境之前，我们应当先认识“环境变量”，它是操作系统中存储的变量，用于配置程序运行环境。环境变量可以影响程序的行为，例如指定编译器的路径、设置库文件的搜索路径等。

\begin{tip}
  \textbf{系统，尤其是Windows系统是一个很玄学的玩意}，有时候需要重启计算机（或者终端）才能使环境变量生效，有时候则不需要。
\end{tip}

\begin{note}
  下文经常提到的一个东西“环境变量”是操作系统的重要变量\texttt{PATH}。该变量存储了一系列路径，当用户在命令行中输入一个命令时，操作系统会在这些路径中查找对应的可执行文件。如果找到了，就会运行该文件，否则会提示“命令未找到”之类的错误。因此，在安装编译器、解释器等工具时，通常需要将它们的安装路径添加到\texttt{PATH}变量中，以便在任何位置都能使用这些工具。否则，每次输入命令时都要指定完整路径，极其不便。
\end{note}

\subsection{C系编译器及其环境配置}\label{sec:c-install}

对于C语言，有三个最常见的编译器：GCC、Clang和MSVC。它们各有特点，但都能满足大部分初学者的C语言开发的需求。这些编译器通常会与特定的C标准库实现（如GNU的libstdc++、LLVM的libc++或Microsoft的MSVC CRT）配合使用，不同的标准库之间存在细微差异。我们一般建议在Linux上使用GCC，而在Mac上推荐使用Clang。MSVC工具链在Windows上非常流行，但是不跨平台且为闭源软件，有部分程序员可能因此不愿意使用。

Linux和Mac用户可以通过包管理器安装特定的编译器，在暑假课程的《包管理器》一节有讲授，这里不再赘述。

对于Windows用户，有两种方式获得这一编译器：如使用MSVC，则直接下载Visual Studio并安装C++开发模块即可，Visual Studio内置了MSVC工具链；如果使用GCC，则需要通过其他渠道。比起手动下载和配置GCC，我更推荐使用MSYS2或者Cygwin来安装GCC。它们提供了一个完整的UNIX环境，免去了在Windows上配置编译器的麻烦。

你需要在\href{https://www.msys2.org/}{MSYS2官网}下载最新的安装包，并按照官网的说明进行安装。安装完成后，你可以通过MSYS2的包管理器pacman来安装GCC。

鉴于国内网络环境，我在这里贴出本人在北大网盘的MSYS2存档\footnote{如失效，务必联系管理员}：\href{https://disk.pku.edu.cn/link/AADF534C03FA714DC982607A17BEF8A178}{msys2-x86}，不能访问MSYS2官网或者下载缓慢的可以使用这个下载对应版本的MSYS2。另外，也可以使用其他手段（例如清华源等）来下载MSYS2的安装文件。

你可以在MSYS2终端中运行以下命令来安装GCC和GDB（建议使用UCRT64终端，不建议使用逐渐失去支持的32位以及MINGW64环境，也不建议新手使用CLANG64环境，该环境完全使用Clang代替GCC）：

\begin{lstlisting}[language=bash]
pacman -S mingw-w64-ucrt-x86_64-gcc
pacman -S mingw-w64-ucrt-x86_64-gdb
\end{lstlisting}

在MSYS2中安装完成后，用户如果想要在Windows终端中使用GCC，则需要设置环境变量，以便在命令行中直接使用编译器命令。

一般情况下，用户需要将MSYS2的bin目录添加到系统的PATH环境变量中。具体步骤如下：

\begin{itemize}
  \item 找到MSYS2的安装目录，通常是\texttt{C:\textbackslash msys64}。
  \item 将\texttt{C:\textbackslash msys64\textbackslash ucrt64\textbackslash bin}添加到系统的PATH环境变量中。（请按照你的实际安装路径进行调整，下同）
  \item 在PowerShell或者CMD中运行以下命令来验证是否配置成功：\texttt{gcc --version}。如果输出了GCC的版本信息，则说明配置成功。
  \item 需要在Windows的PowerShell或者CMD中运行POSIX风格工具时，也可以将下列路径也添加到用户的PATH环境变量中：\texttt{C:\textbackslash msys64\textbackslash usr\textbackslash bin}。但这样具有环境冲突风险，需要注意保证该变量的查找顺序在比ucrt64的bin目录更靠后，以避免冲突。
\end{itemize}

\begin{caution}
  有的同学可能不是按照上述推荐的方式安装GCC的，而是通过其他方式（例如直接下载预编译版本）安装的GCC。如果是这种情况，务必记住GCC和非ASCII字符是死敌，因此请不要将GCC安装在包含非ASCII字符（如汉字、空格）的路径下！（最大的坑可能是你的用户名中包含非ASCII字符，例如汉字！）
\end{caution}

\subsection{Python、虚拟环境及其配置}\label{sec:virtualenv}

如果仅仅是安装Python，那可比安装C系编译器简单得多了，直接去官网上下载就行了，只要记得安装时勾选“添加到Path”就行了。然而，这样安装会有一个问题：会将Python安装到全局环境中。

Python作为一门流行的编程语言，拥有丰富的第三方库和框架，可以帮助我们快速实现各种功能，并不需要从零开始开发，第三方库的安装和管理是必然是开发中非常重要的一部分。而不同的开发往往需要不同的包，或者同一个包的不同版本。这些包有可能会产生冲突，如果用全局环境则会导致依赖混乱。这时，我们引入了虚拟环境，它是解决包冲突的有效手段。

虚拟环境可以理解为一个单独的沙盒，包含了特定版本的编译器、解释器和所有依赖的包。用户可以在虚拟环境中自由安装和管理包，而不会影响全局的Python环境，更不会影响其他沙盒。一般有以下几种方法创建虚拟环境：
\begin{itemize}
  \item \textbf{venv}：Python内置的虚拟环境模块，适用于大多数场景。
  \item \textbf{virtualenv}：一个第三方库，提供了更多的功能和灵活性。
  \item \textbf{conda}：Anaconda发行版提供的虚拟环境管理工具，非常简洁高效，逐渐成为目前开发的主流选择。
  \item \textbf{docker}：容器化技术，可以将应用及其所有依赖打包在一个容器中，适用于生产环境，但是由于比较复杂、笨重、资源开销大，一般不推荐用于开发环境。
\end{itemize}

对于学生一般使用的是conda，或者其衍生高速版本mamba。我们的讲述也是以conda为主。

conda有两个发行版，一个是Anaconda，另一个是Miniconda。Anaconda包含了大量的预装包，适合初学者和数据科学家使用；而Miniconda则是一个轻量级的发行版，只包含conda和Python，适合需要自定义环境的用户。我们非常建议使用Miniconda，因为它更轻量，安装速度更快，并且可以根据需要安装所需的包。

以上两个发行版在Linux和Winget上都难以利用包管理器进行安装。因此，我们一般都是直接从官网下载对应的安装包进行安装。安装完成后，用户需要设置环境变量，以便在命令行中直接使用conda命令。

接下来，因为一些原因，我们应当重启计算机（或者终端），以确保环境变量生效。

然后，我们需要进行终端初始化，例如在Windows上，我们可以使用以下命令：
\begin{lstlisting}[language=bash]
    conda init powershell
\end{lstlisting}

你应该将上述命令替换为你所使用的终端类型，例如在Linux上可以使用\texttt{bash}或\texttt{zsh}。然后你需要重启终端，以使初始化生效。

我们可以创建一个新的虚拟环境，例如：
\begin{lstlisting}[language=bash]
    conda create -n myenv python=3.10
\end{lstlisting}
这样就可以创建一个名为\texttt{myenv}的虚拟环境，并安装Python 3.10的尽可能新的版本。

下面我们需要激活虚拟环境：
\begin{lstlisting}[language=bash]
    conda activate myenv
\end{lstlisting}
这样就进入了虚拟环境，你可以在终端上看到提示符前面有\texttt{(myenv)}，表示当前处于\texttt{myenv}虚拟环境中。如没有，可能是终端配置失败或者其他原因，安装OhMyPosh的部分主题也可能会导致这个问题（最大的可能是你的主题没有Python虚拟环境对应的section）。

现在在Python中我们一般流行使用\texttt{pip}来安装包，它从PyPI安装和管理第三方库。现在不流行直接使用conda管理包了。

我们可以使用以下命令安装一个包，例如安装\texttt{NumPy}库：
\begin{lstlisting}[language=bash]
    pip install numpy
\end{lstlisting}
这将会在当前虚拟环境中安装NumPy库，而不会影响全局的Python环境。

如果你需要安装多个包，可以将它们写在一个文件中，例如\texttt{requirements.txt}，然后使用以下命令安装：
\begin{lstlisting}[language=bash]
    pip install -r requirements.txt
\end{lstlisting}
以上命令也常用于项目的依赖管理，可以方便地安装和更新项目所需的所有包；同时也可以通过修改\texttt{requirements.txt}文件来管理项目的依赖版本，适宜分发。

\subsection{rust环境搭建}

由于rust工具链依旧依赖着c的工具链，所以在安装rust的工具链前，你应该先安装c的工具链，如MSVC、GCC、Clang等（在win上你应该安装MSVC环境,详情见\ref{sec:c-install}）。

我们将会使用rustup来安装rust工具链。

由于众所周知的原因，在安装前你应该换源，如中科大镜像站。在win上请搜索"环境变量"，在"系统环境变量"处点击"新建"，将如下环境变量添加至系统环境变量中。

\begin{lstlisting}
  变量名             变量值
  RUSTUP_DIST_SERVER https://mirrors.ustc.edu.cn/rust-static
  RUSTUP_UPDATE_ROOT https://mirrors.ustc.edu.cn/rust-static/rustup
\end{lstlisting}

\href{https://rustup.rs}{rustup下载}后，就可以点击rustup-init.exe安装了。

在linux上换源方式：将以下设置环境变量的命令放在\texttt{\textasciitilde/.zshrc}里（如果你的终端是其他终端，则按实际情况改为\texttt{\textasciitilde/.bashrc}或者其他的什么东西）。

\begin{lstlisting}[language=bash]
  export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static
  export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup
\end{lstlisting}

然后执行官方脚本来下载rust。

\begin{lstlisting}[language=bash]
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
\end{lstlisting}

\subsection{go环境搭建}

请去\href{https://go.dev/doc/install}{官网下载页面}下载适用于你操作系统的安装包/压缩包。

对于win和mac均是一键安装，对于linux请执行以下命令

\begin{lstlisting}[language=bash]
  sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf go1.24.5.linux-amd64.tar.gz
  # 此命令将会删除以前下载的go，并将你下载的压缩包解压并拷贝至/usr/local下（注意将其替换为压缩包的真实路径）
  export PATH=$PATH:/usr/local/go/bin
  # 这行命令建议手动加入~/.zshrc或~/.bashrc，以使环境变量在所有终端生效（说人话：让终端能找到你的go在哪）
  go version
  # 验证go的版本
\end{lstlisting}

\section{选择合适的IDE}

IDE（集成开发环境）或者文本编辑器是编程的核心工具之一，用于编写代码、调试和测试等功能。选择合适的IDE或编辑器可以提高编程效率和代码质量。

聪明的懒人宁可使用一天时间来把环境配好来节省以后的时间用来摸鱼，而不是天天花时间来鼓捣环境。

\subsection{选择编辑器}

最Geek的一批程序员最喜欢使用命令行编辑器，例如VIM、Emacs、NeoVim等。这些编辑器通常具有强大的功能和高度的可定制性，适合喜欢命令行操作和自定义配置的用户。但是这些编辑器的使用难度极高，学习曲线陡峭，对于初学者来说极不友好。技术人中有一个非常著名的笑话：“怎么生成一段随机的字符串？答：只需要让不会用VIM的人试着退出VIM就可以了！”

\begin{tip}
  退出VIM的命令是\texttt{:q}，如果你在编辑器中输入了内容并且想要保存，可以使用\texttt{:wq}命令；如果你不想保存，可以使用\texttt{:q!}命令强制退出。纵然如此，我个人还是建议同学们学着使用一下vim这个经典TUI编辑器，这是因为在将来的开发中，我们或多或少都会面对一些情况：不得不从远端登录某机器，且这个机器甚至还不能安装一些诸如nano的更现代的编辑器！
\end{tip}

正课一般推荐以下的几个IDE：C++ IDE是Visual Studio和DevC++，Python IDE是PyCharm。它们各有各的优势，并且有一个最大的共同点：开箱即用，用户并不需要复杂的配置来进行编程。

但是它们的缺点非常明显：Visual Studio（一般简称VS）和PyCharm都非常臃肿，尤其是前者如果安装全家桶需要大量的磁盘空间和内存资源。同时，它们更注重于超大型项目的开发，这一“超大”往往动辄涉及数十万甚至上百万行代码，我们日常学习使用的代码量远远达不到这个级别，只能说是“杀鸡焉用牛刀”。VS的另一个缺点是它实际上专精于Windows平台和微软的.NET生态系统，虽然它也支持C++和Python等语言，但很笨重。至于DevC++，它的功能少得可怜且只支持C/C++。虽然比较适合初学者，但扩展性极差，完全无法满足更复杂的开发需求。

\begin{note}
  Visual Studio 把一个工作目录视为一个“项目”，当用户使用编译功能时会把整个项目编译一遍。而在同一个项目中，不能同时存在多个同名的变量和函数，因此即使我们在VS中新建了不同的C++文件且他们在逻辑上并无任何关联，但是VS依然会把它们视为同一个项目的一部分，从而导致命名冲突的问题。对于初学者来说，这无疑是一个巨大的坑，往往表现为“我这个\texttt{main}函数怎么出现了重定义的错误？”。

  另外，VS出于安全性考量，禁用了C系的一部分函数，例如\texttt{printf}。当我们试图对这些函数进行调用时，VS会报错并提示我们使用更安全的版本，例如\texttt{printf\_s}。这无疑给初学者带来了不必要的困扰。当然这个困扰并非不能解决，只需要在文件开头定义宏\texttt{\#define \_CRT\_SECURE\_NO\_WARNINGS}即可，但这无疑增加了学习的难度。另外，\texttt{printf\_s}等并不是标准函数，这会导致代码的可移植性变差。

  综上所述，我非常建议新手远离VS，即使是简陋的DevC++也比VS强。每一年都会有大量的同学因为使用VS而陷入困境，浪费了大量的时间和精力。
\end{note}

因此，我并不推荐初学阶段就使用这些IDE。从长远来看，使用更加通用的编辑器会更有利于你在编程世界中游刃有余。我们强烈推荐同学们使用Visual Studio Code（VS Code，或者直接说Code）完成大多数的任务。它是一款轻量级的编辑器，具有良好的扩展性和社区支持，可以满足不同用户的需求。VS Code支持多种编程语言，并且有丰富的插件生态系统，可以根据需要安装各种插件来增强功能。它同时也为调试和版本控制功能添加了GUI，非常适合初学者和中小型项目开发者使用。

除此之外，还有一些语言仅在特定的编辑器中有很好的支持，例如C\#之于Visual Studio，SQL之于DBeaver和DataGrip，Java之于Eclipse等。这些语言通常需要特定的IDE来提供更好的支持和功能，此时再去使用VS Code反而可能会有些不便。

\subsection{安装VS Code}

我们应该上官网下载安装包进行安装。我们需要安装的是System Installer版本，而不是User Installer版本。因为User Installer版本会将VS Code安装在用户目录下，而System Installer版本会将VS Code安装在系统目录下，这样可以方便地在所有用户之间共享VS Code，并且能够把它直接放在环境变量中。

在安装之前，我们应当确定自己计算机的CPU架构是x86-64还是arm64。在Windows系统下，我们可以使用\texttt{systeminfo}指令来查看系统信息，或者右键点击“此电脑”选择“属性”来查看系统类型。在官网上下载的Code架构应当和操作系统的架构一致。

安装完成后，我们需要设置环境变量，以便在命令行中直接使用code命令。不过如果你在安装时选择了“Add to PATH”选项，则不需要手动设置环境变量。

\subsection{配置VS Code}

VS Code是一个非常灵活的编辑器，可以通过安装插件来增强其功能。我们可以在不同的工作区（可以简单地理解为工作用文件夹）启用和禁用不同的插件，以实现其高度可定制特性。常用的插件包括：

\begin{itemize}
  \item \textbf{Python}：提供对Python的支持，包括语法高亮、代码补全、调试等功能。
  \item \textbf{C/C++}：提供对C/C++的支持，包括语法高亮、代码补全、调试等功能。
  \item \textbf{GitLens}：增强版的Git支持，可以更好地查看版本历史和代码变更。
  \item \textbf{Chinese (Simplified) Language Pack for Visual Studio Code}：提供中文界面支持。
\end{itemize}

此外，VS Code还支持多种主题和图标包，可以根据个人喜好进行定制。你可以在VS Code的插件市场中搜索并安装这些插件和主题等。

\subsubsection{在VS Code中配置C/C++}\label{sec:configure-cpp}

如果你使用的是GCC编译器，则需要在VS Code中配置GCC，以便能够编译和运行C/C++代码。可以通过以下步骤进行配置：

\begin{enumerate}
  \item 安装C/C++插件：在VS Code的插件市场中搜索并安装C/C++插件。建议直接安装微软提供的全家桶。
  \item 配置tasks.json文件：在VS Code中创建一个C++文件\texttt{*.cpp}或者\texttt{*.cc}，然后随便输入一些什么代码，然后编译之。首次编译C++代码时，VS Code会提示你创建一个\texttt{tasks.json}文件。选择“C/C++: g++.exe 生成活动文件”，这将会在项目根目录下创建一个\texttt{.vscode/tasks.json}文件。（如果你创建的是C文件\texttt{*.c}，那么你可以选择“C/C++: gcc.exe 生成活动文件”）
  \item 配置launch.json文件：在VS Code中按下\texttt{F5}，选择“C++ (GDB/LLDB)”，然后选择“g++.exe build and debug active file”。这将会在项目根目录下创建一个\texttt{launch.json}文件。（如果没有后一步，可以忽略之。）
\end{enumerate}

如果你并不信任自动生成的配置文件或者需要更多的功能（例如开\texttt{-O2}优化），可以手动创建并修改\texttt{tasks.json}和\texttt{launch.json}文件。这两个文件都应该放在项目根目录下的\texttt{.vscode}文件夹中。

以下是一个简单的\texttt{tasks.json}文件示例（其实就是上面自动生成的那个，按照笔者的计算机环境稍微改了改）：

\begin{lstlisting}
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "C/C++: g++.exe 生成活动文件",
      "type": "shell",
      "command": "g++",
      "args": [
        "-g",
        "${file}",
        "-O3",
        "-o",
        "${fileDirname}\\${fileBasenameNoExtension}.exe"
      ],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "problemMatcher": ["$gcc"],
      "detail": "生成活动文件"
    }
  ]
}
\end{lstlisting}

以下是一个简单的\texttt{launch.json}文件示例：

\begin{lstlisting}
{
  "version": "0.2.0",
  "configurations": [
      {
          "name": "C++ Launch",
          "type": "cppdbg",
          "request": "launch",
          "program": "${fileDirname}\\${fileBasenameNoExtension}.exe",
          "args": [],
          "stopAtEntry": false,
          "cwd": "${workspaceFolder}",
          "environment": [],
          "externalConsole": false,
          "MIMode": "gdb",
          "setupCommands": [
              {
                  "description": "Enable pretty-printing for gdb",
                  "text": "-enable-pretty-printing",
                  "ignoreFailures": true
              }
          ],
          "preLaunchTask": "C/C++: g++.exe 生成活动文件",
          "miDebuggerPath": "C:\\msys64\\ucrt64\\bin\\gdb.exe"
      }
  ]
}
\end{lstlisting}

如不想用JSON文件进行配置，我们还可以使用UI配置相关功能。

在Code中按下\texttt{Ctrl + Shift + P}，找到“C/C++: Edit Configurations (UI)”选项。这样就可以通过图形界面来配置C/C++的编译和调试选项。

一般地，我们需要更改以下内容：
\begin{itemize}
  \item 配置名称：默认即可。
  \item 编译器路径：选择你要选用的编译器的路径。该选项一般会自动检测电脑上的编译器。
  \item 编译器参数：留空即可。如需要，可以添加一个\texttt{-O2}或者\texttt{-O3}来开启编译优化，或者添加一个\texttt{-g}来开启调试信息。但是，\texttt{-g}会严重拖慢编译速度，因此建议只在调试时开启。
  \item IntelliSense模式：根据你的系统、编译器、CPU架构选择对应的模式。该选项会为你打开对应的代码补全、语法高亮、错误警示功能。
  \item 包含路径：不用动。
  \item 定义：不用动。
  \item C/C++标准：建议C17和C++17，和PKU线上代码检查的标准一致。其他学校的学生按自己的学校要求来设置，例如14或11。
  \item 高级：一个都不用动。
\end{itemize}

调试配置没有UI配置选项，我们还得老老实实地手动编辑\texttt{launch.json}文件。当然默认调试已经够了，如果你不需要更复杂的调试功能，完全可以不修改。

如果你确实做了这些事情，但是你的VS Code仍然无法编译和调试C/C++代码，那么你可能需要检查以下几点：
\begin{itemize}
  \item 使用\texttt{where g++}命令来确定你的编译器是不是在PATH环境变量中，另外你还需要确定上述识别出的编译器是不是你想用的那个。
  \item 检查你的C++目录和编译器目录是否包含非ASCII字符（如汉字、空格等）。
  \item 检查你是不是错误地使用了\texttt{gcc}来编译C++代码。C++代码需要使用\texttt{g++}来编译，而不是\texttt{gcc}。
  \item 检查你的包含路径是否正确。VS Code会自动检测你的编译器和标准库，但如果你使用了自定义的路径或者安装了多个版本的编译器，可能需要手动配置包含路径。
  \item 检查你改的几个配置文件是不是正确的配置文件。
\end{itemize}
一般情况下，修正的方法很简单：如果是环境变量、路径等问题，重新设置就可以；如果是配置文件问题，杀掉当前所有终端，删除\texttt{.vscode}文件夹，然后重新编译调试就可以了。

另外，如果希望使用Code的插件来帮助你编译并运行C/C++代码，则需要打开一个工作文件夹。否则，插件无法为你提供编译和运行的功能。当然，\lstinline[language=bash]|g++ main.cpp -o main.exe && ./main.exe|也并非不可。

\subsubsection{在VS Code中配置Python}

在VS Code中配置Python非常简单。只需要安装微软提供的三个Python插件，然后在VS Code中打开一个Python文件。

你会在右下角看到一个黄色按钮“选择Python解释器”，点击它可以选择你想要使用的Python解释器。一般情况下，你可以选择“Python 3.x (conda)”或者“Python 3.x (venv)”等选项，这样VS Code就会自动识别你当前的虚拟环境。

当然，我们非常建议同学们趁早熟悉纯命令行运行Python的方式，例如\texttt{python main.py}，这样可以更好地理解Python的运行机制，同时也更便于调试（？）。

\subsubsection{在VS Code中配置Rust}

在VS Code中配置Rust比较简单，只需要下载\texttt{rust-analyzer}插件即可。然后用VS Code打开一个空文件夹，打开VS Code的终端（快捷键：\texttt{Ctrl + `}）,\texttt{cargo init} 初始化当前的空文件夹。然后在\texttt{src/main.rs}里即可看到\texttt{main}函数的上方有着运行和调试的符号，点击即可运行或调试。

\begin{caution}
  初始化后，文件夹下应有着\texttt{Cargo.toml}，否则便无法为其提供运行的功能，因为运行是依赖于\texttt{cargo}的。初学者往往会急于创建\texttt{main.rs}而没有用\texttt{cargo init}或\texttt{cargo new dir}来初始化文件夹，然后就会发现\texttt{rust-analyzer}报错\texttt{Failed to discover workspace. Consider adding the Cargo.toml of the workspace to the linkedProjects setting.}
\end{caution}

为了便于调试，我们下载\texttt{codelldb}插件，之后按F5就可以开始调试了。

\subsubsection{在VS Code中配置Go}

安装\texttt{golang.go}插件。然后在终端执行如下命令。（如果你有着足够“好”的网络，那可以不用设置\texttt{GOPROXY}）

\begin{lstlisting}[language=bash]
  go env -w GO111MODULE=on # 启用 Go Modules 功能
  go env -w GOPROXY=https://goproxy.cn,direct # 配置代理
  # go env | grep GOPROXY # linux 确认配置
  # go env |findstr "GOPROXY" # windows 确认配置
\end{lstlisting}

下载\texttt{go tools}：\texttt{Ctrl+Shift+P}打开命令面板输入\texttt{Go: Install/Update Tools}，选择所有并确定，这将会下载\texttt{go tools}。

新建文件夹，用\texttt{VS Code}打开此文件夹，新建\texttt{main.go}文件，\texttt{Ctrl + `} 打开终端，输入\texttt{go mod init helloworld}，编辑\texttt{main.go}

\begin{lstlisting}[language=go]
package main

import (
  "fmt"
)

func main() {
  name := "Go Developers"
  hello := "hello world"
  fmt.Println("Azure for", name, hello)
  hello_world()
}
\end{lstlisting}

按F5即可调试。

\begin{note}
  现在Go使用\texttt{go module} 管理依赖，也就是\texttt{go.mod}文件。现在推荐这么做，有些项目可能还在用\texttt{Go Path}来管理，同学遇到了此种项目可自行搜集资料。
\end{note}

有同学可能发现了，调试的时候并没有输出可执行文件。输出可执行文件：\texttt{go build -o main.exe main.go}, \texttt{-o}选项可以指定可执行文件的名字。如果是多文件编译呢？假设源代码均位于src目录下，\texttt{go build src/*.go}。同学们也可了解一下如何交叉编译。

\subsubsection{在VS Code中配置Git}

在VS Code中配置Git同样非常简单。只需要安装Git，并确保Git的可执行文件在系统的PATH环境变量中。然后在VS Code中打开一个Git仓库，VS Code会自动识别并启用Git功能。

\section{美化你的终端}

在Windows上，默认的终端是cmd或者PowerShell，它们的界面比较简陋，不能显示很多信息。为了让终端更美观、更实用，我们可以使用一些终端美化工具，这里我推荐使用\textbf{Oh My Posh}。

\subsection{安装Oh My Posh}

\begin{tip}
  在配置Oh My Posh的时候，很多的命令涉及到执行脚本。默认情况下，Windows PowerShell会阻止执行脚本以保护系统安全。因此，你需要先修改执行策略来允许执行脚本。在PowerShell中运行以下命令：
\begin{lstlisting}[language=bash]
  Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
\end{lstlisting}
  就可以允许当前用户执行远程签名的脚本。
\end{tip}

我们建议使用winget来安装Oh My Posh。你可以在PowerShell中运行以下命令来安装：

\begin{lstlisting}[language=bash]
  winget install JanDeDobbeleer.OhMyPosh
\end{lstlisting}

安装完成后，你需要在PowerShell中运行以下命令来初始化Oh My Posh：
\begin{lstlisting}[language=bash]
  oh-my-posh init pwsh
\end{lstlisting}

如果你使用的是其他终端，例如cmd，你可以在Oh My Posh的\href{https://ohmyposh.dev/docs/installation}{安装文档}中找到相应的安装方法。

\subsection{配置Oh My Posh}

首先，你应该安装OMP推荐使用的字体，例如Nerd Font。这是因为Oh My Posh使用了一些特殊的图标，如果没有合适的字体，可能会导致图标无法正常显示。

你可以在\href{https://www.nerdfonts.com/}{Nerd Fonts官网}下载最新的字体包。安装完成后，你需要在终端中设置字体为Nerd Font，以便能够正确显示Oh My Posh的图标。另一个办法是利用OhMyPosh安装这个字体：
\begin{lstlisting}[language=bash]
  oh-my-posh font install meslo
\end{lstlisting}

安装完成后，你需要在终端中设置字体为Nerd Font。以PowerShell为例，你可以右键点击窗口标题栏，选择“属性”，然后在“字体”选项卡中选择Nerd Font即可。

为了保证Oh My Posh在每次启动PowerShell时都能自动加载，你需要将初始化命令添加到PowerShell的配置文件中。你可以在PowerShell中运行以下命令来打开配置文件：
\begin{lstlisting}[language=bash]
  notepad $PROFILE
\end{lstlisting}

然后在文件的末尾添加以下内容，并重新启动终端：
\begin{lstlisting}[language=bash]
  oh-my-posh init pwsh | Invoke-Expression
\end{lstlisting}

接下来，你可以在PowerShell中运行命令来设置Oh My Posh的主题了。主题及其安装方法可以在Oh My Posh的\href{https://ohmyposh.dev/docs/themes}{主题文档}中找到。

\subsection{在VS Code中配置终端}

VS Code内置了终端功能，可以方便地在编辑器中运行命令。终端默认使用系统的命令行工具，例如在Windows上是cmd，在Linux上是bash。

你可以通过快捷键\texttt{Ctrl + `}（反引号）打开终端，也可以通过菜单\texttt{视图 > 终端}来打开。终端打开后，你可以在其中输入命令，和在普通命令行中一样。

如果你希望在VS Code中使用Oh My Posh，只需要把Code的终端字体设置为Nerd Font即可。你可以在VS Code的设置中搜索\texttt{terminal.integrated.fontFamily}，然后将其值设置为你安装的Nerd Font的名称，例如\texttt{MesloLGS Nerd Font}。

\section{编写程序的基本素养}

做了这么多操作，我们终于可以编写第一个能跑的程序了。我们将使用C++和Python两个语言来演示怎么书写第一个程序，同时告诉大家编程新手应有的素养。

\subsection{编写你的第一个程序}

由于众所周知的原因，我们的第一个程序通常是“Hello, World!”程序。它的作用是让我们熟悉编程语言的基本语法和编译运行流程，同时也是一个传统。而第二个程序一般往往是写一个加法，让我们熟悉输入输出的基本操作。

\subsubsection{C++}

对于C++，我们可以使用以下代码来编写第一个程序。你可以在VS Code中创建一个新的C++文件，例如\texttt{hello.cpp}（\textbf{该文件的路径不能包含空格和中文！}），然后输入以下代码：

\begin{lstlisting}[language=C++]
#include <iostream>
int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
\end{lstlisting}

然后如果配置得当，我们就可以通过按下F5键来编译并运行这个程序了。VS Code会自动调用编译器进行编译，并在终端中显示输出结果。如果一切顺利，你应该会看到“Hello, World!”的输出。

在一些极端情况下（例如无GUI环境），你可能需要手动编译和运行程序。可以使用以下命令来编译和运行程序：

\begin{lstlisting}[language=bash]
g++ -o hello hello.cpp
./hello
\end{lstlisting}

请使用类似的方式\textbf{手敲}、编译、运行以下代码：

\begin{lstlisting}[language=C++]
#include <iostream>
int main() {
    int a, b;
    std::cout << "Enter the first integer: ";
    std::cin >> a;
    std::cout << "Enter the second integer: ";
    std::cin >> b;
    std::cout << "Their sum is: " << a + b << std::endl;
    return 0;
}
\end{lstlisting}

\subsubsection{Python}

对于Python，我们同样可以使用以下代码来编写第一个程序：

\begin{lstlisting}[language=Python]
print("Hello, World!")
\end{lstlisting}

同样，如果配置得当，我们就可以通过按下F5键来运行这个程序了。VS Code会自动调用Python解释器运行，并在终端中显示输出结果。同样的，如果希望使用命令行来运行程序，可以使用以下命令：

\begin{lstlisting}[language=bash]
python hello.py
\end{lstlisting}

请使用类似的方式\textbf{手敲}、编译、运行以下代码：

\begin{lstlisting}[language=Python]
a = int(input("Enter the first integer: "))
b = int(input("Enter the second integer: "))
print("Their sum is:", a + b)
\end{lstlisting}

\subsubsection{这两个语言有什么区别？}

可以看到，使用命令行来执行程序的方式有所不同：C++需要两步，但是Python只需要一步。这是因为C++是编译型语言，需要先将源代码编译成可执行文件，然后再运行；而Python是解释型语言，直接运行源代码即可。前者的好处是，一份需要被反复运行的代码只需要编译一次，之后可以反复高效率运行。而后者的好处是，代码修改后可以立即运行，但是需要反复解释执行，运行速度（相对的）非常缓慢。

另一个区别是，C++中，我们可以看到定义a和b之前需要先声明它们的类型，而Python中则不需要。这说明，C++是强类型语言，变量的类型在编译时就确定了；而Python是动态类型语言，变量的类型在运行时才确定。

而这也导致了一个问题：编译器可以识别全部的语法错误和部分的语义错误，因此一份能够编译通过的C++代码，通常代码本身是正确的，但是算法可能因为极端数据出现错误，例如除零等；而Python则无法检查语法错误和语义错误，解释器只会在按顺序运行代码，直到在出现问题的的地方停止。Python 自身的动态类型系统与缺少编译器带来的静态查错系统，使得实际写出来的 Python 代码中经常包含大量的错误。

\begin{note}
  在Python的较新版本中引入了“类型注释”，例如\texttt{func(para: int) -> int}。VS Code的Pylance插件能够识别类型注释，并在编辑器中提供有限的类型检查。一些新生代程序员在编写程序时，会使用类型注释来帮助自己检查代码的正确性，防止出现错误。在C++的较新版本中，也引入了“类型推断”，我们可以把部分变量声明为\texttt{auto}类型，例如\texttt{for(auto item : items)}，其中\texttt{items}是一个列表。编译器能够自动推断变量的类型，从而减少了代码的冗余。由此可见，编程语言的发展是不断演进的，程序员们不断引入新的特性和语法，以提高代码的可读性和可维护性；同时，我们还可以看到，强类型语言和动态类型语言之间的界限正在逐渐模糊。
\end{note}

\subsection{学会阅读错误信息}

从上文中我们知道，代码中出现错误是不可避免的一件事情。有时候，我们会犯较为低级的语法错误，此时编辑器会自动指出问题；有时候，我们在只有在代码跑起来的时候才能发现程序错误、不能执行，此时编译器或解释器会给出错误信息，帮助我们定位问题所在；还有一些时候，程序自己运行时并没有因为致命错误而停止运行，但是输出的结果并不是我们期望的，此时我们只能通过调试来解决问题。

例如，以下是C++初学者常见的错误：

\begin{lstlisting}[language=C++]
  #include<iostream>
  using namespace std;
  int mian()
  {
      cout<<"Hello World!"<<endl;
      return 0;
  }
\end{lstlisting}

而它的错误信息是在编译时报出：

\begin{lstlisting}[language=bash]
> g++ example.cpp -o example.exe

ld.exe: *.a(lib64_libmingw32_a-crtexewin.o): in function `main':
C:/.../crtexewin.c:70: undefined reference to `WinMain'
collect2.exe: error: ld returned 1 exit status
\end{lstlisting}

虽然信息略显抽象，但我们还是可以看到很多有用的信息。 ld 是 C++ 中的链接器，再往上看可以发现对 WinMain 的引用是未定义的。这提示我们去看 main 函数，从而发现这里将\texttt{main}函数写成了\texttt{mian}，因此链接器无法找到 main 函数，从而引发错误。

而Python给出的错误信息则更为直观，例如以下代码：

\begin{lstlisting}[language=Python]
def calc(numbers):
  total = sum(numbers)
  count = len(numbers)
  return total / count

numbers = [10, 20, 30, 40, 50]
print("Average:", calc(numbers))

numbers.append("60")
print("Updated Average:", calc(numbers))
\end{lstlisting}

其报错是：
\begin{lstlisting}[language=bash]
Average: 30.0
Traceback (most recent call last):
  File "example.py", line 10, in <module>
    print("Updated Average:", calc(numbers))
  File "example.py", line 2, in calc
    total = sum(numbers)
TypeError: unsupported operand type(s) for +: 'int' and 'str'
\end{lstlisting}

可以看到，解释器对第10行和第2行进行了报错。第10行的报错是因为在调用\texttt{calc}函数时，传入的\texttt{numbers}列表中包含了一个字符串“60”，而\texttt{calc}函数期望的是一个数字列表，因此在计算平均值时出现了类型错误（TypeError）。而第2行的报错则是因为在计算总和时，无法将整数和字符串相加。于是我们发现了问题所在：在第9行，我们向\texttt{numbers}列表中添加了一个字符串“60”，而不是一个数字。我们可以通过将其改为\texttt{numbers.append(60)}来解决这个问题。

顺便一提，这段代码在C++这种强类型语言中是无法通过编译的（\texttt{List<int>}类型不能进行append(string)），但 Python 的解释器还是运行代码直到遇到了具体的问题，在输出信息中可以看到第一个 \texttt{print()} 语句仍然被正常地执行。

\subsection{学会调试}\label{subsec:debugging}

调试（技术人一般直接说debug）是我们发现和修复代码中隐藏起来的错误的最有力工具。调试可以帮助我们理解代码的执行流程，从而\textbf{定位}问题所在。

调试有两种手段：静态调试和动态调试。前者一般是通过静态分析工具（例如反汇编器）来分析代码的结构和逻辑，寻找潜在的问题；后者则是通过运行代码并观察其行为来发现问题。静态调试通常用于编译型语言且难度极高，我们不会涉及；而动态调试则适用于所有语言，接下来的内容我们将主要介绍动态调试。

C系有着自己的调试器：GDB（GNU Debugger），它是一个强大的调试工具，可以在命令行中使用。GDB可以让我们逐行执行代码，查看变量的值，设置断点等。VS Code也集成了GDB，可以通过图形界面进行调试。Python也有类似的调试器：PDB（Python Debugger），它同样可以在命令行中使用，也可以通过VS Code进行调试。

纯命令行调试的方式极为困难（尤其是GDB，需要背诵大量的命令），我们在这里不做介绍。然而，VS Code提供了一个非常友好的调试界面，可以通过图形化的方式进行调试。我们可以在代码中设置断点，逐行执行代码，查看变量的值等。这样可以大大提高调试效率。（当然这需要你安装GDB，安装并配置的过程见\ref{sec:configure-cpp}。）

我们调试主要有以下几个手段：打日志、打断点、写测试代码。

\subsubsection{打日志}

打日志是指在代码中添加打印语句，以便在运行时输出某些特定变量的值，进而确定程序的执行流程。这样可以帮助我们理解代码的执行过程，定位问题所在。

新人常常不喜欢这种手段，因为它需要在代码中添加额外的打印语句，很丑陋、不优雅，且会影响代码的可读性和维护性。但是打日志是一个非常有效的调试手段，尤其是在工程量巨大、无法或者很难打断点的情况下。

例如我在调试某数万行的大型项目时，出现断言错误。于是本人在代码中添加了以下打印语句：

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/printlog.png}
  \caption{打日志的例子}
\end{figure}

这样我就知道了程序在执行到这里的时候，返回的不是预期的200，而是404。于是这让我顺藤摸瓜，排查可能会导致404的原因，最终发现是因为某个API的返回值发生了变化，导致程序无法正常运行。

这是打日志的一个典型例子。通过在代码中添加打印语句，我们可以快速定位问题所在，并进行修复。

\subsubsection{打断点}

在VS Code中，我们可以通过点击行号左侧的空白区域来设置断点。断点是调试过程中非常重要的工具，它可以让代码执行到特定的某行时暂停，从而查看当前的变量值和程序状态。

我们可以逐行执行代码，查看变量的变化，从而定位问题所在。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/breakpoints.png}
  \caption{打断点的例子}
\end{figure}

这样就可以打出一个断点。在调试过程中，当程序执行到断点所在的行时，程序会暂停，我们可以查看当前的变量值和程序状态。我们可以通过单步执行（Step Over）来逐行执行代码，或者通过单步进入（Step Into）来进入函数内部进行调试。对于小型项目或者单文件项目，打断点是一个非常有效的调试手段。

\subsubsection{写测试代码}

写测试代码是指编写一些专门用于测试的代码，以便在运行时验证程序的正确性。测试代码可以帮助我们发现潜在的问题，并确保程序的功能正常。这也是用于较大型项目的调试手段，但是小型项目也可以使用。我们可以在这些测试代码中模拟各种可能出现的情况（包括常规值、边界值、异常值等），从而验证程序的正确性和健壮性。

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/tests.png}
  \caption{我为本人实习的项目编写的集成测试}
\end{figure}

\subsubsection{小结}

debug 最重要的一件事是缩小错误出现的范围，为达成这一目的我们通常会跟踪代码的行为，直到发现代码的行为与预期不符。实际上最棘手的情况是，代码只在特定的数据上出现错误，尤其是当我们无法获取程序执行日志的时候。这种情况尤见于我们在POJ上做题的时候：POJ的测试数据是不可见的，只会告诉你结果是WA、RTE还是TLE、MLE。

这时最应该做的是重新审视自己的预期（以及 OJ 题的题面），寻找是否遗漏了什么约束条件或关键信息。一份貌似运行正常的代码很有可能会在边界条件或复杂数据的情况下出问题，可以尝试手写一些处于边界条件之下的数据，或编写一个数据生成器来生成更复杂的数据。实在手足无措时，休息一下放空大脑也是很好的选择。实在走投无路之时，摇人求助也不是什么大不了的事情。debug 很可能会占用比编写代码更多的时间和精力，保持良好的心态才是 debug 的关键。

\section{Git与版本控制}

试想以下环境：我们正在写一项作业，开发工作已经基本完成，试运行也能够得到90分。此时我们希望进一步精进代码，使得分数达到95分以上；但是经过一通修改以后，发现程序再也运行不起来了。这时候距离ddl只有1小时，我们决定摆烂，提交能够得到90分的代码。然后我们根据记忆改回原来的代码的时候，发现我们再也想不起来旧代码是怎么写的了！这无疑是令人极为懊恼的。

再试想另一个环境：假设我们正在开发一个大型项目，项目中有很多人参与开发。如果使用传统的方式来分发代码，那么每个人都要手动下载代码，修改代码，然后再上传代码。这时候就会出现很多问题，例如代码冲突、版本不一致等。那这就需要专门的一个人或者几个人来管理代码的版本和分发，但是这样就会显著增加工作量和复杂度。

为了避免以上问题，我们引入了版本控制（VCS）系统。一般来说，VCS系统可以分为两类：集中式版本控制系统（CVCS，也叫中心化的）和分布式版本控制系统（DVCS，也叫去中心化的）。集中式版本控制系统的特点是所有的代码都存储在一个中心服务器上，所有的开发者都需要从中心服务器上下载代码，然后再上传代码；而分布式版本控制系统的特点是每个开发者都有一份完整的代码库，所有的操作都是在本地进行的，然后再将修改推送到中心服务器上。这样就可以避免代码冲突、版本不一致等问题。

2002 年以前，Linux 内核开发完全依赖于 Linus 一个人手工检查并合并全世界发来的补丁，这样工作量非常大。于是，Linus 的一个朋友介绍了 BitMover 公司开发的商业 VCS 软件 BitKeeper 免费授权给 Linux 开发团队使用。此举招致了 FSF 的 RMS 等人的批评，认为在自由软件开发中使用非自由软件是“道德上有污点”的行为。但是作为实用主义者的 Linus 并不在意这些事情，BitKeeper 作为去中心化的 VCS，满足了 Linus 的需求。然而好景不长，有 Linux 内核开发者逆向了 BitKeeper 的协议，致使 BitMover 公司在 2005 年决定收回其授权。Git 就是在这种条件下诞生的，据说第一版 Git 是 Linus 利用 1 周休假时间完成的。随着Linux的广泛应用，Git也逐渐成为了最流行的去中心化版本控制系统，也是目前最流行的版本控制系统。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/git.png}
  \caption{一个典型的Git工作流程}
  \label{fig:git-workflow}
\end{figure}

\subsection{Git的工作原理}

Git有三个目录共同完成版本控制：工作区、暂存区、版本库。工作区是项目目录，暂存区是一个隐藏的文件夹.git，版本库是一个隐藏的文件夹.git/objects。工作区是我们平时使用的目录，暂存区是Git用来存储修改的地方，版本库是Git用来存储所有版本信息的地方。版本库有一个指针，指向当前版本的某一节点（一般指向最新的节点）。每个节点都有一个唯一的哈希值\footnote{哈希（Hash，也叫散列）指的是固定长度、像指纹一样的唯一小串字符，可用于快速校验、查找或加密等功能。}，用来标识该节点。每个节点包含了该版本的所有文件和目录的信息，以及指向上一个版本的指针。Git使用哈希值来标识每个版本，这样可以保证每个版本都是唯一的。

这样讲解很难以理解，我们不妨举例说明：现在，Git中有一个版本为X的节点，包括文件A和文件B两个文件。这些文件存储在版本库中。此时，工作区为空，暂存区为空，指针指向X。我现在希望对它们进行修改，这个修改遵循以下过程：

\begin{enumerate}
  \item 我拿出了这些文件，并且对文件A进行修改。此时，工作区有AB两个文件，但是暂存区依然是空的。我们的任何修改都不会被暂存区记录，Git也不会知道我对这些文件进行了修改。

  \item 我觉得修改差不多了，现在把A放进暂存区。现在Git知道我对A进行了一些修改了。
    \begin{figure}[!ht]
      \begin{subfigure}[t]{0.45\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/git-graph-no-modified.png}
      \end{subfigure}
      \hfill               % 把左右撑开
      %----- 右图 -----
      \begin{subfigure}[t]{0.45\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/git-a-changed.png}
      \end{subfigure}
    \end{figure}
  \item 我又对B进行了类似的修改，此时B也进暂存区了。
  \item 我觉得修改差不多了。我认为我应该永久保存目前的状态，于是就把暂存区提交到版本库。此时版本库多了一个Y节点，指针也指向Y节点，有修改过的AB两个文件。此时，暂存区又清空了，而工作区和版本库的Y版本一致。
    \begin{figure}[!ht]
      \begin{subfigure}[t]{0.45\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/git-b-changed.png}
      \end{subfigure}
      \hfill               % 把左右撑开
      %----- 右图 -----
      \begin{subfigure}[t]{0.45\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/git-commited.png}
      \end{subfigure}
    \end{figure}
\end{enumerate}

\subsection{下载Git}

一个最简单的方式是使用Winget包管理器：

\begin{lstlisting}[language=bash]
    winget install Microsoft.git
\end{lstlisting}

或者你也可以从官方网站上下载并安装之。同样，安装的时候一定要勾选“添加到PATH”这一选项，否则你在命令行中无法使用Git。

\subsection{Git信息设置}

安装并使用Git的第一步是先编辑本地的一些信息。Git的提交需要一个用户名和一个邮箱，来对应每次提交的作者。我们可以使用以下命令来设置这些信息：

\begin{lstlisting}[language=bash]
    git config --global user.name "Your Name"
    git config --global user.email "email@example.com"
\end{lstlisting}

这样即可设置全局用户名和邮箱。如希望给某个特定仓库设置特定的用户名和邮箱，你需要在该仓库下重新执行上述命令，但是不写--global命令。

现代Git一般提倡使用main作为根分支的名称。而Git依然使用旧的master分支作为根分支，你可以使用以下命令修改为main：

\begin{lstlisting}[language=bash]
    git config --global init.defaultBranch main
    # 这条命令会修改全局的默认分支名称
\end{lstlisting}

\subsection{Git的最基本使用}

\subsubsection{提交}

要具体地在某一目录下进行版本控制，我们需要在命令行中进入到我们希望使用Git的目录下。然后我们可以使用以下命令来初始化一个Git仓库：

\begin{lstlisting}[language=bash]
    git init
\end{lstlisting}

如果你在视窗中开启了“显示隐藏文件”这类功能，你就会发现一个隐藏的文件夹.git出现在了你当前的目录下。这个文件夹就是Git用来存储版本信息的地方。

然后你可以使用以下命令来添加文件到Git仓库中（这个命令的实际意义是把文件添加到暂存区）；

\begin{lstlisting}[language=bash]
    git add <filename>
\end{lstlisting}

如果我们忘记了当前状态下有哪些文件被修改了，我们可以使用以下命令来查看当前状态：
\begin{lstlisting}[language=bash]
    git status
\end{lstlisting}

如果你觉得修改差不多了，保存文件以后，你可以使用以下命令来提交文件到Git仓库中（这个命令的实际意义是把暂存区的文件提交到版本库中）：

\begin{lstlisting}[language=bash]
    git commit -m "commit message"
\end{lstlisting}

上述内容中，-m后面是提交信息。提交信息是对本次提交的简要描述。我们建议每次提交都写上简要的提交信息，这样可以帮助我们更好地理解代码的修改历史。

\subsubsection{回退}

如果出现了先前我们说的不小心写坏了的情况，这时候就可以进行版本回退了。我们可以使用以下命令来查看当前的版本信息：

\begin{lstlisting}[language=bash]
    git log # 例如版本库是a-b-c-d-e-f-g
\end{lstlisting}

找到你希望回退到的版本的哈希值（前几位即可），然后使用以下命令来回退到该版本（这个命令会把指针回退到指定的版本，丢弃之后的所有内容，然后丢弃暂存区和工作区的所有东西）：

\begin{lstlisting}[language=bash]
    git reset --hard <commit_hash>
    # 请谨慎使用这一命令！该命令不会保留当前的修改！
\end{lstlisting}

如果你希望回退到某个版本，但是不想丢失当前的修改，你可以使用以下命令来回退到该版本（这个命令会把版本库后面的东西全部丢弃，清空暂存区，但是保留当前工作区）：
\begin{lstlisting}[language=bash]
    git reset --mixed <commit_hash>
    # 我们更加推荐这个回退方式，--mixed可以省略，或者用--soft替代。
    # 用--soft替代时，不会清空暂存区。
\end{lstlisting}

使用图解来表示一下：
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/git-reset.png}
  \caption{Git的回退操作}
  \label{fig:git-reset}
\end{figure}
可以看到，回退操作虽然会把指针回退到指定的版本并丢弃之后的版本，但是之后的版本提交依然存在于版本库中，只是被从树上摘下来了。这些提交被称为“孤立提交”。如果希望恢复或者删除这些孤立提交，可以执行以下命令：
\begin{lstlisting}[language=bash]
    git fsck --lost-found # 查看孤立提交、孤立分支等
    git checkout <commit_hash> # 进入分离头模式
    git branch <branch_name> # 创建一个分支来恢复孤立提交

    git gc --prune=now # 清理孤立提交
\end{lstlisting}
即使我们不使用\texttt{git gc}手动清理孤立提交，随着时间的推移（一般是90天提交记录过期），孤立提交也会被Git逐渐自动清理掉。

\subsubsection{排除相关文件}

有时候我们版本跟踪的时候不需要跟踪一些文件，例如具有敏感信息的文件（如密码），或者构建文件等。此时，我们可以创建一个文件 .gitignore 来阻止跟踪。例如，在Linux下，构建文件往往是*.o。那么我们可以在上述文件中加入 *.o ,之后git就会忽略这些文件。

\subsection{分支管理}

有时候我们想同时开发新功能，并且调优以前的代码，这样可能就需要两条线进行开发。这时，分支相关的功能就会很有帮助。Git 的分支功能允许我们在同一个仓库中创建多个独立的开发线，每个分支可以独立地进行提交和修改。

我们可以做如下假设：已经有一个名为main的分支，并已经有了一列提交记录A、B、C。现在，我希望开发一个新的功能，但是不想影响到main分支上的代码。这时，我们可以创建一个新的分支，例如feature，并在该分支上进行开发。

\subsubsection{创建和切换分支}

可以使用以下命令创建一个新的分支并切换到该分支：
\begin{lstlisting}[language=bash]
git checkout -b feature
\end{lstlisting}

以上等价于执行
\begin{lstlisting}[language=bash]
git branch feature <commit-hash of C>
git checkout feature
\end{lstlisting}

如果我现在想要回到main分支，可以使用以下命令：
\begin{lstlisting}[language=bash]
git checkout main
\end{lstlisting}

\subsubsection{分支变基}

如果我们已经在feature分支上进行了多次提交F、G，同时在main分支上也有了新的提交D、E。现在想要将feature这些提交变基到main分支上，可以使用以下命令：
\begin{lstlisting}[language=bash]
  git rebase main
  git checkout main
\end{lstlisting}
这样会把上述feature上的三个提交从C变基到E，变成F'和G'。我们可以用图解来理解这个过程：

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/git-rebase.png}
  \caption{分支变基示意图}
  \label{fig:git-rebase}
\end{figure}

变基操作会改变提交的哈希值。

\subsubsection{合并分支和冲突解决}

如果我们想要将feature分支上的代码合并（不是变基）到main分支上，可以使用以下命令：

\begin{lstlisting}[language=bash]
git checkout main
git merge feature
\end{lstlisting}

这时候我们在main分支上，并试图将E和G合并在一起。这时，会自动创建一个特殊的提交Merge，它有两个父提交。之后的提交就会以Merge为父提交，而不是E或G中的任何一个。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.75\textwidth]{images/git-merge.png}
  \caption{分支合并示意图}
  \label{fig:git-merge}
\end{figure}

如果这两个提交没有冲突，那么合并会自动完成。但是如果有冲突（例如两个分支涉及到同一行的修改），Git 会提示我们解决冲突。此时，我们不得不手动解决冲突。我们会看到以下内容（或者其英文版本）：
\begin{lstlisting}[language=bash]
  自动合并 example1.txt
冲突（内容）：合并冲突于 example1.txt
自动合并失败，修正冲突然后提交修正的结果。
\end{lstlisting}
此时，我们需要打开冲突的文件，手动解决冲突。Git 会在冲突的地方插入标记，例如：
\begin{lstlisting}[language=bash]
  <<<<<<< HEAD
  这是 main 分支上的内容。
  =======
  这是 feature 分支上的内容。
  >>>>>>> feature
\end{lstlisting}
我们需要手动编辑这个文件，删除这些标记，并保留我们想要的内容。

如果使用Code等编辑器，通常会有冲突解决的工具，可以帮助我们更方便地解决冲突。

解决完冲突后，我们需要使用以下命令来标记冲突已解决：
\begin{lstlisting}[language=bash]
  git add .
  git merge --continue
\end{lstlisting}

\subsubsection{删除分支}

如果我们已经完成了feature分支上的开发，并且已经将其合并到main分支上，可以使用以下命令删除该分支：
\begin{lstlisting}[language=bash]
git branch -d feature
\end{lstlisting}

一般不建议直接删除分支，而是使用 \texttt{-d} 选项来删除已经合并的分支。如果分支没有被合并，可以使用 \texttt{-D} 选项强制删除。

\subsubsection{压缩提交}

有时候，我们在开发过程中，可能会有很多小的提交，这些提交可能是一些临时的修改或者调试信息。为了保持代码和版本库的整洁，我们可以使用 Git 的压缩提交功能，将多个提交合并为一个提交。这个压缩功能被称作是\textbf{Squash}，但是特别注意：没有\texttt{git squash}命令。

我们一般只在分支合并的时候使用压缩提交。可以使用以下命令中的一个来压缩提交：
\begin{lstlisting}[language=bash]
git merge --squash feature
\end{lstlisting}

\subsection{标签管理}
标签（Tag）是 Git 中用于标记特定提交的功能。标签通常用于标记版本发布或重要的里程碑。与分支不同，标签是静态的，不会随着提交而移动。

\subsubsection{创建标签}
可以使用以下命令创建一个标签：
\begin{lstlisting}[language=bash]
git tag v1.0
\end{lstlisting}

这将创建一个名为 v1.0 的标签，指向当前的提交。如果需要为特定的提交创建标签，可以在命令中指定提交的哈希值：
\begin{lstlisting}[language=bash]
git tag v1.0 <commit-hash>
\end{lstlisting}

\subsubsection{查看标签}
可以使用以下命令查看所有标签：
\begin{lstlisting}[language=bash]
git tag
\end{lstlisting}

\subsubsection{删除标签}
如果需要删除一个标签，可以使用以下命令：
\begin{lstlisting}[language=bash]
git tag -d v1.0
\end{lstlisting}

\subsection{“摘樱桃”}

Cherry-Pick（摘樱桃）操作（也叫挑拣）是指从一些提交中选择一些特定的提交（修改），并将这些提交（修改）应用到当前分支上。这适用于当我们只想要一些特定的提交而不是整个分支的所有提交的时候。

一般，CherryPick操作很难使用命令行来操作，其复杂程度过高。我们可以使用VS Code的自带Git视窗或者GitLens等工具来进行这个操作。

使用视窗进行挑拣非常方便，我们只需要在提交列表中选择需要的提交，然后右键点击“Cherry-Pick”（汉化应该是挑拣）即可。这样会将选中的提交应用到当前分支上。

\section{GitHub与多人协作}

\subsection{远程仓库}

很多项目无法只在一台机器上进行开发，往往都需要在远程部署一个仓库（例如GitHub、GitLab等，或者公司自建库），然后将本地的代码推送到远程仓库中。这样，我们就可以在不同的机器上从远程仓库中拉取代码，从而保证代码的一致性。

在本节，我们将使用 GitHub 作为远程仓库的示例，介绍如何将本地仓库与远程仓库进行关联、推送和拉取代码。

\subsubsection{创建仓库}
首先，我们需要在 GitHub 上创建一个新的仓库。创建完成后，GitHub 会提供一个远程仓库的 URL，例如：
\begin{lstlisting}
  https://github.com/YourName/example.git
\end{lstlisting}
我们可以在GitHub上的仓库页面中找到这个 URL，如图所示。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.5\textwidth]{images/example.png}
  \caption{GitHub 上的仓库页面}
  \label{fig:github-repo}
\end{figure}

接下来，我们需要将本地仓库与远程仓库关联。可以使用以下命令：
\begin{lstlisting}[language=bash]
git remote add origin <your-repo-url>
\end{lstlisting}
这将把远程仓库的 URL 添加为名为 origin 的远程仓库。origin 是习惯上的远程仓库名称。

现在我们要将这个本地仓库的代码推送到远程仓库中。可以使用以下命令：
\begin{lstlisting}[language=bash]
git push -u origin main
\end{lstlisting}
这里的 \texttt{-u} 选项表示将本地的 main 分支与远程的 main 分支关联起来，以后可以直接使用 \texttt{git push} 和 \texttt{git pull} 命令进行推送和拉取。

如果本地分支名称和远程有区别，（例如本地仓库主要分支是master，而远程仓库的主要分支是main），我们可以使用以下命令来推送代码：
\begin{lstlisting}[language=bash]
git push -u origin master:main
\end{lstlisting}
这将把本地的 master 分支推送到远程的 main 分支。

\subsubsection{使用仓库}

如果你是仓库的使用者，想要从远程仓库中拉取代码（但是本地没有这个仓库），可以使用以下命令：

\begin{lstlisting}[language=bash]
git clone <your-repo-url>
\end{lstlisting}

这样会在本地创建一个\textbf{新的}目录，并将远程仓库的代码克隆到该目录中。在克隆代码的时候，Git 会自动创建与远程同名的分支，并把它们与远程的 main 分支关联起来。

如果你已经有了本地仓库，并且想要将远程仓库的代码拉取到本地，经典的操作是以下命令：
\begin{lstlisting}[language=bash]
git pull origin main
\end{lstlisting}
直接使用 \texttt{git pull} 命令也是可以的，因为我们之前已经使用 \texttt{-u} 选项将本地分支与远程分支关联起来了。然而，需要注意的是现代的拉取操作往往不推荐使用 \texttt{git pull} 命令，因为它会自动合并远程分支的代码到本地分支，这可能会导致冲突。更推荐的做法是先使用 \texttt{git fetch} 命令拉取远程仓库的代码，然后再手动合并：
\begin{lstlisting}[language=bash]
git fetch origin
git merge origin/main
\end{lstlisting}
这样可以更好地控制合并过程，避免自动合并带来的问题。

如果你在本地做出了一些修改，想要将这些修改推送到远程仓库，可以使用以下命令：
\begin{lstlisting}[language=bash]
git push origin main
\end{lstlisting}
直接使用 \texttt{git push} 命令也可以。

如果存在某些提交在远程仓库中，而本地仓库没有这些提交，Git 会提示你先拉取远程仓库的代码，然后再推送本地的修改。这是因为 Git 不允许直接推送到远程仓库，除非本地仓库是最新的。如果你确定你不需要远程仓库的提交，可以使用以下命令强制推送本地的修改：
\begin{lstlisting}[language=bash]
git push -f origin main
\end{lstlisting}

\begin{warning}
  强制推送会覆盖远程仓库的代码，可能会导致其他工作丢失，因此请谨慎使用。
\end{warning}

\subsection{GitHub界面指南}

我们打开GitHub的一个仓库的时候，映入眼帘的类似这张图片内容。可以看到，这些图片中有很多不同的概念和功能。我们来逐一介绍一下。

\begin{figure}[!ht]
  \centering
  \includegraphics[width=\textwidth]{images/github.png}
  \caption{GitHub 仓库页面}
  \label{fig:github}
\end{figure}

在上面的一栏中，我们可以看到以code、issues、pull requests等为标题的选项卡。每个选项卡对应着一个功能模块。

\begin{itemize}
  \item \textbf{Code}：代码模块，显示仓库中的代码文件和目录结构。我们可以在这里浏览代码、下载代码、查看提交历史等。
  \item \textbf{Issues}：问题模块，用于跟踪和管理项目中的问题和任务。我们可以在这里创建新的问题、查看已有的问题、评论和解决问题等。在Gitea上，问题模块被称为“工单”（Tasks），这与它常用于公司自建库的特点有关。
  \item \textbf{Pull Requests}：合并请求模块，用于管理代码的合并和审查。我们可以在这里创建新的合并请求、查看已有的合并请求、评论和审查代码等。Pull Request（简称 PR）是 GitHub 和 GitLab 等平台提供的一种代码审查和合并的机制，具体内容可以参考\ref{sec:pull-request}节。
  \item \textbf{Actions}：自动化模块，用于管理项目的自动化工作流。我们可以在这里创建新的工作流、查看已有的工作流、运行和调试工作流等。
  \item \textbf{Projects}：项目模块，用于管理项目的进度和任务。我们可以在这里创建新的项目、查看已有的项目、添加任务和卡片等。
  \item \textbf{Wiki}：维基模块，用于管理项目的文档和知识库。我们可以在这里创建新的页面、编辑已有的页面、添加图片和链接等。GitHub Wiki 是 GitHub 提供的一种文档管理工具，可以帮助我们编写和维护项目的说明文档。
  \item \textbf{Security}：安全模块，用于管理项目的安全性和漏洞。我们可以在这里查看项目的安全报告、修复漏洞、配置安全策略等。
  \item \textbf{Insights}：洞察模块，用于分析项目的活动情况，例如提交历史、问题和合并请求的统计信息等。我们可以在这里查看项目的活跃度、贡献者的统计信息、代码的质量和覆盖率等。
  \item \textbf{Settings}：设置模块，用于管理项目的设置和配置。我们可以在这里修改项目的名称、描述、权限等属性。
\end{itemize}

靠下一行就是仓库的名称，右面是仓库的描述和一些操作按钮。Star 用来标记喜欢的仓库，Fork 用来复制仓库到自己的账户下，Watch 用来关注仓库的更新。

再靠下一行，我们可以看到仓库的分支（Branch）和提交（Commit）信息。分支是代码的不同版本，提交是代码的历史记录。我们可以在这里切换分支、查看提交历史、比较不同分支的差异等。同一行的那个绿色的Code按钮是用来下载代码的，可以选择下载为 ZIP 文件或者使用 Git 克隆仓库。我们非常推荐使用 Git 克隆仓库，因为这样可以更方便地管理代码和提交。

页面的左下方部分，在文件目录之下，是仓库的readme文件内容。README 文件是仓库的说明文档，通常包含项目的介绍、安装和使用说明、贡献指南等信息。我们可以在这里查看项目的详细信息。

页面右侧的一列是仓库的统计信息，包括提交历史、分支、标签、贡献者等。我们可以在这里查看项目的活跃度、贡献者的统计信息、代码的质量和覆盖率等。同时，我们也可以在这里找到仓库的发行版等信息。

\subsection{多人协作}

成熟的项目往往是由多人协作完成的，因此需要一些规范来管理代码的提交和合并等。GitHub、GitLab等提供了多种方式来支持多人协作，包括分支管理、代码审查、合并请求等。

\subsubsection{Fork}

Fork 是 GitHub 和 GitLab 等平台提供的一种代码复制和协作的机制。它允许用户将其他人的仓库复制到自己的账户下，从而可以在自己的仓库中进行修改和提交。这样可以使得修改更加方便（主要是防止权限不够），并且可以避免直接修改原仓库的代码。当然，权限足够的情况下，我们往往会直接在原仓库中创建新分支进行修改。

\subsubsection{Pull Request}\label{sec:pull-request}
Pull Request（简称 PR）是 GitHub 和 GitLab 等平台提供的一种代码审查和合并的机制。它允许开发者在完成某个功能或修复某个问题后，将自己的代码提交到主分支（通常是 main 或 master）之前，先进行代码审查和讨论。

PR 的工作流程通常如下：

\begin{enumerate}
  \item 开发者fork（分叉）一个仓库，或者在原仓库中创建一个新的分支。
  \item 开发者在自己的分支上进行开发，完成某个功能或修复某个问题。
  \item 创建一个PR，请求将自己的分支合并到主分支。PR 中可以包含对代码的描述、相关问题的链接等信息。
  \item 其他开发者可以对 PR 进行代码审查，提出修改意见或建议。
  \item 开发者根据审查意见修改代码，并更新 PR。
  \item 当 PR 获得足够的审查和批准后，可以将其合并到主分支。通常会有一个维护者或项目负责人来执行这个操作。
  \item 合并后，PR 会被关闭，相关的分支可以被删除；也可以保留，以便后续的开发和维护。
\end{enumerate}

\subsubsection{Lint}

在多人协作中，代码风格和规范的一致性非常重要。Lint 工具可以帮助我们检查代码中的潜在问题和不符合规范的地方。常见的 Lint 工具有 ESLint（用于 JavaScript）、Pylint（用于 Python）等。

如果我们在仓库中包含了 Lint 工具的配置文件（例如 .eslintrc.json 或 .pylintrc），那么在提交代码时，Git 会自动运行 Lint 工具，对代码进行检查。如果代码不符合规范，Lint 工具会给出相应的错误或警告信息。

Lint 工具通常会在 PR 中自动运行，并将检查结果反馈给开发者。开发者可以根据检查结果修改代码，确保代码符合项目的规范。

\subsubsection{成熟项目的分支管理策略}

在成熟的项目中，一般会采用一些分支管理策略来规范分支的使用和合并等。一般说来，同一个仓库中会有以下几种分支：（以下是Git Flow的工作管理策略）
\begin{itemize}
  \item main/master：主分支，通常是代码的稳定版本。一般禁止直接提交代码，只能通过合并其他分支来进行更改。
  \item develop/dev：开发分支，一般是集成了所有的新功能的基准分支，是开发的主要分支。该分支从main分出，最终也要进入main分支。对于一些较为轻量级的项目，有时候会直接使用feature分支来代替develop分支。
  \item feature/\textit{feature-name}：功能分支，每个新功能或改进都在独立的分支上进行开发。不同的开发者可以在不同的功能分支上工作，完成后再合并到develop分支。在功能完成开发后，通常会删除该分支。
  \item hotfix/\textit{hotfix-name}：热修复分支，一般是绕过开发流程，直接从main分支分出，修复完成后再合并回main分支和develop分支。热修复分支通常用于修复生产环境中的紧急问题，在问题彻底解决之后，该分支往往会被删除。
  \item release/\textit{release-name}：发布分支，一般用于准备发布新版本的代码。该分支从develop分出，经过测试和修复后再合并回main分支和develop分支。发布分支通常用于准备发布新版本的代码。在发布完成后，通常会删除该分支。不过现在往往会直接使用打标签的方式来替代发布分支。
\end{itemize}

开发的一般流程是：在main分支上发布了第一个稳定的版本后，会分出一个dev分支。之后，通常会禁止大多数人对main进行直接提交或者合并，所有新功能都在dev分支上开发，具体的形式是从dev分支上分出多个feature分支来进行多线、多功能的同时开发，且对于大型项目，dev分支往往也只允许合并，禁止小的提交。

有时候合并进dev分支的代码可能存在一些问题，而测试和检查又疏忽，导致合并进main分支之后出现了错误。此时，我们需要直接从main分支分出一个hotfix分支来修复问题，可能会采用一些临时的策略来修复问题。修复完成后，hotfix分支会被合并回main分支。在这之后，main分支会被合并进dev分支以同步代码，然后对hotfix分支上出现的问题加以更稳定的修复。在修复完成后，再将dev分支合并进main分支，此时可以删除hotfix分支。

除了Git Flow，还有其他一些分支管理策略，例如GitHub Flow、GitLab Flow等。GitHub Flow 是 GitHub 提出的分支管理策略，主要用于快速迭代和持续集成，其开发非常轻量级，一般只有 main/master 和 feature 分支。GitLab Flow 则是 GitLab 提出的分支管理策略，多出了产品分支和预发布分支等，分别用于生产环境和预发布环境。

\section{密钥与远程}

在初阶课程中，我们已经知道了密钥是什么东西，并且知道了在大多数的情况下要使用密钥而不是密码来进行身份验证。但是关于“怎么使用和管理”密钥，则没有进行详细介绍。在本节中，我将会详细地介绍密钥的使用和管理。

密钥是一种加密技术，用于保护数据的安全性和完整性。密钥的设计通常基于非常困难的数学问题，例如大数分解、椭圆曲线等。密钥通常分为两种类型：对称密钥和非对称密钥。对称密钥使用相同的密钥进行加密和解密，可以理解为家里的每一个人都使用同一把钥匙来开门，如果钥匙丢了（密钥泄漏）则加密的数据就不再安全。非对称密钥使用一对密钥进行加密和解密，通常称为公钥和私钥，可以理解为旧式邮箱，所有人都可以往信箱里投信（公钥），但是只有邮递员（私钥）可以打开信箱取信。非对称密钥的安全性更高，因为即使公钥泄漏，私钥依然是安全的。

现代加密技术往往使用混合加密方式，即使用非对称密钥来交换对称密钥，然后使用对称密钥来加密数据。这样可以兼顾安全性和效率。

对于个人而言，最常用的加密方式是以SSH为代表的非对称密钥加密方式。SSH（Secure Shell）是一种网络协议，用于在不安全的网络上进行安全的远程登录和其他网络服务。SSH 使用非对称密钥加密技术来保护数据的安全性和完整性。

\subsection{SSH密钥的生成}

在Windows上，我们需要安装系统功能OpenSSH Client来进行密钥的初步使用。在Linux和Mac上，OpenSSH通常是预装的。如果没有安装，请自行查找相关资料进行安装。

在安装完成后，我们可以使用以下命令来生成密钥对：
\begin{lstlisting}[language=bash]
ssh-keygen -t rsa -b 4096 -C "<你的邮箱地址>"
\end{lstlisting}

上述命令会生成一个 RSA 密钥对，密钥长度为 4096 位，并且会在密钥中添加一个注释（通常是你的邮箱地址）。执行该命令后，会提示你输入密钥的保存路径和密码。默认情况下，密钥对会保存在 \texttt{\textasciitilde/.ssh/id\_rsa} 和 \texttt{\textasciitilde/.ssh/id\_rsa.pub} 中。

RSA密钥对是最常用的密钥对之一，不过因为 RSA 密钥对的安全性已经不如以前了，因此现在推荐使用 Ed25519 密钥对。可以使用以下命令生成 Ed25519 密钥对：
\begin{lstlisting}[language=bash]
ssh-keygen -t ed25519 -C "<你的邮箱地址>"
\end{lstlisting}

生成密钥对后，我们需要将公钥（\texttt{id\_rsa.pub} 或 \texttt{id\_ed25519.pub}）添加到远程服务器或服务（例如 GitHub、GitLab、CLab 等）的 SSH 密钥列表中。我们可以使用任何喜欢的编辑器打开上述公钥文件，复制其中的内容，并将其粘贴到指定的位置。\textbf{\color{red}同时，私钥（\texttt{id\_rsa} 或 \texttt{id\_ed25519}）必须保密，绝对不能泄露给任何人！}

如果我们本地是Linux或者Mac且能够直接访问远程服务器，可以使用以下命令将公钥复制到远程服务器上：
\begin{lstlisting}[language=bash]
ssh-copy-id user@remote-server
\end{lstlisting}

我们也可以手动将公钥复制到远程服务器的 \texttt{\textasciitilde/.ssh/authorized\_keys} 文件中。我们可以使用记事本或者code等编辑器打开公钥文件，复制其中的内容，然后在远程服务器上使用以下命令将其添加到 \texttt{\textasciitilde/.ssh/authorized\_keys} 文件中。以上方法适用于无法使用 ssh-copy-id 命令的情况，例如Windows系统。

为了保护私钥的安全，我们可以为私钥设置一个密码。这样，在使用私钥进行身份验证时，需要输入密码才能解锁私钥。可以在生成密钥对时设置密码，也可以在后续使用 \texttt{ssh-keygen} 命令修改密码。

设置密码的方式非常简单。在生成密钥对时，系统会提示你输入密码。如果你不想设置密码，可以直接按 Enter 键跳过。

如果你已经生成了密钥对，但没有设置密码，可以使用以下命令为私钥设置密码：
\begin{lstlisting}[language=bash]
ssh-keygen -p -f ~/.ssh/id_rsa
\end{lstlisting}

实际上如果保密需求不是非常高的话，我们可以不设置密码。因为使用密钥除了安全性以外，最大的好处是可以免去每次连接远程服务器时输入密码的麻烦。而如果设置了密码，则每次连接远程服务器时都需要输入密码，这样就失去了使用密钥的便利性。

\subsection{密钥的使用}

在生成密钥对并将公钥添加到远程服务器或服务后，我们就可以使用密钥进行身份验证了。使用密钥进行身份验证的方式与使用密码类似，只不过需要指定私钥文件。

\subsubsection{连接到远程服务器}

可以使用以下命令连接到远程服务器：
\begin{lstlisting}[language=bash]
ssh -i ~/.ssh/id_rsa user@remote-server
\end{lstlisting}
如果你使用的是 Ed25519 密钥对，则需要将 \texttt{id\_rsa} 替换为 \texttt{id\_ed25519}。

如果你已经将私钥添加到 SSH Agent（实际上这确实是更一般的情况）中，可以直接使用以下命令连接到远程服务器：
\begin{lstlisting}[language=bash]
ssh user@remote-server
\end{lstlisting}

\subsubsection{Git托管}

GitHub的有两种托管代码的方式：HTTPS 和 SSH。HTTPS 是通过用户名和密码进行身份验证，而 SSH 是通过密钥进行身份验证。我们建议使用 SSH 进行身份验证，因为它更加安全和方便，且无需忍受网络代理的折磨。

我们需要将公钥添加到 GitHub 的 SSH 密钥列表中。可以在 GitHub 的设置页面中找到 SSH 密钥列表，然后点击“添加 SSH 密钥”按钮，将公钥粘贴到文本框中。

如果你使用的是 Windows 系统，可能需要将公钥转换为 OpenSSH 格式。可以使用以下命令将公钥转换为 OpenSSH 格式：
\begin{lstlisting}[language=bash]
ssh-keygen -i -f ~/.ssh/id_rsa.pub
\end{lstlisting}

添加公钥后，我们就可以使用 SSH 进行身份验证了。在某些情况下，我们可能需要手动指定使用的哪一个密钥文件。可以使用以下命令将 SSH 密钥添加到 SSH Agent 中：
\begin{lstlisting}[language=bash]
ssh-add ~/.ssh/id_rsa
\end{lstlisting}

这样可以免去每次连接远程服务器时指定密钥文件的麻烦。

\subsection{使用VS Code建立SSH连接}

除了使用终端建立SSH连接到远程服务器以外，还可以使用一些其他的工具来建立SSH连接。这时候我们还要请出那位大神：VS Code（怎么哪都有你）。

VS Code 提供了一个名为 Remote-SSH 的扩展，可以帮助我们通过 SSH 连接到远程服务器，并在远程服务器上进行开发。这样，可以在SSH连接中使用一个很方便的图形化界面，以进行和Windows相似的便捷操作。

安装 Remote-SSH 扩展后，我们可以在 VS Code 的界面找到远程连接的选项，一般是左下角的蓝色按钮，图标类似这个$\lessgtr$数学符号。点击这个按钮后，会弹出一个菜单，点选“连接到主机”选项，会让你输入\texttt{user\@ host}类似的远程服务器地址。输入完成后，如果是一个新的远程服务器，Code会让你把它加入到已知主机列表中，用户可以视情况添加到系统配置文件或者其他的配置文件中。

然后，Code会弹出一个新的窗口，试图连接到远程服务器，可能会要求你输入远程服务器的密码和系统类型等信息。连接完成后，就可以在远程服务器上进行开发了。此时，Code会在左侧的资源管理器中显示远程服务器的文件系统（当然你需要打开一个文件夹）。

在Code中，如果不是用终端而是用Code的图形界面来打开新的文件夹，那么每一次打开文件夹都会重新进行一次身份验证。如果你使用的是密码，则需要反复输入，非常麻烦。这时我们一定要尽可能地使用密钥进行登录。


\end{document}
